<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>
</title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body background="../FON.JPG" BGCOLOR="#E7E3E7" TEXT="#000000" LINK="#004080" VLINK="#004080">
<table COLS="3" WIDTH="16%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="Index4.htm">
<img SRC="Back.gif" BORDER="0">
</a>
</font>
</td>
<td WIDTH="10%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0" width="73" height="22">
</a>
</font>
</td>
<td ALIGN="RIGHT">
<font face="Arial, Helvetica, sans-serif">
<a href="Index6.htm">
<img SRC="For.gif" BORDER="0">
</a>
</font>
</td>
</tr>
</table>
<p>
&nbsp;
</p>
<p align="center">
<font face="Arial, Helvetica, sans-serif" size="3">
<font size="4">
Двоично-десятичные числа
</font>
<br>
</font>
</p>
<p align="left">
<font face="Arial, Helvetica, sans-serif" size="3">

 
  В гл. 2 уже говорилось о двоично-десятичных числах - специальном формате хранения 
  данных, используемом в ряде технических приложений. Часто эти числа называют 
  BCD-числами (от binary-coded decimal, двоично-кодированные десятичные числа). 
  Для обработки BCD-чисел (сложения, вычитания, умножения и деления) в МП 86 предусмотрены 
  специальные команды. Рассмотрим этот вопрос на комплексном примере обработки 
  показаний КМОП-часов реального времени.<br>
  Как известно, в современных компьютеров имеются два независимых таймера. Один 
  из них (&quot;часы реального времени&quot;) включен в состав микросхемы с очень 
  низким потреблением тока, питается от батарейки или аккумулятора, находящегося 
  на системной плате, и работает даже на выключенной из сети машине. В этом таймере 
  хранится и автоматически наращивается текущее календарное время (год, месяц, 
  день, час, минута и секунда). <br>
  После включения компьютера вступает в работу другой таймер, который обычно называют 
  системным. Датчиком сигналов времени для него служит кварцевый генератор, работающий 
  на частоте 1,19318 МГц, сигналы от которого, после пересчета в отношении 65536:1, 
  поступают в контроллер прерываний и инициируют прерывания через вектор 8 с частотой 
  18,2065 Гц. Эти прерывания активизируют программу
BIOS, периодически выполняющую 
  инкремент содержимого четырехбайтовой ячейки памяти с текущим временем, находящейся 
  по адресу 46Ch. После включения машины программы BIOS считывают из часов реального 
  времени текущее время суток, преобразуют его в число тактов системного таймера 
  (т.е. в число интервалов по 1/18,2065 с) и записывают в ячейку текущего времени.
  Далее содержимое этой ячейки наращивается уже системным таймером, работающим 
  в режиме прерываний.<br>
  Для определения текущего времени прикладная программа может вызвать соответствующие 
  функции прерывания 21h DOS (конкретно, с номером 2Ah для получения даты и 2Ch 
  для получения времени суток), а может прочитать время непосредственно из часов 
  реального времени с помощью прерывания lAh
BIOS. При этом прерывание 1А1г позволяет, 
  помимо чтения текущего времени (функция 02h) и текущей даты (функция 04h), выполнять 
  и целый ряд других функций, среди которых мы отметим только возможность установить 
  &quot;будильник&quot;, т.е. записать в микросхему часов значение календарного 
  времени, когда часы должны выдать сигнал аппаратного прерывания. Этот сигнал 
  через вектор 70h инициирует обработчик прерываний, входящий в состав
BIOS, который 
  проверяет, возникло ли данное прерывание в результате достижения времени установки 
  будильника (часы реального времени могут инициировать прерывания и по других 
  причинам), тестирует заодно батарейное питание микросхемы, а затем посылает 
  в оба контроллера прерываний команды конца прерываний и завершается командой
iret. Однако по ходу своего выполнения обработчик прерывания 70h выполняет команду 
  hit 4Ah, которая передает управление на обработчик этого прерывания, тоже входящий 
  в состав BIOS. Системный обработчик прерывания 4Ah ничего особенно полезного 
  не делает, в сущности представляя собой просто программу-заглушку. Однако программист 
  имеет возможность записать в вектор 4Ah адрес прикладного обработчика прерываний, 
  который будет активизироваться прерыванием будильника. Функции прикладного обработчика 
  определяет программист.<br>
  В примере 3-9 устанавливается прикладной обработчик прерывания 4All, который 
  сам по себе вызваться никогда не будет, так как по умолчанию будильник часов 
  реального не работает. Если, однако, прочитать системное время с помощью функции 
  02h прерывания lAh, прибавить к нему некоторую величину, например, 1 секунду, 
  и установить будильник на это время (с помощью функции 06h прерывания
lAh), 
  то через одну секунду будет активизирован наш обработчик. В примере 3-9 этот 
  процесс сделан бесконечным: в обработчике прерываний будильника снова выполняется 
  чтение времени, прибавление к нему 1 секунды и установка будильника на новое 
  время. В результате наш обработчик будет вызываться каждую секунду до завершения 
  всей программы.<br>
  Помимо служебной функции установки будильника на следующую секунду, обработчик 
  прерываний выполняет и полезную работу: он выводит текущее время в определенное 
  место экрана. Поскольку обработчик активизируется каждую секунду, выводимое 
  значение времени будет обновляться каждую секунду.<br>
  Как уже говорилось, в часах реального времени значение времени хранится в виде 
  упакованных двоично-десятичных чисел. При выполнении арифметических операций 
  с числами BCD (а нашем случае операции заключаются в прибавлении 1) необходимо 
  использовать предназначенные для этого команды процессора. В примере проиллюстрировано 
  использование одной из этих команд, конкретно, команды
daa.<br>
  Для того, чтобы вывести на экран значение времени, его надо преобразовать в 
  последовательность кодов ASCII. Процедура преобразования упакованных двоично-десятичных 
  чисел в строку символов также включена в рассматриваемый пример.</p>
<p align="center">
<font face="Arial, Helvetica, sans-serif" size="3"><b>Пример 3-9.</b>
Чтение и обработка показаний часов
реального времени</p>
<blockquote>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">.586&nbsp;&nbsp;
  ;Будут использоваться дополнительные
  команды</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">assume
  CS:code,ds:data&nbsp;</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">code
  segment use 16</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">main
  proc</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AX,data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Настроим DS наш</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  DS,Ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сегмент
  данных</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">;Сохраним
  исходный вектор 4Ah</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AX,354Ah</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">int
  21h</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  word ptr old_4a,BX</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  word ptr old_4a+2,ES</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">;Установим
  наш обработчик прерываний 4Ah</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AX,254Ah</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">push
  DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Сохраним DS</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">push
  CS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Настроим DS на сегмент&nbsp;</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">pop
  DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;команд</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  DX,offset new_4a: DS:DX-&gt;new_4a</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">int
  21h</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">pop
  DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Восстановим DS</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">;Установим
  будильник</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">movAH,02h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Чтение текущего времени</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">int
  1Ah</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">call
  add_time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Прибавим 1 секунду</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AH,06h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Установим будильник на это время</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">int
  1Ah</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">;Остановим
  программу, чтобы наблюдать прерывания</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AH,01h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Функция ввода с клавиатуры</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">int
  21h</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">;Завершим
  программу, прибрав за собой</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AH,07h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Сброс будильника</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">int
  1Ah</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">Ids&nbsp;
  DX,old_4a/DS:DX=исходный вектор</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AX,254Ah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Установим
  исходный вектор</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">int
  21h</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AX,4C00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Завершим
  программу</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">int
  21h</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">main
  endp</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">;Наш
  обработчик прерывания от будильника new_4a
  proc</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">push
  a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Сохраним все регистры</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">push
  DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Сохраним еще и</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">push
  ES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;сегментные регистры</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AX ,seg hour&nbsp;&nbsp;&nbsp;&nbsp; ;Настроим DS на наш</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  DX,AX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;сегмент данных</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AH,02h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Прочитаем текущее время</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">int
  1Ah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;из часов реального времени</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">push
  CX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Сохраним полученное</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">push
  DX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;текущее время</font></p>
</blockquote>
<p>В примере 3-9 используются 
  несколько команд, отсутствующих в МП 86: команды сохранения в стеке и восстановления 
  всех регистров общего назначения pusha и рора, а также команда сдвига shl с 
  числовым операндом. Для того, чтобы эти команды распознавались ассемблером, 
  в программу включена 
  директива .586 (можно было бы обойтись и директивой .386). В этом случае необходимо 
  оба сегмента объявить с описателем use16.<br>
  Программа состоит из главной процедуры main, процедуры new_4a обработчика прерываний 
  от будильника, а также трех вспомогательных процедур-подпрограмм
add_time, add_unit 
  и conv. Главная процедура сохраняет исходный вектор прерывания 4Ah, устанавливает 
  новый обработчик этого прерывания, читает текущее время и устанавливает будильник 
  на время, отстоящее от текущего на 1 секунду, а затем останавливается в ожидании 
  нажатия любой клавиши. Пока программа стоит, обрабатываются прерывания от будильника 
  и в правый верхний угол экрана каждую секунду выводится текущее время. После 
  нажатия любой клавиши программа завершается, предварительно сбросив будильник 
  и восстановив исходное содержимое вектора 4Ah.<br>
  Легко видеть, что в предложенном варианте программа имеет мало практического 
  смысла, так как она не выполняет, кроме вывода времени, никакой полезной работы. 
  В то же время, пока эта программа не завершилась, запустить другую программу 
  нельзя, так как DOS является однозадачной системой. Если, однако, написать нашу 
  программу в формате .СОМ и сделать ее резидентной, мы получим возможность запускать 
  любые программы и одновременно наблюдать на экране текущее время. Такого средства 
  в DOS нет, и в какой-то ситуации оно может оказаться полезным. Методика разработки 
  резидентных программ описана выше; читатель может выполнить необходимые преобразования 
  самостоятельно.<br>
  Рассмотрим теперь программу обработчика прерываний будильника. Прежде всего 
  в нем командой pusha (push all, сохранить все) сохраняются все регистры общего 
  назначения и, кроме того, два сегментных регистра DS и
ES, которые будут использоваться 
  в обработчике. Далее регистр DS настраивается на сегментный адрес того сегмента, 
  в который входит ячейка hour, т.е. фактически на наш сегмент команд. На первый 
  взгляд это действие может показаться бессмысленным. Ведь в начале процедуры 
  main в регистр DS уже был помещен адрес нашего сегмента данных
data. Зачем же 
  эту операцию повторять? Дело в том, что процедура new_4a, будучи формально обработчиком 
  программного прерывания 4Ah, фактически представляет собой обработчик аппаратного 
  прерывания от часов реального времени, которое, как и любое аппаратное прерывание, 
  может придти в любой момент времени. В принципе прерываемая программа в этот 
  момент может выполнять любые действия, и содержимое регистра DS может быть любым. 
  Если же говорить о нашей программе, то она находится в цикле ожидания нажатия 
  клавиши. Этот цикл организует функция 01h DOS, которая, между прочим, время 
  от времени обращается к своему драйверу клавиатуры, а тот - к программам BIOS 
  ввода символа с клавиатуры. Вполне вероятно (а на самом деле так оно и есть), 
  что при выполнении упомянутых операций используется регистр
DS, который в этом 
  случае указывает уже не на наш сегмент данных, а на различные системные области. 
  Другими словами, при входе в обработчик прерывания содержимое регистра DS неизвестно, 
  и его следует инициализировать заново, обязательно сохранив исходное значение. 
  Если перед выходом из обработчика это исходное значение не восстановить, будет 
  неминуемо разрушена DOS.<br>
  Сохранив регистры и настроив DS, мы вызываем функцию 02h прерывания lAh чтения 
  текущего времени. Время возвращается, как уже говорилось, в упакованном двоично-десятичном 
  формате (по две цифры в байте) в регистрах СН (часы), CL (минуты) и DH (секунды). 
  Нам это время понадобится еще раз в конце обработчика для установки будильника 
  заново, и чтобы второй раз не вызывать функцию 02h, полученное время (т.е. содержимое 
  регистров СХ и DX) сохраняется в стеке.<br>
  Далее выполняется последовательное преобразование BCD-цифр, составляющих время, 
  в коды ASCII соответствующих символов. Число часов (две упакованные BCD-цифры) 
  переносится в регистр AL, и вызывается подпрограмма
conv, которая преобразует 
  старшую цифру часов в код ASCII и возвращает его в регистре АН. Этот код помещается 
  в объявленную в сегменте данных строку-шаблон
hour, в которой заготовлены пустые 
  пока места для символов цифр, составляющих время, а также имеются разделительные 
  двоеточия. Для удобства обращения к элементам этой строки, она разделена на 
  части и каждая часть снабжена собственным именем - min для поля минут и sec 
  для поля секунд.<br>
  Подпрограмма conv преобразования BCD-цифры в код ASCII состоит всего из трех 
  предложений, не считая заключительной команды
ret. Двух разрядное BCD-число 
  передается в подпрограмму в регистре AL. После обнуления регистра АН, который 
  будет служить приемником для образования конечного результата, содержимое AL 
  сдвигается командой shl влево на 4 бит, в результате чего старший полубайт регистра
AL, т.е. старшая цифра числа, перемещается в регистр АН (рис.
3.9). Двоично-десятичная 
  цифра представляет собой просто двоичное представление цифры; прибавление к 
  ее коду кода символа &quot;0&quot; (числа 30h) дает код ASCII этой цифры.<br>
  Мы преобразовали пока только старший полубайт регистра СН. Для выделения младшего 
  полубайта на регистр СН накладывается маска 0Fh,</p>
<p align="center"><img src="gl3-9.jpg" ></p>
<p align="center"><b>Рис. 3.9.</b> Алгоритм 
  работы подпрограммы conv.</p>
<p>которая обнуляет старший 
  полубайт, не затрагивая младшего. Прибавление кода ASCII нуля к коду десятичной 
  цифры образует код ASCII этой цифры, который и переносится затем в строку-шаблон. 
  Описанная процедура повторяется затем для регистров CL (минуты) и DH (секунды).<br>
  Для вывода строки с временем на экран используется прямое обращение в видеопамяти. 
  В регистр ES заносится сегментный адрес видеобуфера BS00h, а в регистр DI - 
  требуемое смещение видеопамяти к тому месту, начиная с которого мы хотим вывести 
  строку. В регистр SI заносится адрес строки-источника, в регистр СХ - число 
  шагов, а в регистр АН - выбранный нами атрибут символов (красные символы по 
  синему полю). Поскольку перемещение и по строке-шаблону, и по экрану должно 
  осуществляться вперед, командой сld сбрасывается флаг
DF. Наконец, циклическое 
  выполнение пары команд<br>
 </p>
<blockquote>
<p></font></font><font face="Verdana, Arial, Helvetica, sans-serif" size="3">lodsb stosw<br>
</font>
</p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">
<font face="Arial, Helvetica, sans-serif" size="3">

 
<p>приводит к выводу в заданное 
  место экрана всей строки hour.<br>
  Выполнив вывод на экран текущего времени, надо снова установить будильник. Для 
  этого сначала запрещается работа ранее установленного будильника, восстанавливается 
  текущее время в регистрах DX и СХ, и вызовом процедуры add_time к текущему времени 
  прибавляется 1 секунда. Далее вызовом функции 06h заново устанавливается будильник, 
  восстанавливаются сохраненные в начале программы обработчика регистры, и, наконец, 
  командой iret обработчик завершает свою работу.<br>
  Рассмотрим теперь процедуру прибавления 1 к текущему времени. Она состоит из 
  двух компонентов - подпрограммы add_time, которая организует правильное сложение 
  чисел, обозначающих время, чтобы прибавление 1 секунды к 59 секундам дало 0 
  секунд и увеличило на 1 число минут (и то же самое для минут) и подпрограммы
add_uuit, выполняющей прибавление 1 к упакованному коду
BCD.<br>
  Подпрограмма add_time переносит число секунд из DH в
AL, с помощью подпрограммы 
  add_unit увеличивает его на 1 и возвращает в DH. Подпрограмма add_unit сигнализирует 
  установкой флага CF о необходимости переноса 1 в следующий разряд времени (число 
  секунд составляло 59). Поэтому после возврата из add_iuit проверяется флаг CF 
  и, если он сброшен, т.е. следующий разряд времени модифицировать не надо, подпрограмма 
  add_time завершается. Если же флаг CF установлен, выполняется аналогичная процедура 
  прибавления 1 к числу минут, которое находится в регистре
CL. Далее опять анализируется 
  флаг CF, и если он установлен (текущее время было 59 мин 59 с), прибавляется 
  1 к числу часов. Наконец, подпрограмма завершается командой
ret.<br>
  Подпрограмма add_unit получает упакованное двоично-десятичное число, к которому 
  надо прибавить 1, в регистре AL. Командой add к нему прибавляется 1, после чего 
  в некоторых случаях образуется правильная сумма, а в некоторых - неправильная. 
  Так, 14h + 1 = 15h, что правильно, однако 19h + 1 = lAh, что неверно. Такого 
  двоично-десятичного числа не существует, а после прибавления 1 к 19 должно получиться 
  20 (и записано в виде 20h). Коррекцию после сложения BCD-чисел осуществляет 
  команда daa, которая в приведенном примере преобразует lAh в 20h, и которая 
  должна всегда следовать за командой сложения.<br>
  Наши двоично-десятичные числа специфичны в том отношении, что они не могут превышать 
  59. Поэтому после коррекции результат сравнивается с 60h. Если сумма меньше 
  60h, флаг CF сбрасывается и выполняется команда
ret. Если сумма равна 60h, регистр 
  AL обнуляется, флаг CF устанавливается, сигнализируя о переносе 1 в следующий 
  разряд времени (минут или часов) и выполняется та же команда
ret. Таким образом, 
  флаг CF процессора в точке возврата из подпрограммы add_unit говорит не о наличии 
  или отсутствии арифметического переноса, а выполняет роль флага &quot;исключительной 
  ситуации&quot; - перехода времени на следующую минуту или на следующий час. 
  Такое нестандартное использование флага CF является общеупотребительным приемом.</p>

<p>
&nbsp;
</p>
<table COLS="3" WIDTH="16%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="Index4.htm">
<img SRC="Back.gif" BORDER="0">
</a>
</font>
</td>
<td WIDTH="10%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0" width="73" height="22">
</a>
</font>
</td>
<td ALIGN="RIGHT">
<font face="Arial, Helvetica, sans-serif">
<a href="Index6.htm">
<img SRC="For.gif" BORDER="0">
</a>
</font>
</td>
</tr>
</table>
</body>
</html>
