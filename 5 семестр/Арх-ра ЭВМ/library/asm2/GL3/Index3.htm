<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>
</title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body background="../FON.JPG" BGCOLOR="#E7E3E7" TEXT="#000000" LINK="#004080" VLINK="#004080">
<table COLS="3" WIDTH="16%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="Index2.htm">
<img SRC="Back.gif" BORDER="0">
</a>
</font>
</td>
<td WIDTH="10%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0" width="73" height="22">
</a>
</font>
</td>
<td ALIGN="RIGHT">
<font face="Arial, Helvetica, sans-serif">
<a href="Index4.htm">
<img SRC="For.gif" BORDER="0">
</a>
</font>
</td>
</tr>
</table>
<p>
&nbsp;
</p>
<p align="center">
<font face="Arial, Helvetica, sans-serif" size="3">
<font size="4">
Обработка строк 
</font>
<br>
</font>
</p>
<p align="left">
<font face="Arial, Helvetica, sans-serif" size="3">


  Для работы со строками, или цепочками символов или чисел (т.е. попросту говоря, 
  с массивами произвольных данных) в МП предусмотрен ряд специальных команд:</p>
<p><b>movs</b> - пересылка строки;<br>
<b>
  cmps</b> - сравнение двух строк;<br>
<b>
  seas</b> - поиск в строке заданного элемента;<br>
<b>
  lods </b> - загрузка аккумулятора (регистров AL или АХ) из строки;<br>
<b>
  stos</b> - запись элемента строки из аккумулятора (регистров АХ или
AL).</p>
<p>Эти команды очень удобны, 
  однако их использование сопряжено с некоторыми трудностями, так как процессор, 
  выполняя эти команды, неявным образом использует ряд своих регистров. Только 
  если все эти регистры настроены должным образом, команды будут выполняться правильно. 
  В результате включение в программу предложения с командой, например,
movs, требует 
  иной раз 6-7 дополнительных предложений, в которых осуществляется подготовка 
  условий для правильного выполнения этой команды.<br>
  Хотя команды обработки строк, как правило, включаются в программу без явного 
  указания операндов, однако каждая команда, в действительности, использует два 
  операнда. Для команд seas и stos операндом-источником служит аккумулятор, а 
  операнд-приемник находится в памяти. Для команды
lods, наоборот, операнд-источник 
  находится в памяти, а приемником служит аккумулятор. Наконец, для команд movs 
  и cmps оба операнда, и источник, и приемник, находятся в памяти.<br>
  Все рассматриваемые команды, выполняя различные действия, подчиняются одинаковым 
  правилам, перечисленным ниже. Операнды, находящиеся в памяти, всегда адресуются 
  единообразно: операнд-источник через регистры
DS:SI, а операнд-приемник через 
  регистры ES:DI. При однократном выполнении команды обрабатывают только один 
  элемент, а для обработки строки команды должны предваряться одним из префиксов 
  повторения. В процессе обработки строки регистры SI и DI автоматически смещаются 
  по строке вперед (если флаг DF = 0) или назад (если флаг DF = 1), обеспечивая 
  адресацию последующих элементов. Каждая команда имеет модификации для работы 
  с байтами или словами (например, movsb и movsw).<br>
  Таким образом, для правильного выполнения команд обработки строк необходимо 
  (в общем случае) предварительно настроить регистры DS:SI и
ES:DI, установить 
  или сбросить флаг DF, занести в СХ длину обрабатываемой строки, а для команд 
  seas и stos еще поместить операнд-источник в регистр АХ (или AL при работе с 
  байтами).<br>
  Однако сама операция, после всей этой настройки, осуществляется одной командой, 
  которая обычно даже не содержит операндов, хотя может иметь префикс повторения.<br>
  Стоит подчеркнуть, что строки, обрабатываемые рассматриваемыми командами, могут 
  находиться в любом месте памяти: в полях данных программы, в системных областях 
  данных, в ПЗУ, в видеобуфере. Например, с помощью команды movs можно скопировать 
  массив данных из одной массивной переменной в другую, а можно переслать страницу 
  текста на экран терминала. Рассмотрим несколько примеров использования команд 
  обработки строк, ограничившись лишь теми фрагментами программ, которые имеют 
  отношение к рассматриваемому вопросу.</p>
<p align="center"><b>Пример 3-6.</b> Чтение из ПЗУ BIOS
даты его выпуска</p>

<blockquote>
<p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">;В
программном сегменте</font></p>
<p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">main
proc</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AX,0F000h&nbsp;&nbsp;&nbsp; ;Занесем в DS</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  DS,AX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Сегментный
  адрес ПЗУ BIOS</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  SI,0FFF5h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Смещение к
  интересующему нас полю</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AX,data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Настроим
  RS</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  RS,AX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;на
  сегмент данных программы</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  DI,offset bios ;Смещение к полю для хранения даты</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  CX,8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Перенести 8 байт</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">cld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Движение по строке вперед</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">rep
  movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Перенос байтов</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">;Выведем
  полученную информацию на экран</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AX,data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Теперь
  настроим DS</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  DS,AX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;на
  сегмент данных программы</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov&nbsp;
  AH,40h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Функция
  вывода</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  BX,1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Дескриптор экрана</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  CX,8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Вывести 0 байт</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  DX,offset bios&nbsp; ;Смещение в строке</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">int
  21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ; Вызов DOS</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">;В
  сегменте данных</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">bios
  db 8 dup (')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Поле для хранения
  даты</font></p>
</blockquote>
<p>Известно, что в ПЗУ
BIOS, 
  сегментный адрес которого составляет F000h (см. рис. 1.5), наряду с программами 
  управления аппаратурой компьютера, хранятся еще и некоторые идентификаторы. 
  Так, в восьми байтах ПЗУ, начиная с адреса F000h:FFFSh, записана в кодах ASCII 
  дата разработки ПЗУ. В примере 3.6 выполняется чтение этой даты, сохранение 
  ее в памяти и вывод на экран для контроля. Поскольку интересующая нас дата хранится 
  в ПЗУ BIOS в кодах ASCII, никаких преобразований содержимого этого участка ПЗУ 
  перед выводом на экран не требуется.<br>
  В программе осуществляется настройка всех необходимых для выполнения команды 
  movs регистров (DS:SI, ES:DI, CX и флага DF) и одной командой movsb с префиксом 
  rep содержимое требуемого участка ПЗУ переносится в поле
bios. Перенос строки 
  байтами подчеркивает ее формат (в строке записаны байтовые коды
ASCII), однако 
  в нашем примере, при четном числе переносимых байтов, более эффективно осуществить 
  перенос по словам. В этом варианте команда movs будет фактически повторяться 
  не 8 раз, а только 4. Для этого достаточно занести в СХ число 4 (вместо 8) и 
  использовать вариант команды niovsw.<br>
  Для выполнения команды movs нам пришлось настроить сегментный регистр DS на 
  сегмент BIOS. Если в дальнейшем предполагается обращение к полям данных программы, 
  как это имеет место в примере 3-6, в регистр DS следует занести сегментный адрес 
  сегмента данных. После этого, настроив остальные регистры для вызова функции 
  40h, прочитанную из BIOS строку можно вывести на экран.<br>
  В рассмотренном примере неявно предполагалось, что программа будет в дальнейшем 
  как-то использовать полученную из BIOS информацию. Если задача программы заключается 
  просто в выводе на экран даты выпуска BIOS, то нет необходимости сначала копировать 
  эту дату из BIOS в поля данных программы, а потом выводить ее на экран. Можно 
  было поступить гораздо проще: настроив регистр DS на сегмент
BIOS, а регистр 
  DX на адрес строки с датой, вызвать функцию 40h и вывести на экран текст непосредственно 
  из сегмента BIOS. Тогда содержательная часть программы сократится в два раза 
  и примет такой вид:</p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
AX,0F00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Настроим DS</font></p>
<p><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov DS,AX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
;на сегмент BIOS</font></p>
<p><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
AH,40h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Функция
вывода</font></p>
<p><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
BX,1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
;Дескриптор экрана</font></p>
<p><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
CX,8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
;Вывести 8 байт</font></p>
<p><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
DX,0FFFSh&nbsp;&nbsp;&nbsp; ;Смещение к дате</font></p>
<p><font face="Verdana, Arial, Helvetica, sans-serif" size="3">int
21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
;Вызов DOS</font></p>
</blockquote>
<p>Приведенный фрагмент не 
  имеет отношения к данному разделу, так как в нем уже нет команд обработки строк. 
  В то же время он подчеркивает важность сегментных регистров и гибкость сегментной 
  адресации. Функция 40h ожидает найти адрес выводимой на экран строки в регистрах
DS:DX, и никакие другие регистры в этом случае использовать нельзя. С другой 
  стороны, эти регистры можно настроить на любой участок памяти и вывести на экран 
  (а также и на принтер, в файл или в последовательный порт) данные откуда угодно.<br>
  Рассмотрим теперь пример работы с командами lods и
stos, которые можно использовать 
  как по отдельности, так и в паре друг с другом. Эти команды очень удобны, в 
  частности, для прямого обращения к видеопамяти.<br>
  К экрану, как и к любому другому устройству, входящему в состав компьютера, 
  можно обращаться тремя способами: с помощью функций DOS (прерывание 21h), с 
  использованием прерывания BIOS (для управления экраном используется прерывание 
  10h) и, наконец, путем прямого программирования аппаратуры, в данном случае 
  видеобуфера (видеопамяти). Функции DOS позволяют выводить только черно-белый 
  текст и имеют ряд других ограничений (нельзя очистить экран, нет средств позиционирования 
  курсора); при использовании прерывания BIOS все эти ограничения снимаются, однако 
  программирование с помощью средств BIOS весьма трудоемко; наконец, прямая запись 
  в видеопамять, предоставляя возможность вывода цветного текста в любую точку 
  экрана, является процедурой очень простой и, к тому же, повышает скорость вывода 
  (по сравнением с использованием системных средств) в десятки и сотни раз. Прямое 
  обращение к видеобуферу удобно использовать, например, в обработчиках прерываний, 
  где запрещен вызов функций DOS и имеются ограничения на обращение к средствам
BIOS.<br>
  Пусть по ходу программы необходимо вывести в нижнюю строку экрана предупреждающее 
  сообщение. Для этого в программу надо включить следующие предложения:</p>
<p align="center"><b>Пример 3-7.</b> Вывод на экран
прямой записью в видеопамять</p>
</font>
<blockquote>
<p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">;В
полях данных, адресуемых через DS</font></p>
<p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">msg
db 'Измерения закончены'</font></p>
<p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">msg_len=$-msg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
;Длина строки</font></p>
<p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">&nbsp;
;В программном сегменте</font></p>
<p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
SI,offset msg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
;DS:31-&gt;выводимая строка</font></p>
<p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
AX,OB800h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
;Сегментный адрес видеобуфера</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  ES,AX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Будем адресовать через ES</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  DI,25*80*2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Смещение к последней строке экрана</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  CX,msg_len&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Счетчик цикла вывода символов</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">eld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;DF=0 , движение по строке</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ; и по экрану вперед</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">mov
  AH,31h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Атрибут символов-синий по</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ; голубому</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">outher:
  lodsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ;Взять символ из строки в AL</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">show&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ; Вывод на экран символа</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ; из AL и его атрибута из AH</font></p>
  <p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">loop
  outser&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ; Цикл</font></p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Регистры DS:SI настраиваются 
  на адрес начата выводимой строки; регистры ES:DI - на адрес требуемой позиции 
  в видеобуфере. В регистр СХ надо поместить длину строки в байтах, а флаг DF 
  сбросить, чтобы двигаться по строке вперед. На экран будет выводиться содержимое 
  регистра АХ, в младшем байте которого должен находиться код ASCII выводимого 
  символа, а в старшем байте - атрибут символа, т.е. код цвета символа (в младшем 
  полубайте) и код цвета фона (в старшем полубайте). В примере число 31h образует 
  синие символы по бирюзовому фону. При желании можно выбрать другую комбинацию 
  цветов, выбрав ее с помощью табл. 3.1.</p>
  <p></p>
  <p><b>Таблица 3.1.</b> Коды цветов стандартной цветовой палитры<font face="Times New Roman, Times, serif"><b>&nbsp;
  &nbsp;&nbsp;&nbsp;</b>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;
  &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp; 
  &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;
  &nbsp; 
  &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 
  &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</font></p>
  <table border="1" width="59%">
    <tr>
      <td width="22%">
<font face="Arial, Helvetica, sans-serif" size="3">


  <b>Код&nbsp;</b></font></td>
      <td width="17%"><b> Цвет &nbsp;</b></td>
      <td width="27%"><b>&nbsp;Код&nbsp;</b></td>
      <td width="51%"><b>&nbsp;Цвет</b></td>
    </tr>
    <tr>
      <td width="22%">0h&nbsp;</td>
      <td width="17%">Черный&nbsp;&nbsp;&nbsp;</td>
      <td width="27%">&nbsp;8h&nbsp;</td>
      <td width="51%">&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;Серый</td>
    </tr>
    <tr>
      <td width="22%">
  1h</td>
      <td width="17%">&nbsp;&nbsp;Синий</td>
      <td width="27%"> 
  &nbsp;&nbsp;9h</td>
      <td width="51%"> &nbsp;Голубой</td>
    </tr>
    <tr>
      <td width="22%">
  2h &nbsp;</td>
      <td width="17%">Зеленый&nbsp;</td>
      <td width="27%"> 
  10h &nbsp;</td>
      <td width="51%">Салатовый</td>
    </tr>
    <tr>
      <td width="22%">
  3h&nbsp;</td>
      <td width="17%"> &nbsp;Бирюзовый &nbsp;</td>
      <td width="27%"> &nbsp;11h</td>
      <td width="51%"> Светло-бирюзовый</td>
    </tr>
    <tr>
      <td width="22%">
  4h&nbsp;</td>
      <td width="17%">Красный &nbsp; &nbsp;</td>
      <td width="27%">12h 
  &nbsp;&nbsp;</td>
      <td width="51%">Розовый</td>
    </tr>
    <tr>
      <td width="22%">
  5h&nbsp;</td>
      <td width="17%">Фиолетовый&nbsp;</td>
      <td width="27%">13h &nbsp;</td>
      <td width="51%">Светло-фиолетовый</td>
    </tr>
    <tr>
      <td width="22%">
  6h&nbsp;</td>
      <td width="17%">Коричневый</td>
      <td width="27%">14h &nbsp;</td>
      <td width="51%">Желтый</td>
    </tr>
    <tr>
      <td width="22%">
  7h &nbsp;&nbsp;</td>
      <td width="17%"> &nbsp;Белый &nbsp;</td>
      <td width="27%">15h &nbsp;&nbsp;</td>
      <td width="51%">Ярко-белый</td>
    </tr>
  </table>
<p>Выбирая цвета, следует 
  иметь в виду, что при стандартной настройке видеосистемы для цвета фона можно 
  использовать лишь значения из левого столбца таблицы; выбор любого яркого цвета 
  из правого столбца приведет в выводу мерцающего символа. Например, атрибут символа 
  Bill образует синий мерцающий символ на бирюзовом фоне (а не синий символ на 
  светло-бирюзовом фоне).<br>
  Содержательную часть цикла вывода образуют две команды lodsb и
stosw. Первая 
  команда загружает в регистр AL код очередного символа, вторая выводит его вместе 
  с атрибутом, хранящемся в АН, на экран. При этом после каждого выполнения команды 
  lodsb содержимое SI увеличивается процессором на 1, смещая адресацию к следующему 
  символу строки; в то же время каждое выполнение команды stosw увеличивает DI 
  на 2 (потому что команда stosw работает со словами), смещая адресацию на экране 
  на 2 байт, т.е. как раз к позиции следующего символа.<br>
  Примеры использования команд cmps и seas можно найти в Приложении.</p>

<p>
&nbsp;
</p>
<table COLS="3" WIDTH="16%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="Index2.htm">
<img SRC="Back.gif" BORDER="0">
</a>
</font>
</td>
<td WIDTH="10%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0" width="73" height="22">
</a>
</font>
</td>
<td ALIGN="RIGHT">
<font face="Arial, Helvetica, sans-serif">
<a href="Index4.htm">
<img SRC="For.gif" BORDER="0">
</a>
</font>
</td>
</tr>
</table>
</body>
</html>
