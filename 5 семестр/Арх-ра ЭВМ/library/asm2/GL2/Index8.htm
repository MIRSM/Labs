<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>
</title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body background="../FON.JPG" BGCOLOR="#E7E3E7" TEXT="#000000" LINK="#004080" VLINK="#004080">
<table COLS="3" WIDTH="16%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="Index7.htm">
<img SRC="Back.gif" BORDER="0">
</a>
</font>
</td>
<td WIDTH="10%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0">
</a>
</font>
</td>
</td>
</tr>
</table>
<p>
&nbsp;
</p>
<p align="center">
<font face="Arial, Helvetica, sans-serif" size="3">
<font size="4">
Макросредства ассемблера
</font>

</font>
</p>
<p align="left">
&nbsp;
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Современные ассемблеры содержат в себе
так называемые макросредства и по этой
причине называются иногда
макроассемблерами. Общая идея макросредств
заключается в том, что включением в
исходный текст программы предложений
специального языка макросредств (макроязыка)
мы в какой-то степени управляем процессом
трансляции программы. Макроязык позволяет
выполнять или не выполнять трансляцию
отдельных участков программы в зависимости
от некоторого нами же определяемого
условия (условная трансляция); осуществлять
размножение участка исходного текста
программы, в том числе, с модификацией
каждого повторения (блоки повторения);
включать в программу написанные отдельно
фрагменты с настройкой их текста в
соответствии с заданными параметрами (макрокоманды).
Объекты, создаваемые с помощью директив
макроязыка, обычно называют макросами.
Иногда, правда, термин макрос относят
только к одному конкретному виду
макросредств, именно, к макрокоманде.
Использование макросов упрощает
составление исходного текста программы и
иногда делает этот текст более наглядным,
хотя в отдельных случаях, как, например, в
случае директив условной трансляции,
наоборот, может привести к существенному
усложнению исходного текста.<br>
Как и во всяком языке программирования, в
языке макросредств имеется много разного
рода тонкостей, но в прикладном
программировании зачастую используются
лишь базовые возможности этого языка.
Поэтому мы ограничимся здесь рассмотрением
основных макросредств ассемблера.<br>
Блоки повторения<br>
Блоки повторения заставляют транслятор
повторить заданный блок исходного текста
указанное число раз. Повторяемый блок может
состоять из директив описания данных (и
тогда он включается в состав сегмента
данных) или из команд процессора (и тогда он
описывается в программном сегменте).
Например, следующий фрагмент сегмента
данных позволяет образовать массив,
состоящий из кодов ASCII прописных русских
букв:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">


sym='A' ;Начальное значение временной
переменной

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
symbols: ;Имя массива для ссылок на него

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
rept 32 ;Повторять столько раз

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
db sym ;Повторяемая директива

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
sym=sym+l ;Изменение переменной

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
endm ;Конец блока повторения

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Как видно из приведенного фрагмента, блок
повторения начинается с директивы
ассемблера rept (от repetition, повторение), а
заканчивается директивой endm (end macro, конец
макроса). Реально в сегменте данных
выделяется 32 байт, заполненных числами от 81h
до 9Fh, которые предполагается рассматривать,
как последовательность русских букв. Того
же результата можно было достигнуть с
помощью следующего предложения:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">


symbols db &quot;А&quot;, &quot;Б&quot;, &quot;В&quot;, &quot;Г&quot;, и
т.д. до буквы Я

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p><br>
или проще, хотя и менее наглядно:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">


symbols db 128,129,130,131, и т.д. до числа 159.

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p><br>
Макрос повторения несколько сокращает
время, требуемое для описания в тексте
программы требуемого массива, хотя,
возможно, снижает наглядность этого
описания.<br>
При подключении к компьютеру
измерительного или управляющего
оборудования иногда возникает
необходимость замедлить работу процессора
при обращении к портам этого оборудования.
Замедление осуществляется включением в
текст программы одной или, если требуется,
нескольких команд безусловного перехода на
следующее предложение:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">


in AL,300h ;Первое обращение к оборудованию

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
jmp a ;Задержка на время

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
a: jmp b ;выполнения

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
b: jmp с ;трех команд jmp

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
c: in AL,301h ;Следующее обращение к оборудованию

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Для того, чтобы не создавать много
ненужных, в сущности, меток, такого рода
предложения часто записывают следующим
образом:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">


in AL, 300h ;Первое обращение к оборудованию

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
jmp $+2 ;Задержка на время

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
jmp $+2 ;выполнения

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
jmp $+2 ;трех команд jmp

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
in AL,301h ;Следующее обращение к оборудованию

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Здесь используется обозначение счетчика
текущего адреса S. При трансляции любой
команды в счетчике текущего адреса
содержится адрес этой команды (смещение ее
первого байта). Команда короткого перехода
занимает 2 байт, поэтом}' команда jmp $+2
осуществляет переход на команду, идущую
следом.<br>
Часто в подобных случаях ограничиваются
одной командой jmp, которая создает
необходимую задержку в доли микросекунды. В
тех случаях, однако, когда устройство
сопряжения с оборудованием работает
заметно медленнее процессора, приходится
включать между командами обращения к
портам 5-6 команд jmp. Такой фрагмент можно
оформить в виде блока повторения:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">


rept 6 jmp $+2 endm

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Это, пожалуй, проще, чем писать 6 команд jmp.<br>
Макросы повторения имеют несколько
разновидностей, которые мы не будем здесь
рассматривать.<br>
Макрокоманды<br>
Программы, написанные на языке ассемблера,
часто содержат повторяющиеся участки
текста с одинаковой структурой. Такой
участок текста можно оформить в виде
макроопределения, характеризующегося
произвольным именем и необязательным
списком формальных аргументов. После того,
как такое определение сделано, появление в
программе строки, содержащей имя
макроопределения и список фактических
аргументов (все это вместе называют
макрокомандой), приводит к генерации всего
требуемого текста, называемого
макрорасширением. Варьируя фактические
аргументы, можно, сохраняя неизменной
структуру макрорасширения, изменить
отдельные его элементы.<br>
Макроопределение должно начинаться
строкой с именем макроопределения и
директивой macro, в поле аргументов которой
указывается список формальных аргументов.
Заканчивается макроопределение директивой
endm.<br>
Пусть в программе требуется неоднократно
сохранять в стеке содержимое трех
регистров, но в каждом конкретном случае
номера регистров и их порядок отличаются.
Оформим эти действия в виде
макроопределения:</p>

</font>
<blockquote>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


psh macroa,b,c<o:p>
</o:p>

</font>
</span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


push a

</font>
 </span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
push b

</font>
 </span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
push

</font>
 </span>
<font face="Verdana" size="3">


с

</font>
  </p>
<p>
<font face="Verdana" size="3">


<span lang="EN-US" style="mso-ansi-language:EN-US"><br>
endm<o:p>
</span>

</font>
<font face="Arial, Helvetica, sans-serif" size="3">


<span lang="EN-US" style="mso-ansi-language:EN-US">
</o:p>
</span></p>
  </blockquote>
<p>Появление в исходном тексте программы
строки</p>
  <blockquote>
<p>

</font>
<font face="Verdana" size="3">


psh АХ, ВХ, СХ

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>приведет к генерации следующего
фрагмента текста:</p>

</font>
<blockquote>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


push AX push BX push CX<o:p>

</font>
<font face="Arial, Helvetica, sans-serif" size="3">


</o:p>

</font>
</span></p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Если же в исходном тексте имеется строка</p>
<blockquote>
<p><span lang="EN-US" style="mso-ansi-language:EN-US"> </span>

</font>
  <span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


psh DX, ES,

</font>
 </span>
<font face="Verdana" size="3">


ВР<span lang="EN-US" style="mso-ansi-language:EN-US"><o:p>
</span>

</font>
<font face="Arial, Helvetica, sans-serif" size="3">


<span lang="EN-US" style="mso-ansi-language:EN-US">
</o:p>
</span></p>
</blockquote>
<p>то соответствующее макрорасширение будет
иметь вид:</p>

</font>
<blockquote>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


push DX

</font>
</span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
push ES

</font>
</span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
push BP<o:p>

</font>
<font face="Arial, Helvetica, sans-serif" size="3">


</o:p>

</font>
</span></p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>В качестве фактических аргументов могут
выступать любые обозначения ассемблера,
допустимые для данной команды. В частности,
макровызов</p>
<blockquote>
<p>

</font>
<font face="Verdana" size="3">


psh mem, [BX], ES: [17h]

</font>
</p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>приведет к следующему макрорасширению:</p>

</font>
<blockquote>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


push mem

</font>
</span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
push [BX]

</font>
</span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
push ES : [17h]<o:p>

</font>
<font face="Arial, Helvetica, sans-serif" size="3">


</o:p>

</font>
</span></p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Если какие-то строки макроопределения
должны быть помечены (например, с целью
организации циклов), то обозначения меток
следует объявить локальными с помощью
оператора local. В этом случае ассемблер,
генерируя макрорасширения, будет создавать
собственные обозначения меток, не
повторяющиеся при повторных вызовах одной
и той же макрокоманды:</p>

</font>
<blockquote>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


delay macro

</font>
</span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
local point

</font>
</span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
mov CX,200

</font>
</span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
point: loop point

</font>
</span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
endm<o:p>

</font>
<font face="Arial, Helvetica, sans-serif" size="3">


</o:p>

</font>
</span></p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Макрос delay создает задержку фиксированной
длительности. Если в текст программы
включить две макрокоманды delay</p>
<blockquote>
<p><br>

</font>
<font face="Verdana" size="3">


…

</font>
</p>
<p>
<font face="Verdana" size="3">


<br>
delay

</font>
</p>
<p>
<font face="Verdana" size="3">


<br>
…

</font>
</p>
<p>
<font face="Verdana" size="3">


<br>
delay

</font>
</p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>то их макрорасширения, подставленные в
текст программы, будут выглядеть следующим
образом:</p>

</font>
<blockquote>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


…

</font>
</span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
mov CX, 20000

</font>
</span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
??0000: loop ??0000

</font>
</span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
…<br>
mov CX, 20000

</font>
</span></p>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


<br>
??0000: loop ??0000<o:p>

</font>
<font face="Arial, Helvetica, sans-serif" size="3">


</o:p>

</font>
</span></p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>При повторных подстановках
макроопределения транслятор заменяет
обозначение метки point на различающиеся
обозначения ??0000, ??0001 и т.д., обеспечивая тем
самым правильное выполнение команд циклов
и переходов.<br>
Макрокоманды схожи с подпрограммами в том
отношении, что в обоих случаях мы описываем
некоторый программный фрагмент один раз, а
обращаемся к нему многократно, возможно, с
передачей различных параметров. Однако эти
вычислительные средства различаются как по
способу использования, так и по своим
возможностям.<br>
Подпрограммы позволяют сократить объем
выполнимого файла за счет описания
повторяющихся участков программы лишь
однажды. При каждом вызове подпрограммы
командой call происходит переход на один и
тот же фрагмент программы, содержащий
подпрограмму, а после выполнения
подпрограммы - возврат назад в точку вызова.
Текст подпрограммы полностью определяется
на этапе ее написания, и изменения в ходе
выполнения подпрограммы возможны только за
счет передачи ей тех или иных конкретных
значений.<br>
Механизм использования макроса иной.
Каждая макрокоманда, встретившаяся
транслятору в тексте программы, заменяется
им на полный текст макроопределения. Если
макрокоманда содержит параметры, то в
процессе этой замены происходит
подстановка параметров в текст
макроопределения. Образованное таким
образом макрорасширение составляет часть
текста программы, неотличимо от остальных
предложений программы и не нуждается в
каких-либо вызовах. В силу этих
обстоятельств макрокоманды оказываются
несколько эффективнее подпрограмм по
скорости выполнения, особенно, если учесть
время, требуемое для подготовки параметров
перед вызовом подпрограммы (например,
проталкивание их в стек). Вряд ли стоит,
однако, проводить такое сравнение.
Подпрограммы и макрокоманды имеют
различные области применения.<br>
Подпрограммы служат для сокращения объема
программы, повышения ее наглядности и
упрощения перестройки алгоритма
выполнения всего программного комплекса
путем изменения состава и порядка
вызываемых подпрограмм. При этом активное
использование подпрограмм может уменьшить
размер всей программы в десятки раз.<br>
Смысл использования макрокоманд совсем
иной. Макрокоманды позволяют упростить
процесс написания программы и, можно
сказать, являются средством автоматизации
программирования. При этом язык
макрокоманд предоставляет большие
возможности по изменению текста
макрорасширения в зависимости от
указываемых в макрокоманде параметров.
Проиллюстрируем эти возможности на простом
примере макрокоманды вывода на экран
символа. Такой макрокомандой можно
пользоваться в процессе отладки сложных
программ, чтобы получать информацию о
содержимом любых ячеек памяти. Пример
оформлен в виде законченной программы,
которая носит чисто демонстрационный
характер.</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">


;Пример 2-1. Использование макрокоманды<br>
sym macroc ;Имя и формальный аргумент<br>
push AX ;Сохраним используемые<br>
push DX ;в макроопределении регистры<br>
mov АН, 02h ;Функция DOS вывода символа<br>
mov DL,c ;Заберем символ<br>
int 21h ;Вызов DOS<br>
pop DX ;Восстановим<br>
pop AX ;регистры<br>
endm ;Конец макроопределения<br>
code segment<br>
assume cs:code<br>
main proc<br>
sym 'w' ;Символ указан непосредственно<br>
sym ES : 0 ;Вывод первого байта PSP<br>
sym CS:msg ;Вывод первой буквы из msg<br>
lea BX,msg-t-l ;Адрес второй буквы из msg<br>
sym [BX] ;Вывод второй буквы<br>
mov AX, 40h ;Настроим DS<br>
mov DS,AX ;на начало памяти<br>
sym DS:49h ;Вывод номера видеорежима<br>
mov AX,4C00h ;Завершение программы<br>
int 21h<br>
main endp<br>
msg db 'OK'<br>
code ends

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Тексты макроопределений обычно
размещаются в самом начале программы, что
дает возможность вызывать макрокоманды из
любых точек программы. Содержательная
часть макроса sym состоит в вызове функции 02h
DOS, которая выводит на экран символ из
регистра DL. Поскольку макрос использует
регистры АХ и DX, они в начале макроса
сохраняются в стеке, а перед его
завершением восстанавливаются. В качестве
параметра макрокоманды можно использовать
любое обозначение ассемблера, которое
может интерпретироваться, как адрес
символа.<br>
Сама программа умышленно построена
несколько нестандартным образом. В ней
имеется единственный сегмент с текстом
программы, в конце которого помещена строка
данных (слово 'ОК'). Такое расположение
данных допустимо, однако для обращения к
ним необходимо использовать замену
сегмента (как это сделано в третьей строке
программы), так как программный сегмент
адресуется через регистр CS. Сегмент стека в
программе отсутствует, что не очень хорошо,
но для небольших программ допустимо.
Фактически под стек будет использован
самый низ сегмента команд, начиная с адреса
FFFEh. Поскольку наша программа имеет размер,
существенно меньше 64К, такое расположение
стека не приведет ни к каким неприятностям (при
большом размере программы стек мог бы
начать затирать нижние строки программы).<br>
В программе проиллюстрировано
использование в качестве фактического
аргумента макрокоманды различных
конструкций языка: непосредственного
обозначения символа (что, наверное, лишено
смысла), прямого обращения к различным
участкам памяти по абсолютным адресам
через регистры ES и DS, адресации с
использованием символического обозначения
поля данных. На рис. 2.18 приведен вывод
программы.</p>
<p align="center"><!--[if gte vml 1]><v:shapetype id="_x0000_t75" coordsize="21600,21600"
 o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f"
 stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" alt="" style='width:237.75pt;
 height:37.5pt'>
 <v:imagedata src="Index825.jpg"
  o:href="p2.18.jpg"/>
</v:shape><![endif]-->
<img src="gl2-18.jpg" ></p>
<p align="center"><b>Рис. 2.18</b>. Вывод программы 2.1.</p>
<p>Как уже отмечалось, при загрузке
программы в память в регистры DS и ES
заносится сегментный адрес префикса
программы, поэтому адресация через ES
позволяет прочитать содержимое PSP. Префикс
содержит, главным образом, данные,
необходимые системе для обслуживания
текущей программы, но, кроме того, и
несколько команд. В частности, префикс
начинается с команды CD 20h, которая уже давно
не используется, но в префиксе присутствует
ради обеспечения совместимости со старыми
версиями DOS. Первый байт этой команды, если
его рассматривать, как код символа,
соответствует элементу двойной
горизонтальной рамки (длинный знак
равенства).<br>
Занеся в регистр DS число 40h, мы настроили его
на начало области данных BIOS, которая
начинается с абсолютного адреса 400h,
занимает 256 байт и содержит разнообразные
данные, используемые BIOS в процессе
обслуживания аппаратуры компьютера. Так,
например, по адресу 0 от начала этой области
хранится базовый адрес первого
последовательного порта; по адресу 8 - адрес
первого параллельного порта, а по адресу 491i
- код текущего видеорежима. При работе в DOS
видеоадаптер обычно настраивается на режим
3 (80x25 символов, 16 цветов). Будучи выведен на
экран, код 3 образует изображение
червонного туза.<br>
В тех случаях, когда макрокоманды
составляются для конкретной программы, они
включаются в текст программы так, как это
было сделано в примере 2.1. Однако часто
программист оформляет в виде макрокоманд
стандартные процедуры общего назначения,
например, программную задержку или вывод на
экран строки текста. В этом случае тексты
макроопределений целесообразно поместить
в макробиблиотеку.<br>
Макробиблиотека представляет собой файл с
текстами макроопределений.
Макроопределения записываются в этот файл
точно в таком же виде, как и в текст
программы. Ниже приведен текст файла
макробиблиотеки с произвольным именем
MYMACRO.MAC, содержащей две макрокоманды.</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">


;Макрокоманда endpr завершения программы<br>
endpr macro ;Макрокоманда без параметров<br>
mov AX,4C00h<br>
int 2 In<br>
endm ;Конец макрокоманды<br>
;Макрокоманда delay настраиваемой
программной задержки<br>
delay macro time ;Параметр - число шагов<br>
locallabell,Iabel2 ;Локальные метки<br>
push CX ;Сохраним внешний счетчик<br>
mov CX,time ;Получим фактический параметр<br>
Iabel2 : push CX ;Сохраним его в стеке<br>
mov CX, 0 ;Пусть будет 64К шагов<br>
labell: loop lanell ;Внутренний цикл<br>
pop CX ;Извлечем внешний счетчик<br>
loop Iabel2 ;Внешний цикл<br>
pop CX ;Восстановим CX программы<br>
endm ;Конец макрокоманды

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Для того чтобы транслятору были доступны
макрокоманды из файла MYMACRO.MAC, его следует на
этапе трансляции подсоединить к исходному
тексту программы директивой ассемблера
include:</p>

</font>
<blockquote>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">


include my macro, mac<o:p>

</font>
<font face="Arial, Helvetica, sans-serif" size="3">


</o:p>

</font>
</span></p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Все макрокоманды, включенные в этот файл,
можно использовать в любом месте программы.<br>
Директивы условной трансляции<br>
Директивы условной трансляции (условного
ассемблирования) позволяют иметь в
исходном тексте программы различные
варианты отдельных фрагментов программы, и
путем задания определенных условий
управлять процессом трансляции. Таким
образом можно, например, включать или
исключать из текста программы служебные,
отладочные фрагменты или настраивать
программу для выполнения на заданном
процессоре.<br>
Пусть, например, в процессе отладки сложной
программы мы используем подпрограмму regs
вывода на экран содержимого всех регистров
процессора. Включая в разные места
программы вызов этой подпрограммы, мы имеем
возможность контролировать ход ее
выполнения, в том числе и такие тонкие
моменты, как, например, расположение
программы в памяти или интенсивность
использование стека. Для управления
процессом трансляции предусмотрим
константу debug (отладка), ненулевое значение
которой будет требовать отладочного
варианта трансляции, а нулевое - рабочего.
Начало программы, а также участки с вызовом
отладочной подпрограммы будут выглядеть
следующим образом:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">


;debug=l ;Удалите символ ';'для отладочной
трансляции

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
;debug=0 ;Удалите ';' для рабочей трансляции

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
... ;Текст программы

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
if debug ;Транслировать только если debug=l

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
call regs;Вызов отладочной подпрограммы

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
endif ;Конец блока условной трансляции

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
… ;Продолжение программы

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
if debug ;Следующее включение отладочного
блока

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
call regs

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
endif

</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
... ;Продолжение программы

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p><br>
Разумеется, можно отлаживать программу в
отладочном варианте, а затем удалить все
вызовы вспомогательной подпрограммы regs
вручную и получить рабочий вариант, однако
на практике обычно (или даже всегда)
оказывается, что после эксплуатации
программы в течение некоторого времени в
ней обнаруживаются незамеченные ранее
ошибки, что приводит к необходимости снова
вставлять в нее отладочные строки. Часто
эту процедуру приходится повторять
многократно. Использование в программе
директив условной трансляции сокращают
процедуру преобразования программы из
отладочного варианта в рабочий или
наоборот до операции стирания одного
символа &quot;;&quot; в начале программы и
устраняют вероятность случайного внесения
в программу новых ошибок в процессе
удаления или вставки отладочных строк.<br>
Рассмотрим еще один пример применения
директив условной трансляции. Как уже
отмечалось, современные процессоры
предоставляют программисту значительное
количество дополнительных команд, которые
можно использовать в программах реального
режима, но только, разумеется, если
компьютер оснащен соответствующим
процессором. Нетрудно составить
универсальную программу', которую можно
выполнять как на современных процессорах (в
более эффективном режиме), так и на более
старых (с некоторой потерей эффективности),
если включить в нее директивы условной
трансляции этих дополнительных команд. К
таким командам, в частности, относятся
команды сохранения в стеке всех регистров
общего назначения pusha и восстановления всех
регистров рора. Приведем пример условной
трансляции этих команд, в котором
используется конструкция макроязыка if... else...
endif:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">


i386=l<br>
if i386<br>
.386<br>
endif<br>
code segment use16<br>
assume CS:code<br>
main proc<br>
…<br>
if i386<br>
push ;Сохранение всех регистров одной
командой<br>
else<br>
push AX<br>
push CX<br>
push DX<br>
push BX<br>
push BP<br>
push SI<br>
push DI<br>
endif<br>
. . . ;Использование регистров после<br>
;сохранения их значений<br>
if 1386<br>
рора ;Восстановление всех регистров одной
командой<br>
else<br>
pop DI<br>
pop SI<br>
pop BP<br>
pop BX<br>
pop DX<br>
pop CX<br>
pop AX<br>
endif

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


Если в начале программы имеется
объявление i386=1, то, во-первых, в программу
будет включена директива .386, позволяющая
использовать в программе дополнительные
команды, а во-вторых, в последующих условных
блоках будут транслироваться те их участки,
которые содержат команды процессора 80386.
Если же объявление i386=1 изъять, то в условных
блоках будут транслироваться
эквивалентные по существу, но менее
эффективные последовательности команд МП
86.

</font>
<p>
&nbsp;
</p>
<table COLS="3" WIDTH="16%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="Index7.htm">
<img SRC="Back.gif" BORDER="0">
</a>
</font>
</td>
<td WIDTH="10%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0">
</a>
</font>
</td>
</tr>
</table>
</body>
</html>
