<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>
</title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body background="../FON.JPG" BGCOLOR="#E7E3E7" TEXT="#000000" LINK="#004080" VLINK="#004080">
<table COLS="3" WIDTH="16%">
<tr>
    <td> <font face="Arial, Helvetica, sans-serif"> <a href="Index4.htm"> <img src="Back.gif" border="0"></a> 
      </font> </td>
<td WIDTH="10%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0">
</a>
</font>
</td>
<td ALIGN="RIGHT">
<font face="Arial, Helvetica, sans-serif">
<a href="Index6.htm">
<img SRC="For.gif" BORDER="0">
</a>
</font>
</td>
</tr>
</table>
<p>&nbsp;

</p>
<p align="center">
<font face="Arial, Helvetica, sans-serif" size="3">
<font size="4">
Способы адресации 
</font>
<br>
</font>
</p>
<p align="left">
<font face="Arial, Helvetica, sans-serif" size="3">

Способом, или режимом адресации называют
процедуру нахождения операнда для
выполняемой команды. Если команда
использует два операнда, то для каждого из
них должен быть задан способ адресации,
причем режимы адресации первого и второго
операнда могут как совпадать, так и
различаться. Операнды команды могут
находиться в разных местах:
непосредственно в составе кода команды, в
каком-либо регистре, в ячейке памяти; в
последнем случае существует несколько
возможностей указания его адреса. Строго
говоря, способы адресации являются
элементом архитектуры процессора, отражая
заложенные в нем возможности поиска
операндов. С другой стороны, различные
способы адресации определенным образом
обозначаются в языке ассемблера и в этом
смысле являются разделом языка.<br>
Следует отметить неоднозначность термина
&quot;операнд&quot; применительно к программам,
написанным на языке ассемблера. Для
машинной команды операндами являются те
данные (в сущности, двоичные числа), с
которыми она имеет дело. Эти данные могут,
как уже отмечалось, находиться в регистрах
или в памяти. Если же рассматривать команду
языка ассемблера, то для нее операндами (или,
лучше сказать, параметрами) являются те
обозначения, которые позволяют сначала
транслятору, а потом процессору определить
местонахождение операндов машинной
команды. Так, для команды ассемблера</font></p><blockquote>
<p>
<font face="Arial, Helvetica, sans-serif" size="3">

</font>
<font face="Verdana" size="3">

mov mem, AX

</font>
</p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>в качестве операндов используется
обозначение ячейки памяти mem, a также
обозначение регистра АХ. В то же время, для
соответствующей машинной команды
операндами являются содержимое ячейки
памяти и содержимое регистра. Было бы
правильнее говорить об операндах машинных
команд и о параметрах, или аргументах
команд языка ассемблера.<br>
По отношению к командам ассемблера было бы
правильнее использовать термин &quot;параметры&quot;,
оставив за термином &quot;операнд&quot;
обозначение тех физических объектов, с
которыми имеет дело процессор при
выполнении машинной команды, однако обычно
эти тонкости не принимают в расчет, и говоря
об операндах команд языка, понимают в
действительности операнды машинных команд.<br>
В архитектуре современных 32-разрядных
процессоров Intel предусмотрены довольно
изощренные способы адресации; в МП 86
способов адресации меньше. В настоящем
разделе будут описаны режимы адресации,
используемые в МП 86.<br>
В книгах, посвященных языку ассемблера,
можно встретить разные подходы к описанию
способов адресации: не только названия этих
режимов, но даже и их количество могут
различаться. Разумеется, способов
адресации существует в точности столько,
сколько их реализовано в процессоре; однако,
режимы адресации можно объединять в группы
по разным признакам, отчего и создается
некоторая путаница, в том числе и в
количестве имеющихся режимов. Мы будем
придерживаться распространенной, но не
единственно возможной терминологии.</p>
<p><br>
<b>Регистровая адресация.</b> Операнд (байт
или слово) находится в регистре. Этот способ
адресации применим ко всем программно-адресуемым
регистрам процессора.</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

inc СН ;Плюс 1 к содержимому СН

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
push DS ;DS сохраняется в стеке

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
xchg ВХ,ВР ;ВХ и ВР обмениваются содержимым

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov ES, АХ ;Содержимое АХ пересылается в ES

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p><b>Непосредственная адресация.</b> Операнд (байт
или слово) указывается в команде и после
трансляции поступает в код команды; он
может иметь любой смысл (число, адрес, код
ASCII), а также быть представлен в виде
символического обозначения.</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

mov АН, 40h ;Число 40h загружается в АН

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov AL,'*' ;Код ASCII символа &quot;*' загружается в AL

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
int 21h ;Команда прерывания с аргументом 21h

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
limit = 528 ;Число 528 получает обозначение limit

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov CX,limit ;Число, обозначенное limit, загружается
в СХ

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>Команда mov, использованная в последнем
предложении, имеет два операнда; первый
операнд определяется с помощью регистровой
адресации, второй - с помощью
непосредственной.<br>
Важным применением непосредственной
адресации является пересылка
относительных адресов (смещений). Чтобы
указать, что речь идет об относительном
адресе данной ячейки, а не об ее содержимом,
используется описатель onset (смещение):</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

; Сегмент данных

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mes db &quot;Урок 1' ;Строка символов

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
;Сегмент команд

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov DX,offset mes ;Адрес строки засылается в DX

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>В приведенном примере относительный
адрес строки mes, т.е. расстояние в байтах
первого байта этой строки от начала
сегмента, в котором она находится,
заносится в регистр DX.<br>
Прямая адресация памяти. Адресуется память;
адрес ячейки памяти (слова или байта)
указывается в команде (обычно в
символической форме) и поступает в код
команды:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

;Сегмент данных

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
meml dw 0 ;Слово памяти содержит 0

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mem2 db 230 ;Байт памяти содержит 230

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
;Сегмент команд<br>
inc meml ;Содержимое слова meml увеличивается на 1

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov DX, meml ; Содержимое слова с именем menu
загружается в DX

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov AL,mem2 ; Содержимое байта с именем mem2
загружается в АL

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>Сравнивая этот пример с предыдущим, мы
видим, что указание в команде имени ячейки
памяти обозначает, что операндом является
содержимое этой ячейки; указание имени
ячейки с описателем offset - что операндом
является адрес ячейки.<br>
Прямая адресация памяти на первой взгляд
кажется простой и наглядной. Если мы хотим
обратиться, например, к ячейке meml, мы просто
указываем ее имя в программе. В
действительности, однако, дело обстоит
сложнее. Вспомним, что адрес любой ячейки
состоит из двух компонентов: сегментного
адреса и смещения. Обозначения meml и mem2 в
предыдущем примере, очевидно, являются
смещениями. Сегментные же адреса хранятся в
сегментных регистрах. Однако сегментных
регистров четыре: DS, ES, CS и SS. Каким образом
процессор узнает, из какого регистра взять
сегментный адрес, и как сообщить ему об этом
в программе?<br>
Процессор различает группу кодов, носящих
название префиксов. Имеется несколько
групп префиксов: повторения, размера адреса,
размера операнда, замены сегмента. Здесь
нас будут интересовать префиксы замены
сегмента.<br>
Команды процессора, обращающиеся к памяти,
могут в качестве первого байта своего кода
содержать префикс замены сегмента, с
помощью которого процессор определяет, из
какого сегментного регистра взять
сегментный адрес. Для сегментного регистра
ES код префикса составляет 26h, для SS - 361i, для CS
- 2Eh. Если префикс отсутствует, сегментный
адрес берется из регистра DS (хотя для него
тоже предусмотрен свой префикс).<br>
Если в начале программы с помощью директивы
assume указано соответствие сегменту данных
сегментного регистра DS</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

assume DS:data

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>то команды обращения к памяти
транслируются без какого-либо префикса, а
процессор при выполнении этих команд берет
сегментный адрес из регистра DS.<br>
Если в директиве assume указано соответствие
сегмента данных регистру ES</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

assume ES:data

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>(в этом случае сегмент данных должен
располагаться перед сегментом команд), то
команды обращения к полям этого сегмента
транслируются с добавлением префикса
замены для сегмента ES. При этом предложения
программы выглядят обычным образом; в них
по-прежнему просто указываются имена полей
данных, к которым производится обращение.<br>
Однако в ряде случаев префикс замены
сегмента должен указываться в программе в
явной форме. Такая ситуация возникает,
например, если данные расположены в
сегменте команд, что типично для
резидентных обработчиков прерываний. Для
обращения к таким данным можно, конечно,
использовать регистр DS, если
предварительно настроить его на сегмент
команд, но проще выполнить адресацию через
регистр CS, который и так уже настроен
должным образом. Если в сегменте команд
содержится поле данных с именем mem, то
команда чтения из этого поля будет
выглядеть следующим образом:</p>

</font>
<blockquote>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">

mov AX,CS:mem 

</font>
<font face="Arial, Helvetica, sans-serif" size="3">



</font>
</span></p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>В этом случае транслятор включит в код
команды префикс замены для сегмента CS.
Другие примеры команд с заменой сегмента
будут приведены ниже.<br>
До сих пор мы обсуждали адресацию ячеек,
содержащихся в сегментах данных программы.
Однако часто бывает нужно обратиться к
памяти вне пределов программы: к векторам
прерываний, системным таблицам,
видеобуферу и т.д. Разумеется, такое
обращение возможно только если мы знаем
абсолютный адрес интересующей нас ячейки. В
этом случае необходимо сначала настроить
один из сегментных регистров на начато
интересующей нас области, после чего можно
адресоваться к ячейкам по их смещениям.<br>
Пусть требуется вывести в левый верхний
угол экрана несколько символов, например,
два восклицательных знака. Эту операцию
можно реализовать с помощью следующих
команд:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

mov AX,0B800h ;Сегментный адрес видеобуфера

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov ES,AX ;Отправим его в ES

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov byte ptr ES:0, ' ! ' ;Отправим символ на 1-е
знакоместо экрана

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov byte ptr ES:2, ' ! ' ;Отправим символ на 2-е
знакоместо экрана

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>Настроив регистр ES на сегментный адрес
видеобуфера BS00h, мы пересылаем код знака
&quot;!&quot; сначала по относительному адресу 0 (в
самое начало видеобуфера, в байт со
смещением 0), а затем на следующее
знакоместо, имеющее смещение 2 (в нечетных
байтах видеобуфера хранятся атрибуты
символов, т.е. цвет символов и фона под ними).
В обеих командах необходимо с помощью
обозначения ES: указать сегментный регистр,
который используется для адресации памяти.
Встретившись с этим обозначением,
транслятор включит в код команды префикс
замены сегмента, в данном случае код 26h.<br>
В приведенном примере мы снова столкнулись
с использованием атрибутивного оператора
byte ptr, который позволяет в явной форме
задать размер операнда. Однако если раньше
этот оператор использовался, чтобы извлечь
байт из данного, объявленного, как слово, то
здесь его назначение иное. Транслятор,
обрабатывая команду</p>
</font><blockquote><p>
<font face="Arial, Helvetica, sans-serif" size="3">

</font>
<font face="Verdana" size="3">

mov byte ptr ES:0, ' ! '

</font>
</p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>не имеет возможности определить размер
операнда-приемника. Разумеется, видеобуфер,
как и любая память, состоит из байтов,
однако надо ли рассматривать эту память,
как последовательность байтов или слов?
Команда без явного задания размера
операнда</p>
</font><blockquote><p>
<font face="Arial, Helvetica, sans-serif" size="3"><span lang="EN-US" style="mso-ansi-language:EN-US"> </span>

</font>
  <span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">

mov ES:0, ' !

</font>
 </span>
<font face="Verdana" size="3">

'

</font>
</p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>вызовет ошибку трансляции, так как
ассемблер не сможет определить, надо ли
транслировать это предложение, как команду
пересылки в видеобуфер байта 21h, или как
команду пересылки слова 0021h.<br>
Между прочим, на первый взгляд может
показаться, что в обсуждаемой команде
достаточно ясно указан размер правого
операнда, так как символ (в данном случае
&quot;!&quot;) всегда занимает один байт. Однако
транслятор, встретив обозначение &quot;!&quot;,
сразу же преобразует его в код ASCII этого
символа, т.е. в число 21h, и уже не знает,
откуда это число произошло и какой размер
оно имеет.<br>
Стоит еще отметить, что указание в команде
описателя word ptr</p>

</font>
<blockquote>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">

mov word ptr ES:0,'!'<o:p>

</font>
<font face="Arial, Helvetica, sans-serif" size="3">

</o:p>

</font>
</span></p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>не вызовет ошибки трансляции, но приведет
к неприятным результатам. В этом случае в
видеобуфер будет записано слово 002lh,
которое заполнит байт 0 видеобуфера кодом
21h, а байт 1 кодом 00h. Однако атрибут 00h
обозначает черный цвет на черном фоне, и
символ на экране виден не будет (хотя и
будет записан в видеобуфер).<br>
При желании можно избавиться от
необходимости вводить описатель размера
операнда. Для этого надо пересылать не
непосредственное данное, а содержимое
регистра:</p>

</font>
<blockquote>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">

mov AL,'!' mov ES:0,AL<o:p>

</font>
<font face="Arial, Helvetica, sans-serif" size="3">

</o:p>

</font>
</span></p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>Здесь операндом-источником служит
регистр AL, размер которого (1 байт) известен,
и размер операнда-приемника определять не
надо. Разумеется, команда</p>
</font><blockquote><p>
<font face="Arial, Helvetica, sans-serif" size="3">

</font>
<font face="Verdana" size="3">

mov ES:0,AX

</font>
</p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>заполнит в видеобуфере не байт, а слово.<br>
Для адресации к видеобуферу в
вышеприведенном примере использовался
сегментный регистр дополнительных данных ES.
Это вполне естественно, так как обычно
регистр DS служит для обращения к полям
данных программы, а регистр ES как раз и
предназначен для адресации всего
остального. Однако при необходимости можно
было воспользоваться для записи в
видеобуфер регистром DS:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

mov AX,0B800h ;Сегментный адрес

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov DS,AX ; видеобуфера в DS

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov byte ptr DS:0, ' ! ' ;Символ в видеобуфер

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>Любопытно, что хотя обозначение DS: здесь
необходимо, транслятор не включит в код
команды префикс замены сегмента, так как
команда без префикса выполняет адресацию
по умолчанию через DS.<br>
Если, однако, по умолчанию выполняется
адресация через DS, то нельзя ли опустить в
последней команде обозначение сегментного
регистра? Нельзя, так как обозначение DS:
число указывает, что число является не
непосредственным операндом, а адресом
операнда. Команда (неправильная)</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

mov 6,10

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>должна была бы переслать число 10 в число 6,
что, разумеется, лишено смысла и выполнено
быть не может. Команда же</p>
</font><blockquote><p>
<font face="Arial, Helvetica, sans-serif" size="3">

</font>
<font face="Verdana" size="3">

mov DS:6,10

</font>
</p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>пересылает число 10 по относительному
адресу 6, что имеет смысл. Таким образом,
обозначение сегментного регистра с
двоеточием перед операндом говорит о том,
что операнд является адресом. В дальнейшем
мы еще столкнемся с этим важным правилом.<br>
Мы рассмотрели три важнейших способа
адресации: регистровую, непосредственную и
прямое обращение к памяти. Все остальные
режимы адресации относятся к группе
косвенной адресации памяти, когда в
определении адреса ячейки памяти участвует
один или несколько регистров процессора.
Рассмотрим последовательно эти режимы.</p>
<p><br>
<b>Регистровая косвенная</b> <b>(базовая и
индексная).</b> Адресуется память (байт или
слово). Относительный адрес ячейки памяти
находится в регистре, обозначение которого
заключается в прямые скобки. В МП 86
косвенная адресация допустима только через
регистры ВХ, ВР, SI и DI. При использовании
регистров ВХ или ВР адресацию называют
базовой, при использовании регистров SI или
DI - индексной.<br>
Преобразуем приведенный выше пример, чтобы
продемонстрировать использование
косвенной адресации через регистр.</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

mov AX,0B800h ;Сегментный адрес

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov ES,AX ; видеобуфера в ES

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov BX,2000 ;Смещение к середине экрана

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov byte ptr ES:[ВХ], ' ! ' ;Символ на экран

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>Настроив ES, мы засылаем в регистр ВХ
требуемое смещение (для разнообразия к
середине видеобуфера, который имеет объем
точно 4000 байт), и в последней команде
засылаем код в видеобуфер с помощью
косвенной базовой адресации через пару
регистров ES:BX с указанием замены сегмента (ES:).<br>
Если косвенная адресация осуществляется
через один из регистров ВХ, SI или DI, то
подразумевается сегмент, адресуемый через
DS, поэтому при адресации через этот регистр
обозначение DS: можно опустить:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

mov AX,0B800h ;Сегментный адрес

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov DS,AX ;видеобуфера в DS

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov BX,2000 ;Смещение к середине экрана

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov byte ptr [ВХ], ' ! ' ;Символ на экран

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>Кстати, этот фрагмент немного эффективнее
предыдущего в смысле расходования памяти.
Из-за отсутствия в коде последней команды
префикса замены сегмента он занимает на 1
байт меньше места.<br>
Регистры ВХ, SI и DI в данном применении
совершенно равнозначны, и с одинаковым
успехом можно воспользоваться любым из них:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

mov D1,2000 ;Смещение к середине экрана

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov byte ptr [DI] , ' ! ' ;Символ на экран

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>Не так обстоит дело с регистром ВР. Этот
регистр специально предназначен для работы
со стеком, и при адресации через этот
регистр в режимах косвенной адресации
подразумевается сегмент стека; другими
словами, в качестве сегментного регистра по
умолчанию используется регистр SS.<br>
Обычно косвенная адресация к стеку
используется в тех случаях, когда
необходимо обратиться к данным,
содержащимся в стеке, без изъятия их оттуда
(например, если к эти данные приходится
считывать неоднократно). Пример такого рода
операций будет приведен при обсуждении
следующего режима адресации.<br>
Сравнивая приведенные выше фрагменты
программ, можно заметить, что использование
базовой адресации, на первый взгляд,
снижает эффективность программы, так как
требует дополнительной операции - загрузки
в базовый регистр требуемого адреса.
Действительно, базовая адресация в нашем
примере не оправдана - в случае прямого
обращения к памяти вместо двух команд</p>
</font><blockquote><p>
<font face="Arial, Helvetica, sans-serif" size="3">

</font>
<font face="Verdana" size="3">

mov BX,2000 ;Смещение к середине экрана

</font>
</p>
<p>
<font face="Verdana" size="3">

<br>
mov byte ptr ES: [BX] , ' ! ' ;Символ на экран

</font>
</p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>можно использовать одну</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

mov byte ptr ES:2000,'!' ;Выведем символ в середину
экрана

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>Однако команда с базовой адресацией
занимает меньше места в памяти (так как в
нее не входит адрес ячейки) и выполняется
быстрее команды с прямой адресацией (из-за
того, что команда короче, процессору
требуется меньше времени на ее считывание
из памяти). Поэтому базовая адресация
эффективна в тех случаях, когда по
заданному адресу приходится обращаться
многократно, особенно, в цикле. Выигрыш
оказывается тем больше, чем большее число
раз происходит обращение по указанному
адресу. С другой стороны, возможности этого
режима адресации невелики, и на практике
чаще используют более сложные способы,
которые будут рассмотрены ниже.</p>
<p><br>
<b>Регистровая косвенная адресация со
смещением</b> (базовая и индексная).
Адресуется память (байт или слово).
Относительный адрес операнда определяется,
как сумма содержимого регистра BX, BP, SI или DI
и указанной в команде константы, иногда
называемой смещением. Смещение может быть
числом или адресом. Так же, как и в случае
базовой адресации, при использовании
регистров BX, SI и DI подразумевается сегмент,
адресуемый через DS, а при использовании ВР
подразумевается сегмент стека и,
соответственно, регистр SS.<br>
Рассмотрим применение косвенной адресации
со смещением на примере прямого вывода в
видеобуфер.</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

mov AX,0B800h ;Сегментный адрес

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov ES,AX ;видеобуфера в ES

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov DI, 80*2*24 ;Смещение к нижней строке экрана

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov byte ptr ES: [DI] ,'О' ;Символ на экран

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov byte ptr ES:2[DI],'К' ;Запишем символ в следующую
позицию

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov byte ptr ES:4[DI],' ! ' ;Запишем символ в следующую
позицию

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>В этом примере в качестве базового выбран
регистр DI; в него заносится базовый
относительный адрес памяти, в данном случае
смещение в видеобуфере к началу последней
строки экрана. Модификация этого адреса с
целью получить смещение по строке экрана
осуществляется с помощью констант 2 и 4,
которые при вычислении процессором
исполнительного адреса прибавляются к
содержимому базового регистра DI.<br>
Иногда можно встретиться с альтернативными
обозначениями того же способа адресации,
которые допускает ассемблер. Вместо,
например, 4[ВХ] можно с таким же успехом
написать [ВХ+4], 4+[ВХ] или [ВХ]+4. Такая
неоднозначность языка ничего, кроме
путаницы, не приносит, однако ее надо иметь
в виду, так как с этими обозначениями можно
столкнуться, например, рассматривая текст
деассемблированной программы.<br>
Рассмотрим теперь пример использования
базовой адресации со смещением при
обращении к стеку:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

;Основная программа

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
push DS ;В стек загружаются значения

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
push ES ;трех регистров,

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
push SI ;передаваемых подпрограмме

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
call mysub ;Вызов подпрограммы mysub,

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
;использующей эти параметры

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
;Подпрограмма mysub

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov BP,SP ;Поместим в ВР текущий адрес вершины
стека

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov АХ,2[ВР], ;Читаем в АХ последний параметр (SI)

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov ВХ,4[ВР] ;Читаем в ВХ предыдущий параметр (ES)

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov CX,6[BP] ;Читаем в СХ первый параметр (DS)

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>Здесь продемонстрирован классический
прием чтения содержимого стека без
извлечения из него этого содержимого. После
того, как основная, программа сохранила в
стеке три параметра, которые потребуются
подпрограмме, командой call вызывается
подпрограмма mysub. Эта команда сохраняет в
стеке адрес возврата (адрес следующего за
call предложения основной программы) и
осуществляет переход на подпрограмму.
Состояние стека при входе в подпрограмму
приведено на рис. 2.15.</p>
<p align="center"><!--[if gte vml 1]><v:shapetype id="_x0000_t75" coordsize="21600,21600"
 o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f"
 stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" alt="" style='width:286.5pt;
 height:231pt'>
 <v:imagedata src="Index522.jpg"
  o:href="p2.15.jpg"/>
</v:shape><![endif]-->
<img src="gl2-15.jpg" ></p>
<p align="center"><b>Рис.2.15.</b> Состояние стека после загрузки в
него трех параметров и перехода на
подпрограмму</p>
<p>Если бы подпрограмма просто сняла со
стека находящиеся там параметры, она первым
делом изъяла бы из стека адрес возврата, и
лишила бы себя возможности вернуться в
основную программу (подробнее вопросы
вызова подпрограммы и возврата из нее будут
обсуждаться в последующих разделах).
Поэтому в данном случае вместо команд pop
удобнее воспользоваться командами mov.
Подпрограмма копирует в ВР содержимое трех
параметров и перехода на мое SP и использует
затем этот адрес в качестве базового,
модифицируя его с помощью базовой
адресации со смещением.<br>
Кстати, мы опять сталкиваемся здесь с той
весьма обычной ситуацией, когда
программист не имеет возможности
обращаться по наглядным символическим
адресам, которых в стеке, естественно, нет, а
вынужден определять &quot;вручную&quot;
смещения к интересующим его элементам
стека. При этом необходимо учесть и
алгоритм выполнения команды call, которая,
сохраняя в стеке адрес возврата в основную
программу, смещает указатель стека еще на
одно слово.<br>
В нашем фрагментарном примере мы не
рассматриваем вопрос возврата в основную
программу. Вдумчивый читатель мог также
усомниться в правильности или, лучше
сказать, в разумности текста подпрограммы.
Ведь перенося параметры из стека в регистры
общего назначения, подпрограмма затирает
их исходное содержимое. Если же они не
содержали ничего нужного, то ими можно было
воспользоваться для передачи параметров в
подпрограмму, а не связываться с мало
наглядными операциями со стеком.
Действительно, ради краткости мы опустили
операции, практически необходимые в любой
подпрограмме - сохранение в стеке (опять в
стеке!) тех регистров, которые будут
использоваться в подпрограмме. Кстати, это
относится и к регистру ВР. В реальной
подпрограмме эти действия следовало
выполнить, что привело бы к изменению
смещений при регистре ВХ, которые приняли
бы значения (с учетом сохранения 4 регистров)
10, 12 и 14.<br>
Во всех приведенных выше примерах регистр
использовался для хранения базового адреса,
а смещение, если оно требовалось,
указывалось в виде константы. Возможна и
обратная ситуация, когда в качестве
смещения выступает адрес массива, а в
регистре находится индекс адресуемого
элемента в этом массиве. Рассмотрим
относительно реальный пример такого рода.<br>
Пусть нам надо заполнить массив из 10000 слов
натуральным рядом чисел. Зарезервируем в
сегменте данных место под этот массив, а в
сегменте команд организуем цикл занесения
в последовательные слова массива ряда
нарастающих чисел. Нам придется
воспользоваться несколькими новым
командами (inc, add и loop), которые в дальнейшем
будут рассмотрены более подробно.</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

;Сегмент данных

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
array dw 10000

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
;Сегмент команд

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov SI, 0 ;Начальное значение индекса элемента
в массиве

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov АХ, 0 ;Первое число-заполнитель

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov СХ,10000;Число шагов в цикле (всегда в СХ)

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
fill: mov array[SI],AX ;Занесение числа в элемент
массива

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
inc AX ;Инкремент числа-заполнителя

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
add SI,2 ;Смещение в массиве к следующему слову

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
loop fill ;Возврат на метку fill (СХ раз)

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>Цикл начинается с команды, помеченной
меткой fill (правила образования имен меток
такие же, как и для имен полей данных). В этой
команде содержимое АХ, поначалу равное 0,
переносится в ячейку памяти, адрес которой
вычисляется, как сумма адреса массива array и
содержимого индексного регистра SI, в
котором в первом шаге никла тоже 0. В
результате в первое слово массива
заносится 0. Далее содержимое регистра АХ
увеличивается на 1, содержимое регистра SI -
на 2 (из-за того, что массив состоит из слов),
и командой loop осуществляется переход на
метку fill, после чего тело цикла повторяется
при новых значениях регистров АХ и SI. Число
шагов в цикле, отсчитываемое командой loop,
определяется исходным содержимым регистра
СХ.<br>
Базово-индексная адресация. Адресуется
память (байт или слово). Относительный адрес
операнда определяется, как сумма
содержимого следующих пар регистров:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

[ВХ] [SI] (подразумевается DS:[BX][SI])

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
[ВХ][DI] (подразумевается DS:[BX][DI])

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
[ВР] [SI] (подразумевается SS:[BP][SI])

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
[ВР] [DI] (подразумевается SS:[BP][DI])

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>Это чрезвычайно распространенный способ
адресации, особенно, при работе с массивами.
В нем используются два регистра, при этом
одним из них должен быть базовый (ВХ или ВР),
а другим - индексный (SI или DI). Как правило, в
одном из регистров находится адрес массива,
а в другом - индекс в нем, при этом
совершенно безразлично, в каком что.
Трансформируем предыдущий пример, введя в
него более эффективную базово-индексную
адресацию.</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

;Сегмент данных

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
array dw 10000

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
;Сегмент команд

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov BX,offset array ;Базовый адрес массива в

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
;базовом регистре

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov SI, 0 ;Начальное значение индекса

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
;элемента в массиве

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov АХ, 0 ;Первое число-заполнитель

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov CX,10000 ;Число шагов в цикле

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
fill: mov [BX][SI],AX ;Отправим число в массив

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
inc AX ;Инкремент числа-заполнителя

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
add SI, 2 ;Смещение в массиве к следующему слову

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
loop fill ;На метку fill (CX раз)

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>Повышение эффективности достигается за
счет того, что команда занесения числа в
элемент массива оказывается короче (так как
в нее не входит адрес массива) и выполняется
быстрее, так как этот адрес не надо каждый
раз считывать из памяти.<br>
Базово-индексная адресация со смещением.
Адресуется память (байт или слово).
Относительный адрес операнда определяется
как сумма содержимого двух регистров и
смещения.<br>
Это способ адресации является развитием
предыдущего. В нем используются те же пары
регистров, но полученный с их помощью
результирующий адрес можно еще сместить на
значение указанной в команде константы. Как
и в случае базово-индексной адресации,
константа может представлять собой индекс (и
тогда в одном из регистров должен
содержаться базовый адрес памяти), но может
быть и базовым адресом. В последнем случае
регистры могут использоваться для хранения
составляющих индекса. Приведем формальный
пример рассматриваемого режима адресации.<br>
Пусть в сегменте данных определен массив из
24 байтов, в котором записаны коды латинских
и русских символов верхнего ряда
клавиатуры:</p>

</font>
<blockquote>
<p>
<font face="Verdana" size="3">

sims db &quot;QWERTYUIOP{}'

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
db &quot;ЙЦУКЕНПШЦЗХЪ'

</font>
  </p>
<p>
<font face="Verdana" size="3">

Последовательность команд

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov BX,12 ;Число байтов в строке

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov SI, 6

</font>
  </p>
<p>
<font face="Verdana" size="3">

<br>
mov DL,syms[BX][SI]

</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>загрузит в регистр DL элемент с индексом 6
из второго ряда, т.е. код ASCII буквы Г. Тот же
результат можно получить, загрузив в один
из регистров не индекс, а адрес массива:</p>

</font>
<blockquote>
<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">

mov BX, off set sym

</font>
</span></p>

<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">

<br>
mov SI,6

</font>
</span></p>

<p><span lang="EN-US" style="mso-ansi-language:EN-US">
<font face="Verdana" size="3">

<br>
mov DL, 12 [BX] [SI]<o:p>

</font>
<font face="Arial, Helvetica, sans-serif" size="3">

</o:p>

</font>
</span></p>

</blockquote>
<p>&nbsp;

</p>
<table COLS="3" WIDTH="16%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="Index4.htm">
<img SRC="Back.gif" BORDER="0">
</a>
</font>
</td>
<td WIDTH="10%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0">
</a>
</font>
</td>
<td ALIGN="RIGHT">
<font face="Arial, Helvetica, sans-serif">
<a href="Index6.htm">
<img SRC="For.gif" BORDER="0">
</a>
</font>
</td>
</tr>
</table>
</body>
</html>
