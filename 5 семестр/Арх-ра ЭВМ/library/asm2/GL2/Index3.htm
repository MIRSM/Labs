<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>
</title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body background="../FON.JPG" BGCOLOR="#E7E3E7" TEXT="#000000" LINK="#004080" VLINK="#004080">
<table COLS="3" WIDTH="16%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="Index2.htm">
<img SRC="Back.gif" BORDER="0">
</a>
</font>
</td>
<td WIDTH="10%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0" width="73" height="22">
</a>
</font>
</td>
<td ALIGN="RIGHT">
<font face="Arial, Helvetica, sans-serif">
<a href="Index4.htm">
<img SRC="For.gif" BORDER="0">
</a>
</font>
</td>
</tr>
</table>
<p>
&nbsp;
</p>
<p align="center">
<font face="Arial, Helvetica, sans-serif" size="3">
<font size="4">
Описание данных 
</font>
<br>
</font>
</p>
<p align="left">
<font face="Arial, Helvetica, sans-serif" size="3">


Практически любая программа содержит в
себе перечень данных, с которыми она
работает. Это могут быть символьные строки,
предназначенные для вывода на экран; числа,
определяющие ход выполнения программы или
участвующие в вычислениях; адреса
подпрограмм, обработчиков прерываний или
просто тех или иных полей программы;
специальные коды, например, коды цвета
выводимых на экран символов и т.д. Кроме
данных, определяемых в тексте программы, в
программу часто входят зарезервированные
поля, предназначенные для заполнения по
ходу выполнения программы, например,
результатами вычислений или путем чтения
из файла. Все эти данные и
зарезервированные поля должны быть
определены в составе сегмента данных
программы (в принципе они могут быть
определены, и часто определяются, не в
сегменте данных, а в сегменте команд, но
здесь мы не будем касаться этого вопроса).<br>
Для определения данных используются,
главным образом, три директивы ассемблера:
db (define byte, определить байт) для записи байтов,
dw (define word, определить слово) для записи слов
и dd (define double, определить двойное слово) для
записи двойных слов:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


db 255
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
dw 6.5535
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
dd 100000000
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Кроме перечисленных, имеются и другие
директивы, например df (define fanvord, определить
поле из 6 байт), dq (define quadword, определить
четверное слово) или dt (define tcraword, определить
10-байтовую переменную), но они используются
значительно реже.<br>
Для того чтобы к данным можно было
обращаться, они должны иметь имена. Имена
данных могут включать латинские буквы,
цифры (не в качестве первого знака имени) и
некоторые специальные знаки, например,
знаки подчеркивания (_), доллара ($) и
коммерческого at (@). Длину имени некоторые
ассемблеры ограничивают (например,
ассемблер MASM - 31 символом), другие - нет, но в
любом случае слишком длинные имена
затрудняют чтение программы. С другой
стороны, имена данных следует выбирать
таким образом, чтобы они отражали
назначение конкретного данного, например
counter для счетчика или filename для имени файла:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


counter dw 10000
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
filename db &quot;a:\myfile.001'
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Значения числовых данных можно
записывать в различных системах счисления;
чаще других используются десятичная и 16-ричная
запись:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


size dw 256 ;В ячейку size записывается<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;десятичное
число 256
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
setb7 db 80h ;В ячейку setb7 записывается<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;16-ричное
число 80h
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Необходимо отметить неточность
приведенных выше комментариев. В памяти
компьютера могут храниться только двоичные
коды. Если мы говорим, что в какой-то ячейке
записано десятичное число 128, мы имеем в
виду не физическое содержимое ячейки, а
лишь форму представления этого числа в
исходном тексте программы. В слове с именем
size фактически будет записан двоичный код
0000000100000000, являющийся двоичным эквивалентом
десятичного числа 256. Во втором случае в
байте с именем setbit? будет записан двоичный
эквивалент шестнадцатиричного числа 80h,
который составляет 10000000 (т.е. байт с
установленным битом 7, откуда и получила имя
эта ячейка).<br>
Для резервирования места под массивы
используется оператор dup (duplicate, дублировать),
который позволяет &quot;размножить&quot; байт,
слово или двойное слово заданное число раз:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


rawdata dw 300 dup (1) &nbsp; ;Резервируются 300 слов,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;заполненных
числом 1
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
string db 80 dup ('^') &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Резервируются
80 байтов,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
;заполненных знаком '^'
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Присвоение данным символических имен
позволяет обращаться к ним в программных
предложениях, не заботясь о фактических
адресах этих данных. Например, команда</p>
<blockquote>
<p>
</font>
<font face="Verdana" size="3">


<b>mov </b> AX,size
</font>
</p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>занесет в регистр АХ содержимое ячейки size
(число 256), независимо от того, в каком месте
сегмента данных эта ячейка определена, и в
какое место физической памяти она попала.
Однако программист, использующий язык
ассемблера, должен иметь отчетливое
представление о том, каким образом
назначаются адреса ячейкам программы, и
уметь работать не только с символическими
обозначениями, но и со значениями адресов.
Для обсуждения этого вопроса рассмотрим
пример сегмента данных, в котором
определяются данные различных типов. В
левой колонке укажем смещения данных (в
шестнадцатеричной форме), вычисляемые
относительно начала сегмента.</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


data segment
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
0000h counter dw 10000
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
0002h pages db &quot;Страница 1&quot;
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
000Ch numbers db 0, 1, 2, 3, 4
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
0011h page_addr dw pages
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
data ends
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Сегмент данных начинается с данного по
имени counter, которое описано, как слово (2 байт)
и содержит число 10000. Очевидно, что его
смещение равно 0. Поскольку это данное
занимает 2 байт, следующее за ним данное pages
получило смещение 2. Данное pages описывает
строку текста длиной 10 символов и занимает
в памяти столько же байтов, поэтому
следующее данное numbers получило
относительный адрес 2 + 10 = 12 = Ch. В поле numbers
записаны 5 байтовых чисел, поэтому
последнее данное сегмента с именем page_addr
размещается по адресу Ch + 5 = 11h.<br>
Ассемблер, начиная трансляцию сегмента (в
данном случае сегмента данных) начинает
отсчет его относительных адресов. Этот
отсчет ведется в специальной переменной
транслятора (не программы!), которая
называется счетчиком текущего адреса и
имеет символическое обозначение знака
доллара (S). По мере обработки полей данных,
их символические имена сохраняются в
создаваемой ассемблером таблице имен
вместе с соответствующими им значениями
счетчика текущего адреса. Другими словами,
введенные нами символические имена
получают значения, равные их смещениям.
Таким образом, с точки зрения транслятора
counter равно 0, pages - 2, numbers - Ch и т.д. Поэтому
предложение</p>
<blockquote>
<p>
</font>
<font face="Verdana" size="3">


page_addr dw pages
</font>
</p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>трактуется ассемблером, как</p>
<blockquote>
<p>
</font>
<font face="Verdana" size="3">


page_addr dw 2
</font>
</p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>и приводит к записи в слово с
относительным адресом 11h числа 2 (смещения
строки pages).<br>
Приведенные рассуждения приходится
использовать при обращении к &quot;внутренностям&quot;
объявленных данных. Пусть, например, мы
хотим выводить на экран строки &quot;Страница
2&quot;, &quot;Страница 3&quot;, &quot;Страница 4&quot; и т.д.
Можно, конечно, все эти строки описать в
сегменте данных по отдельности, но это
приведет к напрасному расходу памяти.
Экономнее поступить по-другому: выводить на
экран одну и ту же строку pages, но
модифицировать в ней номер страницы.
Модификацию номера можно выполнить с
помощью, например, такой команды:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


<b>mov </b> pages + 9, ' 2'
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Здесь мы &quot;вручную&quot; определили
смещение интересующего нас символа в
строке, зная, что все данные размещаются
ассемблером друг за другом в порядке их
объявления в программе. При этом, какое бы
значение не получило имя pages, выражение pages +
9 всегда будет соответствовать байту с
номером страницы.<br>
Таким же приемом можно воспользоваться при
обращении к данному numbers, которое в сущности
представляет собой небольшой массив из 5
чисел. Адрес первого числа в этом массиве
равен просто numbers, адрес второго числа - numbers
+ 1, адрес третьего - numbers + 2 и т.д. Следующая
команда прочитает последний элемент этого
массива в регистр DL:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


<b>mov </b> DL,numbers+4
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Какой смысл имело объединение ряда чисел
в массив numbers? Да никакого, если к этим
числам мы все равно обращаемся по
отдельности. Удобнее было объявить этот
массив таким образом:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


nmb0 db 0
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
nmbl db 1
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
nmb2 db 2
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
nmb3 db 3
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
nmb4 db 4
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>В этом случае для обращения к последнему
элементу не надо вычислять его адрес, а
можно воспользоваться именем nmb4. Если, с
другой стороны, мы хотим работать с числами,
как с массивом, используя индексы отдельных
элементов (о чем речь будет идти позже), то
присвоение массиву общего имени
представляется естественным. Получение
последнего элемента массива по его индексу
выполняется с помощью такой
последовательности команд:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


mov SI,4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Индекс
элемента в массиве
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
mov DL,numbers[SI] ;Обращение по адресу
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;numbers
+ содержимое SI
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Иногда желательно обращаться к элементам
массива (обычно небольшого размера) то с
помощью индексов, то по их именам. Для этого
надо к описанию массива, как
последовательности отдельных данных,
добавить дополнительное символическое
описание адреса начала массива с помощью
директивы ассемблера label (метка):</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


numbers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
nmb0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
nmbl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
nmb2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
nmb3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
nmb4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
4
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Метка numbers должна быть объявлена в данном
случае с описателем byte, так как данные,
следующие за этой меткой, описаны как байты
и мы планируем работать с ними именно как с
байтами. Если нам нужно иметь массив слов,
то отдельные элементы массива следует
объявить с помощью директивы dw, а метке numbers
придать описатель word:</p>
</font>
<blockquote>
<p><font face="Verdana" size="3">numbers&nbsp;&nbsp;&nbsp;&nbsp; label&nbsp;&nbsp;&nbsp;
word</font></p>
<p><font face="Verdana" size="3"><br>
nmb0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0</font></p>
<p><font face="Verdana" size="3"><br>
nmbl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dw &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1</font></p>
<p><font face="Verdana" size="3"><br>
nmb2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dw &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2</font></p>
<p><font face="Verdana" size="3"><br>
nmb3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>&nbsp;&nbsp;&nbsp; <font face="Verdana" size="3">dw &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3
</font>
  </p>
<p><font face="Verdana" size="3"><br>
nmb4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dw &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
4
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>В чем состоит различие двух последних
описаний данных? Различие есть, и весьма
существенное. Хотя в обоих случаях в память
записывается натуральный ряд чисел от 0 до 4,
однако в первом варианте под каждое число в
памяти отводится один байт, а во втором -
слово. Если мы в дальнейшем будем изменять
значения элементов нашего массива, то в
первом варианте каждому числу' можно будет
задавать значения от 0 до 255, а во втором - от 0
до 65535.<br>
Выбирая для данных способ их описания,
необходимо иметь в виду, что ассемблер
выполняет проверку размеров используемых
данных и не пропускает команды, в которых
делается попытка обратиться к байтам, как к
словам, или к словам - как к байтам.
Рассмотрим последний вариант описания
массива numbers. Хотя под каждый элемент
выделено целое слово, однако реальные числа
невелики и вполне поместятся в байт. Может
возникнуть искушение поработать с ними, как
с байтами, перенеся предварительно в
байтовые регистры:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


mov AL,nmb0 ;Переносим nmb0 в AL
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
mov DL,nmbl ;Переносим nmb1 в AL
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
mov CL,nmb2 ;Переносим nmb2 в AL
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Так делать нельзя. Транслятор сообщит о
грубой ошибке - несоответствии типов, и не
будет создавать объектный файл. Однако
довольно часто возникает реальная
потребность в операциях такого рода. Для
таких случаев предусмотрен специальный
атрибутивный оператор byte ptr (byte pointer,
байтовый указатель), с помощью которого
можно на время выполнения одной Команды
изменить размер операнда:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


mov AL,byte ptr nmb0
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
mov DL,byte ptr nmbl
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
mov CL,byte ptr nmb2
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Эти команды транслятор рассматривает, как
правильные.<br>
Часто возникает необходимость выполнить
обратную операцию - к паре байтов
обратиться, как к слову. Для этого надо
использовать оператор word ptr:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


okey db 'OK'
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
…
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
mov AX,word ptr okey
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Здесь оба байта из байтовой переменной okey
переносятся в регистр АХ. При этом первый по
порядку байт, т.е. байт с меньшим адресом,
содержащий букву &quot;О&quot; (можно считать,
что он является младшим в слове<br>
&quot;OK&quot;), отправится в младшую половину АХ -
регистр AL, а второй по порядку байт, с буквой
&quot;К&quot;, займет регистр АН.<br>
До сих пор речь шла о данных, которые, в
сущности, являлись переменными, в том
смысле, что под них выделялась память и их
можно было модифицировать. Язык ассемблера
позволяет также использовать константы,
которые являются символическими
обозначениями чисел и могут использоваться
всюду в тексте программы, как наглядные
эквиваленты этих чисел:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


maxsize = 0FFFFh
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
mov CX,maxsize mov CX,0FFFFh
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Последние две команды полностью
эквивалентны.<br>
При определении констант допустимо
выполнение арифметических операций. Пусть
нам надо задать позицию символа (или строки
символов) на экране. Учитывая, что каждый
символ записывается в видеопамяти в двух
байтах (в первом - код ASCII символа, а во
втором - его атрибут), строка экрана имеет
длину 80 символов, а высота экрана
составляет 25 строк, то для вывода
некоторого символа в середину экрана его
смещение в видеопамяти от начала
видеостраницы можно определить следующим
образом:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


position=80*2*12+40*2
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>Такая запись достаточно наглядна, и ее
легко модифицировать, если мы решим вывести
символ в какую-то другую область экрана.<br>
Константами удобно пользоваться для
определения длины текстовых строк:</p>
</font>
<blockquote>
<p>
<font face="Verdana" size="3">


mes db 'Ждите'
</font>
  </p>
<p>
<font face="Verdana" size="3">


<br>
mes_len = $-mes
</font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">


<p>В этом примере константа mes_len получает
значение длины строки mes (в данном случае 5
байт), которая вычисляется как разность
значения счетчика текущего адреса после
определения строки и ее начального адреса
mes. Такой способ удобен тем, что при
изменении содержимого строки достаточно
перетранслировать программу, и та же
константа mes_len автоматически получит новое
значение.
</font>
</p>
<p>
&nbsp;
</p>
<table COLS="3" WIDTH="16%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="Index2.htm">
<img SRC="Back.gif" BORDER="0">
</a>
</font>
</td>
<td WIDTH="10%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0" width="73" height="22">
</a>
</font>
</td>
<td ALIGN="RIGHT">
<font face="Arial, Helvetica, sans-serif">
<a href="Index4.htm">
<img SRC="For.gif" BORDER="0">
</a>
</font>
</td>
</tr>
</table>
</body>
</html>
