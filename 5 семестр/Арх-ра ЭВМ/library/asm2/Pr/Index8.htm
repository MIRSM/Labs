<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>
</title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body background="../FON.JPG" BGCOLOR="#E7E3E7" TEXT="#000000" LINK="#004080" VLINK="#004080">
<table COLS="3" WIDTH="16%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="Index7.htm">
<img SRC="Back.gif" BORDER="0" width="73" height="22">
</a>
</font>
</td>
<td WIDTH="10%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0" width="73" height="22">
</a>
</font>
</td>
<td ALIGN="RIGHT">
<font face="Arial, Helvetica, sans-serif">
<a href="Index9.htm">
<img SRC="For.gif" BORDER="0" width="73" height="22">
</a>
</font>
</td>
</tr>
</table>
<p>
&nbsp;
</p>
<p align="center">
<font face="Arial, Helvetica, sans-serif" size="3">
<font size="4">
486+ CMPXCHG Сравнение и обмен
</font>
<br>
</font>
</p>
<p align="left">
<font face="Arial, Helvetica, sans-serif" size="3">

  Команда cmpxchg выполняет в одной операции сравнение и обмен операндов. Команда 
  требует два параметра и неявным образом использует третий операнд - регистр 
  ЕАХ. Первый операнд (приемник) должен находиться в 16- или 32-битовой ячейке 
  памяти, второй операнд (источник) - в регистре общего назначения такого же размера. 
  Команда выполняет сравнение операнда-приемника с содержимым неявного операнда 
  - регистра ЕАХ. Если сравниваемые значения совпадают, операнд-приемник замещается 
  операндом-источником (т.е. содержимое регистра записывается в память). Если 
  сравниваемые значения не совпадают, содержимое памяти (приемник) поступает в 
  регистр ЕАХ (рис. П1). Команда воздействует на флаги
OF, SF, ZF, AF, PF и CF.</p>
<p align="center"><img src="pr-1.jpg"></p>
<p align="center"><b>Рис.П1.</b> Действие команды 
  cmpxchg</p>
<p align="center"><b>Пример 1</b></p>
<blockquote>
<p><br>
  </font><font face="Verdana, Arial, Helvetica, sans-serif" size="3">
  ; В полях данных<br>
  mem dw 135<br>
  ; В программном сегменте<br>
  mov AX,135<br>
  mov BX,60<br>
  cmpxchg mem,BX ;mem=AX. Регистр ® память ;<br>
mem=60, BX=60, АХ=135</font></p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>
  </p>
<p align="center"><b>Пример 2</b>
  </p>
  <blockquote>
<p><br>
    </font><font face="Verdana, Arial, Helvetica, sans-serif" size="3">
  ; В полях данных<br>
  mem dw 135<br>
  ;В программном сегменте<br>
  mov AX,148<br>
  mov BX,60<br>
  cmpxchg mem,BX ;mem&lt;&gt;AX. Память ® АХ<br>
;mem=135, BX=60, AX=148</font>
<font face="Arial, Helvetica, sans-serif" size="3">

  <br>
    
  </p>
<p>&nbsp;
  </p>
</blockquote>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="4">Pentium+ 
  CMPXCHG8B Сравнение и обмен 8 байтов</font></p>
<p>
<font face="Arial, Helvetica, sans-serif" size="3">

  <br>
  Команда cmpxchgSb выполняет в одной операции сравнение и обмен 8-байтовых операндов. 
  Команда требует один параметр и неявным образом использует еще два операнда 
  - пары регистров EDX:EAX и ЕСХ:ЕВХ. В качестве явного операнда команды (приемника) 
  может выступать только 64-битная (8-байтовая) ячейка памяти. Команда выполняет 
  сравнение операнда-приемника в памяти с содержимым
EDX:EAX. Если сравниваемые 
  значения совпадают, то операнд-приемник в памяти замещается 64-битным значением 
  ЕСХ:ЕВХ. Если сравниваемые значения не совпадают, содержимое памяти поступает 
  в пару регистров EDXrEAX, замещая один из сравниваемых операндов (рис. П2). 
  Команда воздействует на флаг ZF.</p>
<p align="center"><img src="pr-2.jpg" ></p>
<p align="center"><font size="3"><b>Рис. 
  П2. </b> Действие команды 
  cmpxchg8b<br>
</font></p>
<p align="center"><font size="3">
  <br>
  <b>Пример 1</b></font></p>
<blockquote>
<p><font size="3"><br>
</font></font><font face="Verdana, Arial, Helvetica, sans-serif" size="3">
  ; В полях данных<br>
  mem dq 1122334455667788h<br>
  ;В программном сегменте<br>
  mov ЕСХ,9<br>
  mov ЕВХ,5<br>
  mov EDX,11223344h <br>
  mov EAX,55667788h<br>
  cmpxchgSb mem ;mem=EDX:EAX. ECX:EBX ® mem ;<br>
mem=0000000900000005h</font></p>
</blockquote>
<font size="3">
<font face="Arial, Helvetica, sans-serif" size="3">

<p>
  </p>
<p align="center"><b>Пример 2</b>
  </p>
  <blockquote>
<p><br>
    </font><font face="Verdana, Arial, Helvetica, sans-serif">
  ; В полях данных<br>
  mem dq 1122334455667788h<br>
;B программном сегменте<br>
  mov ECX,9<br>
  mov EBX,5<br>
  mov EDX,11223344h<br>
  mov EAX,55667789h<br>
  cmpxchgSb mem ;memOEDX: EAX. Mem -&quot; EDX : EAX ;mem=1122334455667788h ;EDX=11223344h,
EAX=55667788h<br>
    </font>
  </p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>При работе с многобайтовыми 
  данными не следует забывать о том, что в памяти байты любых данных всегда выстраиваются 
  в порядке их номеров, т.е. от младшим к все более старшим, в то время как при 
  изображении чисел мы применяем обратный порядок - сначала пишем старшие разряды 
  числа, затем младшие. В то же время символьные строки мы изображаем так же, 
  как они располагаются в памяти - для нас естественно считать, что по мере движения 
  по строке вправо номер символа возрастает.</p>
<p align="center"><b>Пример 3</b></p>
  <blockquote>
<p><br>
    </font><font face="Verdana, Arial, Helvetica, sans-serif">
  ; В полях данных<br>
  meml db '12345678' ;Строка-операнд <br>
  mem2 db '12345678' ;Сравниваемая строка <br>
  ;В программном сегменте<br>
  mov ECX,68676665h ;'efgh' <br>
  mov EBX,64636261h ;'abcd' <br>
  mov EDX,dword ptr mem2+4 ;Забираем старшую<br>
  ;часть строки <br>
  mov EAX,dword ptr mem2 ;Забираем младшую<br>
  ;часть строки<br>
  cmpxchg8b gword ptr meml ;Операнды совпадают<br>
;ZF=1, mem1=''abcdefgh'' <br>
;ECX:EBX без изменений <br>
;EDX:EAX без изменений</font></p>
</blockquote>
<font face="Arial, Helvetica, sans-serif" size="3">

<p>&nbsp;
  </p>
<p align="center"><b>Пример 4</b>
  </p>
  <blockquote>
<p><br>
    </font><font face="Verdana, Arial, Helvetica, sans-serif">
  ;В полях данных<br>
  meml db '12345678' ;Строка-операнд <br>
  mem2 db 'abcdefgh' ;Сравниваемая строка <br>
  ; В программном сегменте<br>
  mov ECX,68676665h ;'efgh'<br>
  mov EBX,64636261h ;'abed'<br>
  mov EDX,dword ptr mem2+4 ;3абираем старшую <br>
  ;часть строки<br>
  mov EAX,dword ptr mem2 ;Забираем младшую <br>
  ;часть строки<br>
  cmpxchg8b qword ptm mem1 ;Операнды не совпадают <br>
;ZF=0, EDX=38373635='5678' <br>
;EAX=34333231='1234' <br>
  ;mem1s без изменения <br>
  ;При неравенстве ЕСХ:ЕВХ не принимают участие в операции</font>
<font face="Arial, Helvetica, sans-serif" size="3">

  <br>
  </p>
  </blockquote>
  &nbsp;
<p align="center"><font face="Arial, Helvetica, sans-serif" size="4">
Pentium+ 
CPUID Идентификация процессора</font></p>
<p><font size="3"><br>
Команда cpuid позволяет получить код идентификации процессора, установленного 
на данном компьютере. Команда в качестве неявного операнда использует регистр 
ЕАХ. Для процессоров Pentium регистр ЕАХ перед вызовом команды cpuid может принимать 
два значения: 0 и 1. Если ЕАХ=0, то команда возвращает в регистре ЕАХ код 1, а 
в регистрах ЕВХ, EDX и ЕСХ (именно в таком порядке) - три части символьной строки, 
идентифицирующей изготовителя процессора. Для процессоров Intel возвращаемая строка 
в целом имеет вид &quot;Genumclatcl&quot;.<br>
Если перед вызовом команды cpuid значение ЕАХ равно 1, то команда возвращает в 
регистре ЕАХ коды разработки конкретной версии процессора, а в регистре EDX код
IBFli, содержащий информацию о возможностях процессора.<br>
Коды разработки в регистре ЕАХ хранятся в следующем формате:</p>
<blockquote>
  <p><font size="3"><br>
  <font face="Verdana, Arial, Helvetica, sans-serif" size="3">
биты 0 ... 3 - номер поколения (например, 3);</p>
  <p><font face="Verdana, Arial, Helvetica, sans-serif" size="3">
биты 4 ... 7 - модель (например, 4);</font></p>
  <p><font face="Verdana, Arial, Helvetica, sans-serif" size="3">биты 8 ... 11 - семейство (5 для
  Pentium).</font></p>
</blockquote>
<p><font size="3"><br>
</font></font>
Содержимое регистра EDX включает конфиденциальную информацию изготовителя, а также 
говорит о наличии на кристалле микропроцессора арифметического сопроцессора (бит 
0) и поддержке команды cmpxchgSb (бит 8).</p>
  <font size="3">
<p align="center"><b>Пример</b></p>
  <font face="Verdana, Arial, Helvetica, sans-serif" size="3">
<blockquote>
<p><br>
  <font face="Verdana, Arial, Helvetica, sans-serif" size="3">
  ;В полях данных mem dd 0,0,0 ;В программном сегменте<br>
  mov ЕАХ,О<br>
  cpuid ;EAX=0001h<br>
  mov mem, ЕВХ<br>
  mov mem+4, EDX<br>
  mov mem+8, ECX ;mem='Genuinelntel'<br>
  cpuid EAX=543h (например) ,EDX = lBFh</font></p>
</blockquote>
<font size="3"> 
<p>&nbsp;</p>
</font>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="4">CWD 
  Преобразование слова в двойное слово</font></p>
<font size="3">
<p><br>
  </font></font>
  Команда cwd заполняет регистр DX знаковым битом содержимого регистра АХ, преобразуя 
  тем самым 16-разрядное число со знаком в 32-разрядное, размещаемое в регистрах
DX:AX. Команду удобно использовать для преобразования двухбайтового делимого 
  в четырехбайтовое (двойное слово) при делении на 16-разрядный операнд. Команда 
  не имеет параметров и не воздействует на флаги процессора.</p>
<p align="center"><b>Пример 1</b></p>
  <font face="Verdana, Arial, Helvetica, sans-serif" size="3">
<font size="3">
<blockquote>
<p><br>
  </font><font face="Verdana, Arial, Helvetica, sans-serif" size="3">
  mov AX,32767 ;AX=7FFFh <br>
  cwd ;AX=7FFFh, DX=OOOOh. <br>
;DX:AX=32767</font></p>
</blockquote>
  </font>
<p align="center"><b>Пример 2</b></p>
<font size="3">
  <font face="Verdana, Arial, Helvetica, sans-serif" size="3">
<blockquote>
<p><br>
 <font face="Verdana, Arial, Helvetica, sans-serif" size="3">
  mov AX,-32768 ;AX=8000h <br>
  cwd ;AX=8000h, DX=FFFFh. <br>
;DX:AX=-32768</font></p>
</blockquote>
<font size="3">
<p>&nbsp;</p>
</font>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="4">386+ 
  CWDE Преобразование слова в двойное слово с расширением</font></p>
<font size="3">
<p>
  <font size="3"><br>
  </font></font></font>
</font>
  Команда cwde заполняет старшую половину регистра ЕАХ знаковым битом содержимого 
  регистра АХ, преобразуя тем самым 16-разрядное число со знаком в 32-разрядное, 
  размещаемое в расширенном регистре ЕАХ. Команда не имеет операндов и не воздействует 
  на флаги процессора.</p>
<font size="3">
<p align="center"><b>Пример</b></p>

  <font face="Verdana, Arial, Helvetica, sans-serif" size="3">
<font size="3">
  <font size="3">

<blockquote>
<p><br>
  </font>
</font>
<font face="Verdana, Arial, Helvetica, sans-serif" size="3">
  ; В полях данных<br>
  mem dw - 3<br>
  ;В программном сегменте<br>
  mov AX,mem ;AX=FFFD<br>
  cwde ;EAX=FFFFFFFDh</font></p>

</blockquote>
  <font size="3"><font size="3">
<p>
&nbsp;
</p>
<table COLS="3" WIDTH="16%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="Index7.htm">
<img SRC="Back.gif" BORDER="0" width="73" height="22">
</a>
</font>
</td>
<td WIDTH="10%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0" width="73" height="22">
</a>
</font>
</td>
<td ALIGN="RIGHT">
<font face="Arial, Helvetica, sans-serif">
<a href="Index9.htm">
<img SRC="For.gif" BORDER="0" width="73" height="22">
</a>
</font>
</td>
</tr>
</table>
  </font>
</body>
</html>
