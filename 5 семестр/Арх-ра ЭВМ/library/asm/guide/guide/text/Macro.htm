 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">	<!версия HTML-стандарта>
 <HTML>	<!начало html-документа>
 <HEAD>	<!заголовок html-документа>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
 <TITLE>Макросредства Ассемблера</TITLE>	<!заголовок страницы>
 <BASEFONT SIZE=3> <!базовый размер символов (для всего документа>
 </HEAD>
 <BODY BGCOLOR=#cfFFFF>	<!тело html-документа>
 <HR SIZE=5 WIDTH=60%>

<A NAME="Макроассемблер">  
<H2>Макросредства языка ассемблера</H2>
<UL>
<LI><A HREF="#ПонятиеОМакросредствах"><EM></EM>Понятие о макросредствах языка ассемблера</A>
<LI><A HREF="#ПсевдооператорыEQUи="><EM>Псевдооператоры equ и =</EM></A>
<LI><A HREF="#Макрокоманды"><EM>Макрокоманды</EM></A>
<LI><A HREF="#Макродирективы"><EM>Макродирективы</EM></A>
<LI><A HREF="#ДирективыУсловнойКомпиляции"><EM>Директивы условной компиляции</EM></A>
</UL>
<A NAME="ПонятиеОМакросредствах">
<P>Любопытный читатель к этому занятию, вероятно, попытался
самостоятельно написать хотя бы несколько программ на
ассемблере.
<BR>Скорее всего, эти программы были предназначены для
решения небольших, чисто исследовательских задач, но даже на
примере этих маленьких по объему программ вам, наверное, стали
очевидны некоторые из перечисленных здесь проблем:
<UL>
<LI>плохое понимание исходного текста программы, особенно по
  прошествии некоторого времени после ее написания;
<LI>ограниченность набора команд;
<LI>повторяемость некоторых идентичных или незначительно
отличающихся участков программы;
<LI>необходимость включения в каждую программу участков кода,
  которые уже были использованы в других программах;
<LI>и многое другое
</UL>
<P>Если бы мы писали программу на машинном языке, то данные
проблемы были бы принципиально не решаемыми. Но язык
ассемблера, являясь символическим аналогом машинного языка,
предоставляет для их решения ряд средств.
<BR>Основной целью,
которая при этом преследуется, является повышение удобства
написания программ.
<BR>В общем случае эта цель достигается по
нескольким направлениям за счет следующего:
<UL>
<LI>расширения набора директив;
<LI>введения некоторых дополнительных команд, не имеющих
  аналогов в системе команд микропроцессора. За примером далеко
  ходить не нужно — команды <A HREF="Data.htm#setfield"><B>setfield</B></A>
  и <A HREF="Data.htm#getfield"><B>getfield</B></A>, которые скрывают от программиста рутинные действия
  и генерируют наиболее эффективный код;
<LI>введения сложных типов данных.
</UL>
<P>Но это все глобальные направления, по которым развивается
сам транслятор от версии к версии.
<BR>Что же делать программисту
для решения его локальной задачи, для облегчения работы в
определенной проблемной области?
<BR>Для этого разработчики
компиляторов ассемблера включают в язык и постоянно
совершенствуют <EM>аппарат макросредств</EM>. Этот аппарат является
очень мощным и важным.
<P>В общем случае есть смысл говорить о
том, что транслятор ассемблера состоит из двух частей —
непосредственно транслятора, формирующего объектный модуль, и
макроассемблера (рис. 1).
   
<P ALIGN=CENTER> <IMG SRC="../PIC/RIS13_1.GIF" BORDER=0"> 
<P ALIGN=CENTER><EM><B>Рис. 1.</B> Макроассемблер в общей схеме трансляции
                       программы на TASM</EM>
      
<P>Если вы знакомы с языком С или
С++, то конечно помните широко применяемый в них <EM>механизм
препроцессорной обработки</EM>. Он является некоторым аналогом
механизма заложенного в работу макроассемблера. Для тех, кто
ничего раньше не слышал об этих механизмах, поясню их суть.
<BR>Основная идея — использование подстановок, которые замещают
определенным образом организованную символьную
последовательность другой символьной последовательностью.
Создаваемая таким образом последовательность может быть как
последовательностью, описывающей данные, так и
последовательностью программных кодов. Главное здесь то, что
на входе макроассемблера может быть текст программы весьма
далекий по виду от программы на языке ассемблера, а на выходе
обязательно будет текст на чистом ассемблере, содержащем
символические аналоги команд системы машинных команд
микропроцессора.
<P>Таким образом, обработка программы на
ассемблере с использованием макросредств неявно
осуществляется транслятором в две фазы(рис. 1).
<BR>На первой
фазе работает часть компилятора, называемая <EM>макроассемблером</EM>,
функции которого на идейном уровне мы описали чуть выше.
<BR>На второй фазе трансляции работает непосредственно <EM>ассемблер</EM>,
задачей которого является формирование объектного кода,
содержащего текст исходной программы в машинном виде.

<P>Далее мы обсудим основной набор макросредств, доступных
при использовании компилятора TASM. Отметим, что большинство
этих средств доступно и в компиляторе с языка ассемблера фирмы
Microsoft.
<BR>Обсуждение начнем с простейших средств и закончим
более сложными.
   
<A NAME="ПсевдооператорыEQUи=">
<H3>Псевдооператоры equ и =</H3>
<P>К простейшим макросредствам языка ассемблера можно отнести
псевдооператоры <B>equ</B> и "<B>=</B>" (равно).
<BR>Их мы уже неоднократно
использовали при написании программ.
<BR>Эти псевдооператоры
предназначены для присвоения некоторому выражению
символического имени или идентификатора. Впоследствии, когда в
ходе трансляции этот идентификатор встретится в теле
программы, макроассемблер подставит вместо него
соответствующее выражение.
<BR>В качестве выражения могут быть
использованы константы, имена меток, символические имена и
строки в апострофах. После присвоения этим конструкциям
символического имени его можно использовать везде, где
требуется размещение данной конструкции.
<P>Синтаксис псевдооператора <B>equ</B>:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
имя_идентификатора	equ	строка или числовое_выражение
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Синтаксис псевдооператора “<B>=</B>”:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
имя_идентификатора	=	числовое_выражение
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Несмотря на внешнее и функциональное сходство
псевдооператоры <B>equ</B> и “<B>=</B>” отличаются следующим:
<UL>
<LI>из синтаксического описания видно, что с помощью <B>equ</B>
  идентификатору можно ставить в соответствие как числовые
  выражения, так и текстовые строки, а псевдооператор “<B>=</B>” может
  использоваться только с числовыми выражениями;
<LI>идентификаторы, определенные с помощью “<B>=</B>”, можно
  переопределять в исходном тексте программы, а определенные с
  использованием <B>equ</B> — нельзя.
</UL>  
<P>Ассемблер всегда пытается вычислить значение строки,
воспринимая ее как выражение. Для того чтобы строка
воспринималась именно как текстовая, необходимо заключить ее в
угловые скобки: <B>&lt;<EM>строка</EM>&gt;</B>.
<BR>Кстати сказать, угловые скобки
являются <EM>оператором</EM> ассемблера, с помощью которого транслятору
сообщается, что заключенная в них строка должна трактоваться
как текст, даже если в нее входят служебные слова ассемблера
или операторы. Хотя в режиме Ideal это не обязательно, так как
строка для <B>equ</B> в нем всегда трактуется как текстовая.
<P>Псевдооператор <B>equ</B> удобно использовать для настройки
программы на конкретные условия выполнения, замены сложных в
обозначении объектов, многократно используемых в программе,
более простыми именами и т. п.
<BR>К примеру:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
masm
model	small
stack	256
mas_size	equ	10	;размерность массива
akk	equ	ax		;переименовать регистр
mas_elem	equ	mas[bx][si]	;адресовать элемент массива
.data
;описание массива из 10 байт:
mas	db	mas_size dup (0)
.code
	mov	akk,@data	;фактически mov ax,@data
	mov	ds,akk		;фактически mov ds,ax
...
	mov	al,mas_elem	;фактически — mov al,mas[bx][si]
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Псевдооператор “<B>=</B>” удобно использовать для определения
простых абсолютных (то есть не зависящих от места загрузки
программы в память) математических выражений.
<BR>Главное условие
то, чтобы транслятор мог вычислить эти выражения во время
трансляции.
<BR>К примеру:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
.data
adr1	db	5 dup (0)
adr2	dw	0
len = 43
len = len+1	;можно и так, через предыдущее определение
len = adr2-adr1
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Как видно из примера, в правой части псевдооператора “<B>=</B>”
можно использовать метки и ссылки на адреса — главное, чтобы в
итоге получилось абсолютное выражение.
<P>Компилятор TASM, начиная с версии 3.00, содержит
директивы, значительно расширяющие его возможности по работе с
текстовыми макросами. Эти директивы аналогичны некоторым
функциям обработки строк в языках высокого уровня. Под
<EM>строками</EM> здесь понимается текст, описанный с помощью
псевдооператора <B>equ</B>.
<P>Набор этих директив следующий:
<UL>
<LI>директива слияния строк <B>catstr</B>:
<BR><EM><B>идентификатор catstr строка_1,строка_2,...</B></EM> — значением этого
 макроса будет новая строка, состоящая из сцепленной слева
 направо последовательности строк <B>строка_1,строка_2,...</B>
 <BR>В качестве сцепляемых строк могут быть указаны имена ранее
 определенных макросов.
 <BR>К примеру:
 <TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
 <TR>
 <TD><TT><FONT COLOR="#000099">
 <PRE>
pre	equ	Привет,
name	equ	< Юля>
privet	catstr	pre,name	;privet= “Привет, Юля”
 </PRE>
 </FONT></TT></TD>
 </TR>
</TABLE>

<LI>директива выделения подстроки в строке <B>substr</B>:
<BR><EM><B>идентификатор substr строка,номер_позиции,размер</B></EM> — значением
 данного макроса будет часть заданной строки, начинающаяся с
 позиции с номером <EM>номер_позиции</EM> и длиной, указанной в <EM>размер</EM>.
<BR>Если требуется только остаток строки, начиная с некоторой
 позиции, то достаточно указать только <EM>номер_позиции</EM> без
 указания <EM>размера</EM>.
 <BR>К примеру:
  <TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
  <TR>
  <TD><TT><FONT COLOR="#000099">
  <PRE>
;продолжение предыдущего фрагмента:
privet	catstr	pre,name	;privet= “Привет, Юля”
name	substr	privet,7,3	;name=“Юля”
  </PRE>
  </FONT></TT></TD>
  </TR>
</TABLE>

<LI>директива определения вхождения одной строки в другую <B>instr</B>:
<BR><EM><B>идентификатор instr номер_нач_позиции,строка_1,строка_2</B></EM> —
 после обработки данного макроса транслятором <EM>идентификатору</EM>
 будет присвоено числовое значение, соответствующее номеру
 (первой) позиции, с которой совпадают <EM>строка_1</EM> и <EM>строка_2</EM>.
<BR>Если такого совпадения нет, то идентификатор получит значение <B>0</B>;
<LI>директива определения длины строки в текстовом макросе <B>sizestr</B>:
<BR><EM><B>идентификатор sizestr строка</B></EM> — в результате обработки данного
 макроса значение <EM>идентификатор</EM> устанавливается равным длине
 строки.
  <TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
  <TR>
  <TD><TT><FONT COLOR="#000099">
  <PRE>
;как продолжение предыдущего фрагмента:
privet	catstr	pre,name	;privet= “Привет, Юля”
len	sizestr	privet	;len=10
  </PRE>
  </FONT></TT></TD>
  </TR>
</TABLE>
</UL>

<P>Эти директивы очень удобно использовать при разработке
<EM>макрокоманд</EM>, которые являются следующим макросредством,
предоставляемым компилятором ассемблера.
   
<A NAME="Макрокоманды">
<H3>Макрокоманды</H3>
<P>Идейно макрокоманда представляет собой дальнейшее развитие
механизма замены текста.
<BR>С помощью макрокоманд в текст
программы можно вставлять последовательности строк (которые
логически могут быть данными или командами) и даже более
того — привязывать их к контексту места вставки.
<P>Представим ситуацию, когда необходимо выполнить некоторые
повторяющиеся действия. Программа из листинга 1 является
ярким этому примером.
<A NAME="Листинг_1">
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
  <TR>
  <TD><TT><FONT COLOR="#000099">
  <PRE>
Листинг 1. Пример программы на ассемблере
<1> ;---------Prg_3_1.asm----------------------------------
<2> ;Программа преобразования двузначного шестнадцатеричного числа
<3> ;в символьном виде в двоичное представление.
<4> ;Вход: исходное шестнадцатеричное число из двух цифр,
<5> ;вводится с клавиатуры.
<6> ;Выход: результат преобразования должен
<7> ;быть в регистре al.
<8> ;------------------------------------------------------
<9> data segment para public 'data'	;сегмент данных
<10> message	db	'Введите две шестнадцатеричные цифры,$'
<11> data ends
<12> stk segment stack
<13> 	db	256 dup ('?')	;сегмент стека
<14> stk ends
<15> code segment para public 'code'	;начало сегмента кода
<16> main	proc	;начало процедуры main
<17> 	assume cs:code,ds:data,ss:stk
<18> 	mov	ax,data	;адрес сегмента данных в регистр ax
<19> 	mov	ds,ax	;ax в ds
<20> 	mov	ah,9
<21> 	mov	dx,offset message
<22> 	int	21h
<23> 	xor	ax,ax	;очистить регистр ax
<24> 	mov	ah,1h	;1h в регистр ah
<25> 	int	21h	;генерация прерывания с номером 21h
<26> 	mov	dl,al	;содержимое регистра al в регистр dl
<27> 	sub	dl,30h	;вычитание: (dl)=(dl)-30h
<28> 	cmp	dl,9h	;сравнить (dl) с 9h
<29> 	jle	M1	;перейти на метку M1 если dl&lt;9h или dl=9h
<30> 	sub	dl,7h	;вычитание: (dl)=(dl)-7h
<31> M1:		;определение метки M1
<32> 	mov	cl,4h	;пересылка 4h в регистр cl
<33> 	shl	dl,cl	;сдвиг содержимого dl на 4 разряда влево
<34> 	int	21h	;вызов прерывания с номером 21h
<35> 	sub	al,30h	;вычитание: (dl)=(dl)-30h
<36> 	cmp	al,9h	;сравнить (al) с 9h	28
<37> 	jle	M2	;перейти на метку M2, если al&lt;9h или al=9h
<38> 	sub	al,7h	;вычитание: (al)=(al)-7h
<39> M2:			;определение метки M2
<40> 	add	dl,al	;сложение: (dl)=(dl)+(al)
<41> 	mov	ax,4c00h	;пересылка 4c00h в регистр ax
<42> 	int	21h	;вызов прерывания с номером 21h
<43> main endp		;конец процедуры main
<44> code ends		;конец сегмента кода
<45> end main		;конец программы с точкой входа main
  </PRE>
  </FONT></TT></TD>
  </TR>
</TABLE>

<P>Структурно в ней явно прослеживаются
повторяющиеся участки кода. Их можно оформить в виде
макрокоманд и использовать эти повторяющиеся фрагменты в
различных программах. 
<BR>Дальнейшее наше обсуждение будет
посвящено тому, как это сделать.
<P>Определимся с терминологией.
<BR><EM><B>Макрокоманда</B></EM> представляет
собой строку, содержащую некоторое символическое имя — <EM>имя
макрокоманды</EM>, предназначенную для того, чтобы быть замещенной
одной или несколькими другими строками.
Имя макрокоманды
может сопровождаться <EM><B>параметрами</B></EM>.
<P> Обычно программист сам
чувствует момент, когда ему нужно использовать макрокоманды в
своей программе. Если такая необходимость возникает и нет
готового, ранее разработанного варианта нужной макрокоманды,
то вначале необходимо задать ее <B>шаблон-описание</B>, который
называют <EM><B>макроопределением</B></EM>.
<BR>Синтаксис <EM>макроопределения</EM> следующий:
  <TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
  <TR>
  <TD><TT><FONT COLOR="#000099">
  <PRE>
имя_макрокоманды macro список_формальных_аргументов

тело макроопределения
	
endm
  </PRE>
  </FONT></TT></TD>
  </TR>
</TABLE>

<P>Где должны располагаться макроопределения?
<BR>Есть три варианта:
<OL>
<LI>В <EM>начале исходного текста программы</EM> до сегмента кода и
  данных с тем, чтобы не ухудшать читабельность программы.
  <BR>Этот
  вариант следует применять в случаях, если определяемые вами
  макрокоманды актуальны только в пределах одной этой программы.
<LI>В <EM>отдельном файле</EM>.
<BR>Этот вариант подходит при работе над
  несколькими программами одной проблемной области. Чтобы
  сделать доступными эти макроопределения в конкретной
  программе, необходимо в начале исходного текста этой программы
  записать директиву <B>include имя_файла</B>, к примеру:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
masm
model	small
include	show.inc
;в это место будет вставлен текст файла show.inc
...
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<LI>В <EM>макробиблиотеке</EM>.
<BR>Если у вас есть универсальные
  макрокоманды, которые используются практически во всех ваших
  программах, то их целесообразно записать в так называемую
  <EM><B>макробиблиотеку</B></EM>. Сделать актуальными макрокоманды из этой
  библиотеки можно с помощью все той же директивы <B>include</B>.
</OL>
<BR>Недостаток двух последних способов в том, что в исходный
  текст программы включаются абсолютно все макроопределения.
<BR>Для
  исправления ситуации можно использовать директиву <B>purge</B>, в
  качестве операндов которой через запятую перечисляются имена
  макрокоманд, которые не должны включаться в текст программы.
<BR>К примеру,
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
...
include	iomac.inc
purge	_outstr,_exit
...
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>В данном случае в исходный текст программы перед началом
компиляции TASM вместо строки <B>include iomac.inc</B> вставит строки
из файла <B>iomac.inc</B>. Но вставленный текст будет отличаться от
оригинала тем, что в нем будут отсутствовать макроопределения
<B>_outstr</B> и <B>_exit</B>.
<P>А теперь вернемся к программе из <A HREF="#Листинг_1">листинга 1</A>.
Проанализируем ее текст, выявим повторяющиеся участки и
составим для них макроопределения (листинг 2).
<A NAME="Листинг_2">
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
Листинг 2. Пример 1 создания и использования макрокоманд
<1>;prg_3_1.asm с макроопределениями
<2>init_ds	macro
<A NAME="3_7">
<3>;Макрос настройки ds на сегмент данных
<4>	mov	ax,data
<5>	mov	ds,ax
<6>	endm
<A NAME="9_18">
<7>out_str	macro	str
<8>;Макрос вывода строки на экран.
<9>;На входе — выводимая строка.
<10>;На выходе - сообщение на экране.
<11>	push	ax
<12>	mov	ah,09h
<13>	mov	dx,offset str
<14>	int	21h
<15>	pop	ax
<16>	endm
<17><A NAME="20_23">
<18>clear_r	macro	rg
<19>;очистка регистра rg
<20>	xor	rg,rg
<21>	endm
<22><A NAME="25_30">
<23>get_char	macro
<24>;ввод символа
<25>;введенный символ в al
<26>	mov	ah,1h
<27>	int	21h
<28>	endm
<29><A NAME="32_38">
<30>conv_16_2	macro
<31>;макрос преобразования символа шестнадцатеричной цифры 
<32>;в ее двоичный эквивалент в al
<33>	sub	dl,30h
<34>	cmp	dl,9h
<35>	jle	$+5
<36>	sub	dl,7h
<37>	endm
<38><A NAME="40_44">
<39>exit	macro
<40> ;макрос конца программы
<41>	mov	ax,4c00h
<42>	int	21h
<43>	endm
<44>
<45> data	segment para public 'data'
<46> message	db	'Введите две шестнадцатеричные цифры (буквы A,B,C,D,E,F — прописные): $'
<47> data	ends
<48>
<49> stk	segment	stack
<50>	db	256 dup('?')
<51> stk	ends
<52><A NAME="56_70">
<53> code	segment para public 'code'
<54>	assume	cs:code,ds:data,ss:stk
<55> main	proc
<56>	init_ds
<57>	out_str	message
<A NAME="58">
<58>	clear_r	ax
<59>	get_char
<60>	mov	dl,al
<61>	conv_16_2
<62>	mov	cl,4h
<63>	shl	dl,cl
<64>	get_char
<65>	conv_16_2
<66>	add	dl,al
<67>	xchg	dl,al	;результат в al
<68>	exit
<69> main	endp
<70> code	ends
<71> end	main
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>В листинге 2 в строках <A HREF="#3_7">3–7</A>,
<A HREF="#9_18">9–18</A>,
<A HREF="#20_23">20–23</A>,
<A HREF="#25_30">25–30</A>, 
<A HREF="#32_38">32–38</A>,
<A HREF="#40_44">40–44</A> описаны макроопределения. Их назначение приведено сразу
после заголовка в теле каждого макроопределения.
<P>Все эти
макроопределения можно использовать и при написании других
программ. Посмотрите на модернизированный исходный текст
программы из листинга 3.1 в листинге 2 (строки <A HREF="#56_70">56–70</A>). Если
не обращать внимания на некоторые неясные моменты, то сам
сегмент кода стал внешне более читабельным и даже можно
сказать, что в нем появился какой то смысл.
<P>Функционально макроопределения похожи на процедуры.
<BR>Сходство их в том, что и те, и другие достаточно один раз где-то
описать, а затем вызывать их специальным образом. На этом
их сходство заканчивается, и начинаются различия, которые в
зависимости от целевой установки можно рассматривать и как
достоинства и как недостатки:
<UL>
<LI>в отличие от процедуры, текст которой неизменен,
  макроопределение в процессе макрогенерации может меняться в
  соответствии с набором фактических параметров.
  <BR>При этом
  коррекции могут подвергаться как операнды команд, так и сами
  команды. Процедуры в этом отношении объекты менее гибки;
<LI>при каждом вызове макрокоманды ее текст в виде
макрорасширения вставляется в программу. 
<BR>При вызове процедуры
микропроцессор осуществляет передачу управления на начало
процедуры, находящейся в некоторой области памяти в одном
экземпляре. Код в этом случае получается более компактным,
хотя быстродействие несколько снижается за счет необходимости
осуществления переходов.
</UL>
<P>Макроопределение обрабатывается компилятором особым
образом. Для того чтобы использовать описанное
макроопределение в нужном месте программы, оно должно быть
активизировано с помощью макрокоманды указанием следующей
синтаксической конструкции:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
	имя_макрокоманды	список_фактических_аргументов
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Результатом применения данной синтаксической конструкции в
исходном тексте программы будет ее замещение строками из
конструкции тело макроопределения. Но это не простая замена.
<BR>Обычно макрокоманда содержит некоторый <EM>список аргументов</EM> —
<EM><B>список_фактических_аргументов</B></EM>, которыми корректируется
макроопределение.
<BR>Места в теле макроопределения, которые будут
замещаться фактическими аргументами из макрокоманды,
обозначаются с помощью так называемых <EM><B>формальных аргументов</B></EM>.
<BR>Таким образом, в результате применения макрокоманды в программе
<EM>формальные аргументы</EM> в макроопределении замещаются
соответствующими <EM>фактическими аргументами</EM>; в этом и
заключается учет контекста.
<BR>Процесс такого замещения
называется <B>макрогенерацией</B>, а результатом этого процесса
является <B>макрорасширение</B>.
<P>К примеру, рассмотрим самое короткое макроопределение в
<A HREF="#Листинг_2">листинге 2</A> — <B>clear_rg</B>.
<BR>Как отмечено выше, результаты работы
макроассемблера можно узнать, просмотрев файл листинга после
трансляции. Покажем несколько его фрагментов, которые
демонстрируют, как был описан текст макроопределения <B>clear_rg</B>
(строки <A HREF="#25_30">24-27</A>), как был осуществлен вызов макрокоманды
<B>clear_rg</B> с фактическим параметром <B>ax</B> (строка <A HREF="#58">58</A>) и как
выглядит результат работы макрогенератора, сформировавшего
команду ассемблера <B>xor ax,ax</B> (строка 75);
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
24		clear_r	macro	rg
25	;очистка регистра rg
26		xor	rg,rg
27		endm
...
74		clear_r	ax
75000E 33 C0	xor	ax,ax
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Таким образом в итоге мы получили то, что и требовалось —
команду очистки заданного регистра, в данном случае <B>ax</B>.
<BR>В другом месте программы вы можете выдать ту же макрокоманду, но
уже с другим именем регистра.

<P>Каждый <EM><B>фактический аргумент</B></EM> представляет собой строку
символов, для формирования которой применяются следующие
правила:
<UL>
<LI>строка может состоять из:
 <UL>
<LI>последовательности символов без пробелов, точек, запятых, точек с запятой;
<LI>последовательности любых символов, заключенных в угловые
скобки: &lt;...&gt;. В этой последовательности можно указывать как
пробелы, так и точки, запятые, точки с запятыми.
<BR>Не забывайте
о том, что угловые скобки &lt; &gt; — это тоже оператор ассемблера. Мы
упоминали о них при обсуждении директивы <B>equ</B>;
</UL>
<LI>для того чтобы указать, что некоторый символ внутри
  строки, представляющей фактический параметр, является
  собственно символом, а не чем-то иным, например некоторым
  разделителем или ограничивающей скобкой, применяется
  специальный оператор “<B>!</B>”.
  <BR>Этот оператор ставится
  непосредственно перед описанным выше символом, и его действие
  эквивалентно заключению данного символа в угловые скобки
  (см. предыдущий пункт);
<LI>если требуется вычисление в строке некоторого
константного выражения, то в начале этого выражения нужно
поставить знак “<B>%</B>”:
<BR><B>% константное_выражение</B> — значение <EM>константное_выражение</EM>
 вычисляется и подставляется в текстовом виде в соответствии с
 текущей системой счисления.
</UL> 
<P>Теперь обсудим вопрос — как транслятор распознает
<EM>формальные аргументы</EM> в теле макроопределения для их
последующей замены на <EM>фактические аргументы</EM>?
<P>Прежде всего по их именам в заголовке макроопределения. В
процессе генерации макрорасширения компилятор ассемблера ищет
в тексте тела макроопределения последовательности символов,
совпадающие с теми последовательностями символов, из которых
состоят <EM>формальные параметры</EM>. После обнаружения такого
совпадения <EM>формальный параметр</EM> из тела макроопределения
замещается соответствующим <EM>фактическим параметром</EM> из
макрокоманды. Этот процесс называется <EM><B>подстановкой аргументов</B></EM>.
<P>Здесь нужно еще раз особо отметить
<B>список_формальных_аргументов</B> в заголовке макроопределения.
<BR>В общем случае он содержит не только перечисление <EM>формальных
аргументов</EM> через запятую, но и некоторую дополнительную
информацию. Полный синтаксис <B>формального аргумента</B> следующий:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
	имя_формального_аргумента[:тип]
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

 где <B>тип</B> может принимать значения:
<UL>
<LI><B>REQ</B>, которое говорит о том, что требуется обязательное
  явное задание фактического аргумента при вызове макрокоманды;
<LI><B>=&lt;любая_строка&gt;</B> — если аргумент при вызове макрокоманды
не задан, то в соответствующие места в макрорасширении будет
вставлено значение по умолчанию, соответствующее значению
<EM>любая_строка</EM>.
<BR>Будьте внимательны: символы, входящие в
<EM>любая_строка</EM>, должны быть заключены в угловые скобки.
</UL>
<P>Но не всегда ассемблер может распознать в теле
макроопределения формальный аргумент. Это, например, может
произойти в случае, когда он является частью некоторого
идентификатора. В этом случае последовательность символов
формального аргумента отделяют от остального контекста с
помощью специального символа <B>&</B>.
<BR>Этот прием часто используется
для задания модифицируемых идентификаторов и кодов операций.
<BR>К примеру, определим макрос, который предназначен для генерации
в программе некоторой таблицы, причем параметры этой таблицы
можно задавать с помощью аргументов макрокоманды:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
...
def_table macro	type=b,len=REQ
tabl_&type	d&type	len dup (0)
endm
...
.data
def_tabl	b,10
def_tabl	w,5
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>После того как вы подвергнете трансляции текст программы,
содержащий эти строки, вы получите следующие макрорасширения:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
tabl_b	db	10 dup (0)
tabl_w	dw	10 dup (0)
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Символ <B>&</B> можно применять и для распознавания формального
аргумента в строке, заключенной в кавычки ' '. Например:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
num_char	macro	message
;...
;подсчитать количество (num) символов в строке
	jmp	m1
elem	db	'Строка &message содержит '
;число символов в строке message в коде ASCII
num	db	2 dup (0)
	db	' символов',10,13,'$'	;конец строки для вывода функцией 09h
m1:
;...
;вывести elem на экран
	endm
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>В связи с рассмотрением последнего фрагмента разберем
ситуацию, когда тело макроопределения содержит метку или имя в
директиве резервирования и инициализации данных. Если в
программе некоторая макрокоманда вызывается несколько раз, то
в процессе макрогенерации возникнет ситуация, когда в
программе один идентификатор будет определен несколько раз,
что, естественно, будет распознано транслятором как ошибка.
Для выхода из подобной ситуации применяют директиву <B>local</B>,
которая имеет следующий синтаксис:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
local список_идентификаторов
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>
<P>Эту директиву необходимо <EM>размещать непосредственно за
заголовком макроопределения</EM>.
<BR>Результатом работы этой директивы
будет генерация в каждом экземпляре макрорасширения уникальных
имен для всех идентификаторов, перечисленных в
список_идентификаторов. Эти уникальные имена имеют вид <B>??xxxx</B>,
где <B>хххх</B> — шестнадцатеричное число.
<BR>Для первого идентификатора
в первом экземпляре макрорасширения <B>хххх= 0000</B>, для второго —
<B>хххх= 0001</B> и т. д. Контроль за правильностью размещения и
использования этих уникальных имен берет на себя ассемблер.

<P>Для того чтобы вам окончательно все стало понятно, введем и
подвергнем трансляции листинг 3. В нем, кроме некоторых
ранее рассмотренных макрокоманд, содержится макрокоманда
<VAR>num_char</VAR>. Ее назначение — подсчитывать количество символов в
строке, адрес которой передается этой макрокоманде в качестве
фактического параметра. Строка должна удовлетворять
требованию, предъявляемому к строке, предназначенной для
вывода на экран функцией <B>09h</B> прерывания <B>21h</B>, то есть
заканчиваться символом <B>$</B>.
<BR>Другой момент, который нашел
отражение в этой программе, — использование символа <B>$</B> для
распознавания формального аргумента в строке, заключенной в
кавычки ' ' (см. последний фрагмент).
  <P>Листинг 3. Пример 2 создания и использования макрокоманд
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
;prg_13_2.asm
init_ds	macro
;макрос настройки ds на сегмент данных
	mov	ax,data
	mov	ds,ax
	xor	ax,ax
	endm
out_str	macro	str
;макрос вывода строки на экран.
;На входе — выводимая строка.
;На выходе — сообщение на экране.
	push	ax
	mov	ah,09h
	mov	dx,offset str
	int	21h
	pop	ax
	endm
exit	macro
;макрос конца программы
	mov	ax,4c00h
	int	21h
	endm
num_char	macro	message
	local
m1,elem,num,err_mes,find,num_exit
;макрос подсчета количества символов в строке.
;Длина строки — не более 99 символов.
;Вход: message — адрес строки символов, ограниченной '$'
;Выход: в al — количество символов в строке message и вывод сообщения
	jmp	m1
elem	db	'Строка &message содержит '
num	db	2 dup (0) ;число символов в строке message в коде ASCII
	db	' символов',10,13,'$'	;конец строки для вывода функцией 09h
err_mes	db	'Строка &message не содержит символа конца строки',10,13,'$'
m1:
;сохраняем используемые в макросе регистры
	push	es
	push	cx
	push	ax
	push	di
	push	ds
	pop	es	;настройка es на ds
	mov	al,'$'	;символ для поиска — `$`
	cld		;сброс флага df
	lea	di,message	;загрузка в es:di смещения строки message
	push	di	;запомним di — адрес начала строки
	mov	cx,99	;для префикса repne — максимальная длина строки
;поиск в строке (пока нужный символ и символ в строке не равны)
;выход — при первом совпавшем
repne	scasb
	je	find	;если символ найден — переход на обработку
;вывод сообщения о том, что символ не найден
	push	ds
;подставляем cs вместо ds для функции 09h (int21h)
	push	cs
	pop	ds
	out_str	err_mes
	pop	ds
	jmp	num_exit	;выход из макроса
find:	;совпали
;считаем количество символов в строке:
	pop	ax	;восстановим адрес начала строки
	sub	di,ax	;(di)=(di)-(ax)
	xchg	di,ax	;(di) <-> (ax)
	sub	al,3	;корректировка на служебные символы — 10, 13, '$'
	aam		;в al две упакованные BCD-цифры результата подсчета
	or	ax,3030h	;преобразование результата в код ASCII
	mov	cs:num,ah
	mov	cs:num+1,al
;вывести elem на экран
	push	ds
;подставляем cs вместо ds для функции 09h (int21h)
	push	cs
	pop	ds
	out_str	elem
	pop	ds
num_exit:
	push	di
	push	ax
	push	cx
	push	es
	endm

data	segment	para public 'data'
msg_1	db	'Строка_1 для испытания',10,13,'$'
msg_2	db	'Строка_2 для второго испытания',10,13,'$'
data ends

stk	segment	stack
	db	256 dup('?')
stk	ends

code	segment	para public 'code'
	assume	cs:code,ds:data,ss:stk
main	proc
	init_ds
	out_str	msg_1
	num_char	msg_1
	out_str	msg_2
	num_char	msg_2
	exit
main	endp
code	ends
end	main
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>
<P>В теле макроопределения можно размещать <EM>комментарии</EM> и
делать это особым образом.
<BR>Если применить для обозначения
комментария не одну, как обычно, а две подряд идущие точки с
запятой, то при генерации макрорасширения этот комментарий
будет исключен.
<BR>Если по какой-то причине необходимо
присутствие комментария в макрорасширении, то его нужно
задавать обычным образом, то есть с помощью одинарной точки с
запятой. Например:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
mes	macro	messsage
...		;этот комментарий будет включен в текст листинга
...		;;этот комментарий не будет включен в текст листинга
	endm
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<A NAME="Макродирективы">
<H3>Макродирективы</H3>
<P>С помощью макросредств ассемблера можно не только частично
изменять входящие в макроопределение строки, но и
модифицировать сам набор этих строк и даже порядок их
следования. Сделать это можно с помощью набора макродиректив
(далее — просто директив). Их можно разделить на две группы:
<UL>
<LI>директивы повторения <A HREF="#WHILE"><B>WHILE</B></A>,
<A HREF="#WHILE"><B>REPT</B></A>,
<A HREF="#IRP"><B>IRP</B></A>
и <A HREF="#IRPC"><B>IRPC</B></A>.
<BR>Директивы этой группы предназначены для создания макросов, содержащих
  несколько идущих подряд одинаковых последовательностей строк.
  При этом возможна частичная модификация этих строк.
<LI>директивы управления процессом генерации макрорасширения
<A HREF="#EXITM"><B>EXITM</B></A> и 
<A HREF="#GOTO"><B>GOTO</B></A>.
<BR>Они предназначены для управления процессом
формирования макрорасширения из набора строк соответствующего
макроопределения. С помощью этих директив можно как исключать
отдельные строки из макрорасширения, так и вовсе прекращать
процесс генерации. Директивы <B>EXITM</B> и <B>GOTO</B> обычно используются
вместе с условными директивами компиляции, поэтому они будут
рассмотрены вместе с ними.
</UL>
   
<A NAME="WHILE">   
<H4>Директивы WHILE и REPT</H4>
<P>Директивы <B>WHILE</B> и <B>REPT</B> применяют для повторения
определенное количество раз некоторой последовательности
строк.
<BR>Эти директивы имеют следующий синтаксис:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
WHILE	константное_выражение
последовательность_строк
ENDM
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>   

<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>   
REPT	константное_выражение
последовательность строк
ENDM
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>   
<P>Обратите внимание, что последовательность повторяемых строк
в обеих директивах ограничена директивой <B>ENDM</B>.
<P>При использовании директивы <B>WHILE</B> макрогенератор
транслятора будет повторять последовательность_строк до тех
пор, пока значение <EM><B>константное_выражение</B></EM> не станет равно нулю.
Это значение вычисляется каждый раз перед очередной итерацией
цикла повторения (то есть значение <EM><B>константное_выражение</B></EM>
должно подвергаться изменению внутри <EM><B>последовательность_строк</B></EM>
в процессе макрогенерации).
<P>Директива <B>REPT</B>, подобно директиве <B>WHILE</B>, повторяет
<EM><B>последовательность_строк</B></EM> столько раз, сколько это определено
значением <EM><B>константное_выражение</B></EM>. Отличие этой директивы от
<B>WHILE</B> состоит в том, что она автоматически уменьшает на
единицу значение <EM><B>константное_выражение</B></EM> после каждой итерации.
<P>В качестве примера рассмотрим листинг 4, в котором
демонстрируется применение директив <B>WHILE</B> и <B>REPT</B> для
резервирования области памяти в сегменте данных. Имя
идентификатора и длина области задаются в качестве параметров
для соответствующих макросов <VAR>def_sto_1</VAR> и <VAR>def_sto_2</VAR>.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>   
Листинг 4. Использование директив повторения
;prg_13_3.asm
def_sto_1	macro	id_table,ln:=<5>
;макрос резервирования памяти длиной len.
;Используется WHILE
id_table	label	byte
len=ln
	while	len
	db	0
	len=len-1
	endm
endm
def_sto_2	macro	id_table,len
;макрос резервирования памяти длиной len
id_table	label	byte
	rept	len
	db	0
	endm
endm

data	segment	para public 'data'
	def_sto_1	tab_1,10
	def_sto_2	tab_2,10
data	ends
;сегменты команд и стека в этой программе необязательны
end
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>
<P>Заметьте, что счетчик повторений в директиве <B>REPT</B>
уменьшается автоматически после каждой итерации цикла.
Проанализируйте результат трансляции листинга 13.3.
<P>Таким образом, директивы <B>REPT</B> и <B>WHILE</B> удобно применять для
“размножения” в тексте программы последовательности одинаковых
строк без внесения в эти строки каких-либо изменений.
<P>Следующие две директивы, <A HREF="#IRP"><B>IRP</B></A>
и <A HREF="#IRPC"><B>IRPC</B></A>, делают этот процесс более
гибким, позволяя модифицировать на каждой итерации некоторые
элементы в последовательность_строк.

<A NAME="IRP">
<H4>Директива IRP</H4>
<P>Директива <B>IRP</B> имеет следующий синтаксис:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
IRP формальный_аргумент,<строка_символов_1,...,строка_символов_N>
	последовательность_строк
ENDM
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>
<P>Действие данной директивы заключается в том, что она
повторяет последовательность_строк N раз, то есть столько раз,
сколько <EM><B>строк_символов</B></EM> заключено в угловые скобки во втором
операнде директивы <B>IRP</B>. Но это еще не все.
<BR>Повторение <EM><B>последовательности_строк</B></EM>
 сопровождается заменой в ней 
<EM><B>формального_аргумента</B></EM> строкой символов из второго операнда.
<BR>Так, при первой генерации <EM><B>последовательности_строк</B></EM>
<EM><B>формальный_аргумент</B></EM> в них заменяется на <EM><B>строка_символов_1</B></EM>.
<BR>Если есть <EM><B>строка_символов_2</B></EM>, то это приводит к генерации
второй копии <EM><B>последовательности_строк</B></EM>, в которой
<EM><B>формальный_аргумент</B></EM> заменяется на <EM><B>строка_символов_2</B></EM>. Эти
действия продолжаются до <EM><B>строка_символов_N</B></EM> включительно.
<P>К примеру, рассмотрим результат определения в программе следующей конструкции:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
	irp	ini,<1,2,3,4,5>
	db	ini
	endm
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>
<P>Макрогенератором будет сгенерировано следующее макрорасширение:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
	db	1
	db	2
	db	3
	db	4
	db	5
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<A NAME="IRPC">
<H4>Директива IRPC</H4>
<P>Директива <B>IRPC</B> имеет следующий синтаксис:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
IRPC	формальный_аргумент,строка_символов
	последовательность строк
ENDM
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>
<P>Действие данной директивы подобно <B>IRP</B>, но отличается тем,
что она на каждой очередной итерации заменяет
<EM><B>формальный_аргумент</B></EM> очередным символом из <EM><B>строка_символов</B></EM>.
<BR>Понятно, что количество повторений <EM><B>последовательность_строк</B></EM>
будет определяться количеством символов в <EM><B>строка_символов</B></EM>.
<BR>К примеру:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
	irpc	rg,<abcd>
	push	rg&x
	endm
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>
<P>В процессе макрогенерации эта директива развернется в
следующую последовательность строк:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
	push	ax
	push	bx
	push	cx
	push	dx
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<A NAME="ДирективыУсловнойКомпиляции">
<H3>Директивы условной компиляции</H3>
<P>Последний тип макросредств — директивы условной компиляции.
<BR>Существует два типа этих директив:
<UL>
<LI><A HREF="#ДирективыКомпиляцииПоУсловию"><EM>директивы компиляции по условию</EM></A> позволяют
  проанализировать определенные условия в ходе генерации
  макрорасширения и, при необходимости, изменить этот процесс;
<LI><A HREF="#ДирективыГенерацииОшибокПоУсловию"><EM>директивы генерации ошибок по условию</EM></A> также контролируют
ход генерации макрорасширения с целью генерации или
обнаружения определенных ситуаций, которые могут
интерпретироваться как ошибочные.
</UL>

<P>С этими директивами применяются директивы управления
процессом генерации макрорасширений <B>EXITM</B> и <B>GOTO</B>.
<A NAME="EXITM">
<P>Директива <B>EXITM</B> не имеет операндов, и ее действие
заключается в том, что она немедленно прекращает процесс
генерации макрорасширения, начиная с того места, где она
встретилась в макроопределении.
<P>Директива <B>GOTO</B> <EM><B>имя_метки</B></EM> переводит процесс генерации
макроопределения в другое место, прекращая тем самым
последовательное разворачивание строк макроопределения. <EM>Метка</EM>,
на которую передается управление, имеет специальный формат:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
:имя_метки
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Примеры применения этих директив будут приведены ниже.

<A NAME="ДирективыКомпиляцииПоУсловию">
<H3>Директивы компиляции по условию</H3>
<P>Данные директивы предназначены для организации выборочной
трансляции фрагментов программного кода. Такая выборочная
компиляция означает, что в макрорасширение включаются не все
строки макроопределения, а только те, которые удовлетворяют
определенным условиям. То, какие конкретно условия должны быть
проверены, определяется типом условной директивы.
<P>Введение в
язык ассемблера этих директив значительно повышает его мощь.
<BR>Всего имеется 10 типов условных директив компиляции. Их
логично попарно объединить в четыре группы:
<OL>
<LI>Директивы <A HREF="#IF"><EM><B>IF</B></EM></A> и <A HREF="#IF"><EM><B>IFE</B></EM></A>
— условная трансляция <EM>по результату
  вычисления логического выражения</EM>.
<LI>Директивы <A HREF="#IFDEF"><EM><B>IFDEF</B></EM></A> и <A HREF="#IFDEF"><EM><B>IFNDEF</B></EM></A> — 
условная трансляция <EM>по факту
определения символического имени</EM>.
<LI>Директивы <A HREF="#IFB"><EM><B>IFB</B></EM></A> и <A HREF="#IFB"><EM><B>IFNB</B></EM></A> — 
условная трансляция <EM>по факту
определения фактического аргумента при вызове макрокоманды</EM>.
<LI>Директивы <A HREF="#IFIDN"><EM><B>IFIDN</B></EM></A>, <A HREF="#IFIDN"><EM><B>IFIDNI</B></EM></A>, 
<A HREF="#IFIDN"><EM><B>IFDIF</B></EM></A> и <A HREF="#IFIDN"><EM><B>IFDIFI</B></EM></A>
— условная трансляция <EM>по результату сравнения строк символов</EM>.
</OL>

<P>Условные директивы компиляции имеют общий синтаксис и
применяются в составе следующей синтаксической конструкции:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
IFxxx	логическое_выражение_или_аргументы
фрагмент_программы_1
	ELSE
фрагмент_программы_2
ENDIF
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Заключение некоторых фрагментов текста программы —
<EM><B>фрагмент_программы_1</B></EM> и <EM><B>фрагмент_программы_2</B></EM> — между
директивами <B>IFxxx</B>, <B>ELSE</B> и <B>ENDIF</B> приводит к их выборочному
включению в объектный модуль. Какой именно из этих
фрагментов — <EM><B>фрагмент_программы_1</B></EM> или <EM><B>фрагмент_программы_2</B></EM> —
будет включен в объектный модуль, зависит от конкретного типа
условной директивы, задаваемого значением <B>xxx</B>, и значения
условия, определяемого операндом (операндами) условной
директивы <EM><B>логическое_выражение_или_аргумент(ы)</B></EM>.
<P>Синтаксические конструкции, соответствующие директивам условной компиляции,
могут быть вложенными друг в друга
(см.<A HREF="#Вложенность"><EM> "Вложенность директив условной трансляции"</EM></A>)

<A NAME="IF">
<H4>Директивы IF и IFE</H4>
<P>Синтаксис этих директив следующий:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
IF(E)	логическое_выражение
фрагмент_программы_1
	ELSE
фрагмент_программы_2
ENDIF
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Обработка этих директив макроассемблером заключается в
вычислении <EM><B>логического_выражения</B></EM> и включении в объектный
модуль <EM><B>фрагмент_программы_1</B></EM> или <EM><B>фрагмент_программы_2</B></EM> в
зависимости от того, в какой директиве <B>IF</B> или <B>IFE</B> это выражение
встретилось:
<UL>
<LI>если в директиве <B>IF</B> логическое выражение <U>истинно</U>, то в
  объектный модуль помещается <EM><B>фрагмент_программы_1</B></EM>.
  <BR>Если
  логическое выражение <U>ложно</U>, то при наличии директивы <B>ELSE</B> в
  объектный код помещается <EM><B>фрагмент_программы_2</B></EM>. Если же
  директивы <B>ELSE</B> нет, то вся часть программы между директивами
  <B>IF</B> и <B>ENDIF</B> игнорируется и в объектный модуль ничего не
  включается. Кстати сказать, понятие <U>истинности</U> и <U>ложности</U>
  значения <EM><B>логического_выражения</B></EM> весьма условно. <EM>Ложным</EM> оно
  будет считаться, если его значение равно нулю, а <EM>истинным</EM> —
  при любом значении, отличном от нуля.
<LI>директива <B>IFE</B> аналогично директиве <B>IF</B> анализирует
значение <EM><B>логического_выражения</B></EM>. Но теперь для включения
<EM><B>фрагмент_программы_1</B></EM> в объектный модуль требуется, чтобы
<EM><B>логическое_выражение</B></EM> имело значение <U>“ложь”</U>.
</UL>
<P>Директивы <B>IF</B> и <B>IFE</B> очень удобно использовать при
необходимости изменения текста программы в зависимости от
некоторых условий.
<P>К примеру, составим макрос для определения
в программе области памяти длиной не более 50 и не менее
10 байт (листинг 5).
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
Листинг 5. Использование условных директив IF и IFE
<1>;prg_13_4.asm
<2>masm
<3>model	small
<4>	stack	256
<5>	def_tab_50	macro	len
<6>if	len	GE 50
<7>GOTO	exit
<8>endif
<9>	if	len LT 10
<10>:exit
<11>EXITM
<12>endif
<13>rept	len
<14>	db	0
<15>endm
<16>endm
<17>.data
<18>def_tab_50	15
<19> def_tab_50	5
<20>.code
<21>main:
<22>	mov	ax,@data
<23>	mov	ds,ax
<24>exit:
<25>	mov	ax,4c00h
<26>	int	21h
<27>end	main
ENDIF
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Введите и оттранслируйте листинг 5. При этом не забывайте о том,
что условные директивы действуют на шаге трансляции, и
поэтому результат их работы можно увидеть только после
макрогенерации, то есть в листинге программы.
<BR>В нем вы
увидите, что в результате трансляции строка 18 листинга 5
развернется в пятнадцать нулевых байт, а строка 19 оставит
макрогенератор совершенно равнодушным, так как значение
фактического операнда в строках 6 и 9 будет ложным. Обратите
внимание, что для обработки реакции на ложный результат
анализа в условной директиве мы использовали макродирективы
<B>EXITM</B> и <B>GOTO</B>.
<P>Другой интересный и полезный вариант применения директив <B>IF</B>
и <B>IFE</B> — <U>отладочная печать</U>.
<BR>Суть здесь в том, что в процессе
отладки программы почти всегда возникает необходимость
динамически отслеживать состояние определенных программно-
аппаратных объектов, в качестве которых могут выступать
переменные, регистры микропроцессора и т. п. После этапа
отладки отпадает необходимость в таких диагностических
сообщениях. Для их устранения нужно корректировать исходный
текст программы, после чего ее следует подвергнуть повторной
трансляции. Но есть более изящный выход.
<BR>Можно определить в
программе некоторую переменную, к примеру <VAR>debug</VAR>, и
использовать ее совместно с условными директивами <B>IF</B> или <B>IFE</B>.
К примеру,
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
<1>...
<2>debug	equ	1
<3>...
<4>.code
<5>...
<6>if	debug
<7>;любые команды и директивы ассемблера
<8>;(вывод на печать или монитор)
<9>endif
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>На время отладки и тестирования программы вы можете
заключить отдельные участки кода в своеобразные операторные
скобки в виде директив <B>IF</B> и <B>ENDIF</B> (строки 6-9 последнего
фрагмента), которые реагируют на значение логической
переменной <VAR>debug</VAR>. При значении <B>debug = 0</B> транслятор полностью
проигнорирует текст внутри этих условных операторных скобок;
при <B>debug = 1</B>, наоборот, будут выполнены все действия,
описанные внутри них.

<A NAME="IFDEF">
<H4>Директивы IFDEF и IFNDEF</H4>
<P>Синтаксис этих директив следующий:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
IF(N)DEF	символическое_имя
фрагмент_программы_1
	ELSE
фрагмент_программы_2
ENDIF
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Данные директивы позволяют управлять трансляцией фрагментов
программы в зависимости от того, определено или нет в
программе некоторое <EM><B>символическое_имя</B></EM>. Директива <B>IFDEF</B>
проверяет, описано или нет в программе <EM><B>символическое_имя</B></EM>, и
если это так, то в объектный модуль помещается
<EM><B>фрагмент_программы_1</B></EM>. В противном случае, при наличии
директивы <B>ELSE</B>, в объектный код помещается
<EM><B>фрагмент_программы_2</B></EM>.
<BR>Если же директивы <B>ELSE</B> нет (и
<EM><B>символическое_имя</B></EM> в программе не описано), то вся часть
программы между директивами <B>IF</B> и <B>ENDIF</B> игнорируется и в
объектный модуль не включается.
<P>Действие <B>IFNDEF</B> обратно <B>IFDEF</B>. Если <EM><B>символического_имени</B></EM> в
программе нет, то транслируется <EM><B>фрагмент_программы_1</B></EM>. Если оно
присутствует, то при наличии <B>ELSE</B> транслируется
<EM><B>фрагмент_программы_2</B></EM>. Если <B>ELSE</B> отсутствует, а
<EM><B>символическое_имя</B></EM> в программе определено, то часть программы,
заключенная между <B>IFNDEF</B> и <B>ENDIF</B>, игнорируется.
<P>В качестве примера рассмотрим ситуацию, когда в объектный
модуль программы должен быть включен один из трех фрагментов
кода. Какой из трех фрагментов будет включен в объектный
модуль, зависит от значения некоторого идентификатора <VAR>switch</VAR>:
<UL>
<LI>если <VAR>switch = 0</VAR>, то сгенерировать фрагмент для вычисления
  выражения <BR><B>y = x*2**n</B>;
<LI>если <VAR>switch = 1</VAR>, то сгенерировать фрагмент для вычисления
выражения <BR><B>y = x/2**n</B>;
<LI>если <VAR>switch</VAR> не определен, то ничего не генерировать.
</UL>
<P>Соответствующий фрагмент исходной программы может выглядеть так:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
ifndef	sw	;если sw не определено, то выйти из макроса
EXITM
else		;иначе — на вычисление
	mov	cl,n
ife	sw
	sal	x,cl	;умножение на степень 2 сдвигом влево
	else
	sar	x,cl	;деление на степень 2 сдвигом вправо
	endif
endif
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>
<P>Как видим, эти директивы логически связаны с директивами <B>IF</B>
и <B>IFE</B>, то есть их можно применять в тех же самых случаях, что
и последние.
<BR>Есть еще одна интересная возможность
использования этих директив. На уроке 4 мы обсуждали формат командной строки
 и говорили об опциях, которые в
ней можно задавать. Вспомните одну из опций командной строки TASM — опцию 
<BR><B>/dидентификатор=значение</B>.
<BR>Ее использование дает возможность
управлять значением идентификатора прямо из командной строки транслятора,
не изменяя при этом текста программы.
<BR>В качестве примера
рассмотрим листинг 6, в котором мы попытаемся с помощью
макроса контролировать процесс резервирования и инициализации
некоторой области памяти в сегменте данных.
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
Листинг 6. Инициализация значения идентификатора из командной строки
<1>;prg_13_5.asm
<2>masm
<3>model	small
<4>	stack	256
<5>def_tab_50	macro	len
<6>ifndef	len
<7>display	'size_m не определено, задайте значение 10<size_m<50'
<8>exitm
<9>else
<10>if	len GE 50
<11>GOTO exit
<12>endif
<13>if	len LT 10
<14>:exit
<15>EXITM
<16>endif
<17>rept	len
<18>	db	0
<19>endm
<20>endif
<21>endm
<22>;size_m=15
<23>.data
<24>def_tab_50	size_m
<25>
<26>.code
<27>main:
<28>	mov	ax,@data
<29>	mov	ds,ax
<30>exit:
<31>	mov	ax,4c00h
<32>	int	21h
<33>end	main
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>
<P>Запустив этот пример на трансляцию, вы получите сообщение о
том, что забыли определить значение переменной <VAR>size_m</VAR>. После
этого попробуйте два варианта действий:
<OL>
<LI>Определите где-то в начале исходного текста программы
  значение этой переменной с помощью <B>equ</B>:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
size_m equ 15
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>
<LI>Запустите программу на трансляцию командной строкой вида
<BR><B>tasm /dsize_m=15 /zi prg_13_2,,,</B>
</OL>
<P>В листинге 6 мы использовали еще одну возможность
транслятора — директиву <A HREF="#display"><EM><B>display</B></EM></A>, с помощью которой можно
формировать пользовательское сообщение в процессе трансляции
программы.
   
<A NAME="IFB">
<H4>Директивы IFB и IFNB</H4>
<P>Синтаксис этих директив следующий:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
IF(N)B	аргумент
фрагмент_программы_1
	ELSE
фрагмент_программы_2
ENDIF
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Данные директивы используются для проверки фактических
параметров, передаваемых в макрос. При вызове макрокоманды они
анализируют значение аргумента, и в зависимости от того, равно
оно пробелу или нет, транслируется либо <EM><B>фрагмент_программы_1</B></EM>,
либо <EM><B>фрагмент_программы_1</B></EM>. Какой именно фрагмент будет выбран,
зависит от кода директивы:
<UL>
<LI>Директива <B>IFB</B> проверяет равенство <EM><B>аргумента</B></EM> пробелу. В
  качестве <EM><B>аргумента</B></EM> могут выступать <U>имя</U> или <U>число</U>.
  <BR>Если его
  значение равно <EM>пробелу</EM> (то есть фактический аргумент при
  вызове макрокоманды не был задан), то транслируется и
  помещается в объектный модуль <EM><B>фрагмент_программы_1</B></EM>.
  <BR>В
  противном случае, при наличии директивы <B>ELSE</B>, в объектный код
  помещается <EM><B>фрагмент_программы_1</B></EM>. Если же директивы <B>ELSE</B> нет,
  то при равенстве <EM><B>аргумента</B></EM> <EM>пробелу</EM> вся часть программы между
  директивами <B>IFB</B> и <B>ENDIF</B> игнорируется и в объектный модуль не
  включается.
<LI>Действие <B>IFNB</B> обратно <B>IFB</B>. Если значение <EM><B>аргумента</B></EM> в
программе не равно <EM>пробелу</EM>, то транслируется
<EM><B>фрагмент_программы_1</B></EM>.
<BR>В противном случае, при наличии
директивы <B>ELSE</B>, в объектный код помещается
<EM><B>фрагмент_программы_1</B></EM>. Если же директивы <B>ELSE</B> нет, то вся часть
программы (при неравенстве <EM><B>аргумента</B></EM> <EM>пробелу</EM>) между
директивами <B>IFNB</B> и <B>ENDIF</B> игнорируется и в объектный модуль не
включается.
</UL>
<P>В качестве типичного примера применения этих директив
предусмотрим строки в макроопределении, которые будут
проверять, указывается ли фактический аргумент при вызове
соответствующей макрокоманды:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
show	macro	reg
ifb	<reg>
display	'не задан регистр'
exitm
endif
...
endm
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>
<P>Если теперь в сегменте кода вызвать макрос <VAR>show</VAR> без
аргументов, то будет выведено сообщение о том, что не задан
регистр и генерация макрорасширения будет прекращена
директивой <B>exitm</B>.

<A NAME="IFIDN">
<H4>Директивы IFIDN, IFIDNI, IFDIF и IFDIFI</H4>
<P>Эти директивы позволяют не просто проверить наличие или
значение аргументов макрокоманды, но и выполнить идентификацию
аргументов как строк символов.
<P>Синтаксис этих директив:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
IFIDN(I)	аргумент_1,аргумент_2
фрагмент_программы_1
	ELSE
фрагмент_программы_2
ENDIF
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
IFDIF(I)	аргумент_1,аргумент_2
фрагмент_программы_1
	ELSE
фрагмент_программы_2
ENDIF
</PRE>
</FONT></TT></TD>
</TR>
</TABLE> 

<P>В этих директивах проверяются <EM><B>аргумент_1</B></EM> и <EM><B>аргумент_2</B></EM> как
<U>строки символов</U>. Какой именно код — <EM><B>фрагмент_программы_1</B></EM> или
<EM><B>фрагмент_программы_1</B></EM> — будет транслироваться по результатам
сравнения, зависит от кода директивы. 
<BR>Парность этих директив
объясняется тем, что они позволяют учитывать либо не
учитывать различие строчных и прописных букв. Так, директивы
<B>IFIDNI</B> и <B>IFDIFI</B> игнорируют это различие, а <B>IFIDN</B> и <B>IFDIF</B> —
учитывают.
<P>Директива <B>IFIDN</B>(I) сравнивает символьные значения
<EM><B>аргумент_1</B></EM> и <EM><B>аргумент_2</B></EM>.
<BR>Если результат сравнения
положительный, то <EM><B>фрагмент_программы_1</B></EM> транслируется и
помещается в объектный модуль. 
<BR>В противном случае, при наличии
директивы <B>ELSE</B>, в объектный код помещается
<EM><B>фрагмент_программы_1</B></EM>.
<BR>Если же директивы <B>ELSE</B> нет, то вся часть
программы между директивами <B>IFIDN</B>(I) и <B>ENDIF</B> игнорируется и в
объектный модуль не включается.
<P>Действие <B>IFDIF</B>(I) обратно <B>IFIDN</B>(I).
<BR>Если результат
сравнения отрицательный (строки не совпадают), транслируется
<EM><B>фрагмент_программы_1</B></EM>.
<BR>В противном случае все происходит
аналогично рассмотренным ранее директивам.
<P>Как мы уже упоминали, эти директивы <CITE>удобно применять
для проверки фактических аргументов макрокоманд</CITE>.
<BR>К примеру,
проверим, какой из регистров — <B>al</B> или <B>ah</B> — передан в макрос в
качестве параметра (проверка проводится без учета различия
строчных и прописных букв):
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
show	macro	rg
ifdifi	<al>,<rg>
goto	M_al
else
ifdifi	<ah>,<rg>
goto	M_ah
else
exitm
endif
endif
:M_al
...
:M_ah
...
endm
ENDIF
</PRE>
</FONT></TT></TD>
</TR>
</TABLE> 

<A NAME="Вложенность">   
<H4>Вложенность директив условной трансляции</H4>
<P>Как мы неоднократно видели в приведенных выше примерах,
TASM допускает вложенность условных директив компиляции. Более
того, так как вложенность требуется довольно часто, TASM
предоставляет набор дополнительных директив формата <EM><B>ELSEIFxxx</B></EM>,
которые заменяют последовательность подряд идущих <B>ELSE</B> и <EM><B>IFxxx</B></EM>
в структуре:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
IFxxx
;
	ELSE
	IFxxx
;...
ENDIF
ENDIF
</PRE>
</FONT></TT></TD>
</TR>
</TABLE> 

   Эту последовательность условных директив можно заменить
эквивалентной последовательностью дополнительных директив:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
IFxxx
;...
	ELSEIFxxx
;...
ENDIF
</PRE>
</FONT></TT></TD>
</TR>
</TABLE> 

<P>Наличие <B>xxx</B> в ELSExxx говорит о том, что каждая из директив
<B>IF</B>, <B>IFB</B>, <B>IFIDN</B> и т. д. имеет аналогичную директиву <EM><B>ELSEIF</B></EM>,
<EM><B>ELSEIFB</B></EM>, <EM><B>ELSEIFIDN</B></EM> и т. д.
<BR>В конечном итоге это улучшает
читаемость кода. В последнем примере фрагмента макроса,
проверяющем, имя какого регистра было передано в макрос,
наблюдается подобная ситуация. Последовательность <B>ELSE</B> и
<B>IFDIFI</B> можно записать так, как в строке 4:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
<1>show	macro	rg
<2>ifdifi	<al>,<rg>
<3>goto	M_al
<4>elseifdifi	<ah>,<rg>
<5>	goto	M_ah
<6>else
<7>exitm
<8>endif
<9>:M_al
<10>...
<11>:M_ah
<12>...
<13>endm
</PRE>
</FONT></TT></TD>
</TR>
</TABLE> 

   
<A NAME="ДирективыГенерацииОшибокПоУсловию">
<H3>Директивы генерации ошибок</H3>
<P>В языке TASM есть ряд директив, называемых <EM>директивами
генерации пользовательской ошибки</EM>. Их можно рассматривать и
как самостоятельное средство, и как метод, расширяющий
возможности директив условной компиляции. Они предназначены
для обнаружения различных ошибок в программе, таких как
неопределенные метки или пропуск параметров макроса.
<P><EM>Директивы
генерации пользовательской ошибки</EM> по принципу работы можно
разделить на два типа:
<UL>
<LI><A HREF="#БезусловныеДирективы"><EM>безусловные директивы</EM></A>,
генерирующие ошибку трансляции без
  проверки каких-либо условий;
<LI><A HREF="#УсловныеДирективы"><EM>условные директивы</EM></A>,
генерирующие ошибку трансляции после
проверки определенных условий.
</UL>
<P>Большинство директив генерации ошибок имеют два
обозначения, хотя принцип их работы одинаков. Второе название
отражает их сходство с директивами условной компиляции. При
дальнейшем обсуждении такие парные директивы будут приводиться
в скобках.
   
<A NAME="БезусловныеДирективы">   
<H4>Безусловная генерация пользовательской ошибки</H4>
<P>К безусловным директивам генерации пользовательской ошибки
относится только одна директива — это <EM><B>ERR (.ERR)</B></EM>.
<P>Данная директива, будучи вставлена в текст программы,
безусловно приводит к генерации ошибки на этапе трансляции и
удалению объектного модуля. Она очень эффективна при ее
использовании с директивами условной компиляции или в теле
макрокоманды с целью отладки.
<BR>К примеру, эту директиву можно
было бы вставить в ту ветвь программы (в последнем
рассмотренном нами макроопределении), которая выполняется,
если указанный в качестве аргумента регистр отличен от <B>al</B> и
<B>ah</B>:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
show	macro	rg
ifdifi	<al>,<rg>
goto	M_al
else
ifdifi	<ah>,<rg>
goto	M_ah
else
.Err
endif
endif
...
endm
</PRE>
</FONT></TT></TD>
</TR>
</TABLE> 

<P>Если после определенного таким образом макроопределения в
сегменте кода вызвать макрокоманду <VAR>show</VAR> с фактическим
параметром, отличным от имен регистров <B>ah</B> или <B>al</B>, будет
сгенерирована ошибка компиляции (с текстом <CITE>“User error”</CITE>), сам
процесс компиляции прекращен и, естественно, объектный модуль
создан не будет.
<P>Остальные директивы являются <EM>условными</EM>, так как их
поведение определяют некоторые условия.
   
<A NAME="УсловныеДирективы">
<H4>Условная генерация пользовательской ошибки</H4>
<P>Набор условий, на которые реагируют <EM>директивы условной
генерации пользовательской ошибки</EM>, такой же, как и у <EM>директив
условной компиляции</EM>. Поэтому и количество этих директив такое
же. К их числу относятся следующие директивы:
<UL>
<LI><A HREF="#ERRB"><EM>.ERRB (ERRIFB)</EM></A> и <A HREF="#ERRB"><EM>.ERRNB (ERRIFNB)</EM></A>
<LI><A HREF="#ERRDEF"><EM>.ERRDEF (ERRIFDEF)</EM></A> и <A HREF="#ERRDEF"><EM>.ERRNDEF (ERRIFNDEF)</EM></A>
<LI><A HREF="#ERRDIF"><EM>.ERRDIF (ERRIFDIF)</EM></A> и <A HREF="#ERRDIF"><EM>.ERRIDN (ERRIFIDN)</EM></A>
<LI><A HREF="#ERRE"><EM>.ERRE (ERRIFE) </EM></A> и <A HREF="#ERRE"><EM>.ERRNZ (ERRIF)</EM></A>
</UL>
<BR>Принцип их работы ясен, поэтому рассматривать их мы будем
очень кратко. Заметим только, что как и директивы условной
компиляции, использовать большинство директив условной
генерации пользовательской ошибки можно как в
макроопределениях, так и в любом месте программы.
   
<A NAME="ERRB">
<H4>Директивы .ERRB (ERRIFB) и .ERRNB (ERRIFNB)</H4>
<P>Синтаксис директив:
<P><B> .ERRB (ERRIFB) &lt;имя_формального_аргумента&gt;</B> — генерация
 пользовательской ошибки, если <EM><B>&lt;имя_формального_аргумента&gt;</B></EM>
 пропущено;
<P><B>  .ERRNB (ERRIFNB) &lt;имя_формального_аргумента&gt;</B> — генерация
 пользовательской ошибки, если <EM><B>&lt;имя_формального_аргумента&gt;</B></EM>
 присутствует.
<P>Данные директивы применяются для генерации ошибки
трансляции в зависимости от того, задан или нет при вызове
макрокоманды фактический аргумент, соответствующий формальному
аргументу в заголовке макроопределения с именем
<EM><B>&lt;имя_формального_аргумента&gt;</B></EM>.
<BR>По принципу действия эти
директивы полностью аналогичны соответствующим директивам
условной компиляции <B>IFB</B> и <B>IFNB</B>. Их обычно используют <CITE>для
проверки задания параметров при вызове макроса</CITE>.
<P>Строка <B>имя_формального_аргумента</B> должна быть заключена в
угловые скобки.
<P>К примеру, определим обязательность задания фактического
аргумента, соответствующего формальному аргументу <VAR>rg</VAR>, в
макросе <VAR>show</VAR>:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
<1>	show	macro	rg
<2>;если rg в макрокоманде не будет задан, 
<3>;то завершить компиляцию
<4>.errb	<rg>
<5>;текст макроопределения
<6>;...
<7>endm
</PRE>
</FONT></TT></TD>
</TR>
</TABLE> 

   
<A NAME="ERRDEF">
<H4>Директивы .ERRDEF (ERRIFDEF) и .ERRNDEF (ERRIFNDEF)</H4>
<P>Синтаксис директив:
<P><B>.ERRDEF (ERRIFDEF) символическое_имя</B> — если указанное имя
 определено до выдачи этой директивы в программе, то
 генерируется пользовательская ошибка.
<P><B>.ERRNDEF(ERRIFNDEF) символическое_имя</B> — если указанное
 символическое_имя не определено до момента обработки
 транслятором данной директивы, то генерируется
 пользовательская ошибка.
<P>Данные директивы генерируют ошибку трансляции в зависимости
от того, определено или нет некоторое символическое_имя в
программе.
<BR>Не забывайте о том, что компилятор TASM по
умолчанию формирует объектный модуль за один проход исходного
текста программы. Следовательно, директивы <EM><B>.ERRDEF (ERRIFDEF)</B></EM>
и <EM><B>.ERRNDEF (ERRIFNDEF)</B></EM> отслеживают факт определения
символического_имени только в той части исходного текста,
которая находится до этих директив.
   
<A NAME="ERRDIF">
<H4>Директивы .ERRDIF (ERRIFDIF) и .ERRIDN (ERRIFIDN)</H4>
<P>Синтаксис директив:
 <P><B>.ERRDIF (ERRIFDIF) &lt;строка_1&gt;,&lt;строка_2&gt;</B> — директива,
 генерирующая пользовательскую ошибку, если две строки
 посимвольно не совпадают. Строки могут быть символическими
 именами, числами или выражениями и должны быть заключены в
 угловые скобки. Аналогично директиве условной компиляции
 <B>IFDIF</B>, при сравнении учитывается различие прописных и строчных
 букв.
  <P><B>.ERRIDN (ERRIFIDN) &lt;строка_1&gt;,&lt;строка_2&gt;</B> — директива,
 генерирующая пользовательскую ошибку, если строки посимвольно
 идентичны. Строчное и прописное написание одной и той же
 буквы воспринимается как разные символы.
<P>Для того чтобы <EM>игнорировать различия строчных и прописных
букв</EM>, существуют аналогичные директивы:
 <P><B> ERRIFDIFI &lt;строка_1&gt;,&lt;строка_2&gt;</B> — то же, что и <EM><B>ERRIFDIF</B></EM>, но
 игнорируется различие строчных и прописных букв при сравнении
 &lt;строка_1&gt; и &lt;строка_2&gt;.
 <P><B> ERRIFIDNI &lt;строка_1&gt;,&lt;строка_2&gt;</B> — то же, что и ERRIFIDN, но
 игнорируется различие строчных и прописных букв при сравнении
 &lt;строка_1&gt; и &lt;строка_2&gt;.
<P>Данные директивы, как и соответствующие им директивы
условной компиляции, удобно применять для проверки
передаваемых в макрос фактических параметров.
   
<A NAME="ERRE">
<H4>Директивы .ERRE (ERRIFE) и .ERRNZ (ERRIF)</H4>
<P>Синтаксис директив:
  <P><B>.ERRE (ERRIFE) константное_выражение</B> — директива вызывает
 пользовательскую ошибку, если константное_выражение ложно
 (равно нулю). Вычисление константного_выражения должно
 приводить к абсолютному значению, и это выражение не может
 содержать компонентов, являющихся ссылками вперед.
  <P><B>.ERRNZ(ERRIF) константное_выражение</B> — директива вызывает
 пользовательскую ошибку, если константное_выражение истинно
 (не равно нулю). Вычисление константного_выражения должно
 приводить к абсолютному значению и не может содержать
 компонентов, являющихся ссылками вперед.
   
<H3>Константные выражения в условных директивах</H3>
<P>Как вы успели заметить, во многих условных директивах в
формировании условия участвуют <EM><B>выражения</B></EM>. Результат вычисления
этого выражения обязательно должен быть <B>константой</B>. Хотя его
компонентами могут быть и символические параметры, но их
сочетание в выражении должно давать абсолютный результат.
<BR>К примеру:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
.data
mas	db	...
len	dd	...
...
.code
...
.erre	(len-mas) lt 10	;генерация ошибки, если длина
			;области mas меньше 10 байт
...
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>Кроме того, <EM><B>выражение</B></EM> не должно содержать компоненты,
которые транслятор еще не обработал к тому месту программы,
где находится условная директива.
<BR>Также мы отметили, что
логические результаты <B>“истина”</B> и <B>“ложь”</B> являются условными в
том смысле, что ноль соответствует логическому результату
<B>“ложь”</B>, а любое ненулевое значение — <B>“истине”</B>.
<BR>Но в языке
ассемблера существуют операторы, которые позволяют
сформировать и “чисто логический” результат. Это так
называемые <EM>операторы отношений</EM>, выражающие отношение двух
значений или константных выражений. 
<BR>В контексте условных
директив вместе с операторами отношений можно рассматривать и
<EM>логические операторы</EM>. Результатом работы и тех, и других может
быть одно из двух значений:
<UL>
<LI><B>истина</B> — число, которое содержит двоичные единицы во всех
  разрядах;
<LI><B>ложь</B> — число, которое содержит двоичные нули во всех
разрядах.
</UL>
<P>Операторы, которые можно применять в выражениях условных
директив и которые формируют логические результаты, приведены
в табл. 1 и 2.
 <P><H5>Таблица 1. Операторы отношений</H5>
 <CENTER>
	<TABLE ALIGN=CENTER BGCOLOR="#E2E2E2" BORDER=3 RULES=ALL VALIGN=MIDDLE>
<TR ALIGN=CENTER><TD><B>Оператор</B>/</TD><TD><B>Синтаксис</B></TD><TD><B>Результат отношения</B></TD></TR>
<TR ALIGN=CENTER><TD>EQ (equal) — равно</TD><TD>выражение_1 EQ выражение_2</TD><TD>
истина — если выражение_1 равно выражение_2</TD></TR>
<TR ALIGN=CENTER><TD>NE (not equal) — не <BR> равно</TD><TD>Выражение_1 NE выражение_2</TD><TD>
Истина — если выражение_1 не равно выражение_2</TD></TR>
<TR ALIGN=CENTER><TD>LT (less than) — меньше</TD><TD>Выражение_1 LT выражение_2</TD><TD>
Истина — если выражение_1 меньше выражение_2</TD></TR>
<TR ALIGN=CENTER><TD>LE (less or equal) —  меньше или равно</TD><TD>Выражение_1 LE выражение_2</TD><TD>
Истина — если выражение_1 меньше или равно выражение_2</TD></TR>
<TR ALIGN=CENTER><TD>GT (greater than) — больше</TD><TD>Выражение_1 GT выражение_2</TD><TD>
Истина — если выражение_1 больше выражение_2</TD></TR>
<TR ALIGN=CENTER><TD>GE (greater or equal) —  больше или равно</TD><TD>Выражение_1 GE выражение_2</TD><TD>
Истина — если выражение_1 больше или равно выражение_2</TD></TR>
 </TABLE>	
	</CENTER>
 <P><H5>Таблица 2. Логические операторы</H5>
 <CENTER>
	<TABLE ALIGN=CENTER BGCOLOR="#E2E2E2" BORDER=3 RULES=ALL VALIGN=MIDDLE>
<TR ALIGN=CENTER><TD>Оператор</TD><TD>Синтаксис</TD><TD>Результат</TD></TR>
<TR ALIGN=CENTER><TD>NOT — логическое отрицание</TD><TD>NOT выражение</TD><TD>
Истина — если выражение ложно;
<BR>ложь — если выражение истинно</TD></TR>
<TR ALIGN=CENTER><TD>AND — логическое И</TD><TD>выражение_1 AND выражение_2</TD><TD>
Истина — если выражение_1 и выражение_2 истинны</TD></TR>
<TR ALIGN=CENTER><TD>OR — логическое ИЛИ</TD><TD>выражение_1 OR выражение_2</TD><TD>
Истина — если выражение_1 или выражение_2 истинны</TD></TR>
<TR ALIGN=CENTER><TD>XOR — исключающее ИЛИ</TD><TD>выражение_1 XOR выражение_2</TD><TD>
Истина — если выражение_1 = (NOT выражение_2)</TD></TR>
 </TABLE>	
	</CENTER>

<A NAME="display">
<H3>Дополнительное управление трансляцией</H3>
<P>TASM предоставляет средства для вывода текстового сообщения
во время трансляции программы — директивы <B>DISPLAY</B> и <B>%OUT</B>. С их
помощью можно, при необходимости, следить за ходом трансляции.
<BR>К примеру:
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD><TT><FONT COLOR="#000099">
<PRE>
display	недопустимые аргументы макрокоманды
...
%out	недопустимое имя регистра
</PRE>
</FONT></TT></TD>
</TR>
</TABLE>

<P>В результате обработки этих директив на экран будут
выведены тексты сообщений. Если эти директивы использовать
совместно с директивами условной компиляции, то, к примеру,
можно отслеживать путь, по которому осуществляется трансляция
исходного текста программы.

 <HR SIZE=5 WIDTH=80%>
 </BODY>
</HTML>	<!конец html-документа>