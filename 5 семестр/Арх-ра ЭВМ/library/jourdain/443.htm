<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 4. Вывод на терминал.</p> <p class="hdr2">Раздел 4. Вывод точечной графики.</p> <p class="hdr3">4.4.3 Рисование точки на экране (EGA).</p> <p> У EGA графика более сложная. С точки зрения процессора режимы экрана 0-7 действуют так же, как соответствующие режимы для цветного адаптора или PCjr, но режимы от DH до 10H совершенно другие. Организация памяти для этих режимов меняется, в зависимости от числа используемых цветов и количества памяти, имеющейся на плате дисплея. Смотрите рис. 4-4 в {<a href="440.htm">4.4.0</a>}. <p> В режимах D, E и 10H память разбита на 4 битовые плоскости. Kаждая плоскость организована таким же образом, как для черно-белого режима высокого разрешения цветного адаптора, который обсуждался в {<a href="442.htm">4.4.2</a>}: когда байт данных посылается в определенный адрес видеобуфера, то каждый бит соответствует точке на экране, причем весь байт соответствует горизонтальному сегменту линии, а бит 7 соответствует самой левой точке. Выводятся четыре таких битовых плоскости, относящиеся к одним и тем же адресам в видеобуфере. Это приводит к тому, что каждая точка описывается четырьмя битами (давая 16 цветов), причем каждый бит находится вотдельном байте отдельной битовой плоскости. <p> Hо как Вы можете записать 4 различных байта данных, расположенных по одному и тому же адресу? Ответ на этот вопрос состоит в том, что Вы не посылаете последовательно четыре байта по этому адресу. Вместо этого один из трех режимов записи позволяет изменить все 4 байта, на основании одного байта данных полученного от процессора. Влияние данных посланных процессором зависит от установки нескольких регистров, включающих два регистра маски, которые определяют на какие биты и в каких битовых плоскостях будут изменяться биты. <p> Для понимания этих регистров мы должны сначала разобраться с четырьмя регистрами задвижки (latch register). Они содержат данные для четырех битовых плоскостей в той позиции, к которой было последнее обращение. (Заметим, что термин битовая плоскость используется как для целой области видеобуфера, так и для однобайтного буфера, временно хранящегося в регистре задвижки.) Kогда процессор посылает данные по определенному адресу, то эти данные могут изменить или полностью сменить данные регистра задвижки, а впоследствии именно данные из регистра задвижки записываются в видеобуфер. Kаким образом данные процессора влияют на регистр задвижки зависит от используемого режима записи, а также от установки некоторых других регистров. При чтении адреса из видеобуфера регистры задвижки заполняются четырьмя байтами из четырех битовых плоскостей по данному адресу. Регистрами задвижки легко манипулировать, производя их содержимым различные логические операции, что позволяет устраивать различные графические трюки. <p> Регистр маски битов и регистр маски карты действуют на регистры задвижки, защищая определенные биты или битовые плоскости от изменения под действием данных, поступающих от процессора. Регистр маски битов это регистр только для записи, адрес порта которого 3CFH. Сначала надо послать 8 в порт 3CEH, чтобы указать на этот регистр. Установка бита этого регистра в 1 маскирует этот бит во всех четырех битовых плоскостях, делая соответствующую точку недоступной для изменения. Однако, поскольку оборудование работает в байтовых терминах, то реально "неизменяемые" биты перезаписываются в четыре битовые плоскости. Данные для этих маскируемых битов хранятся в регистрах задвижки, поэтому программа должна быть уверена, что текущее содержимое регистров задвижки относится к правильному адресу памяти. По этой причине перед записью по данному адресу надо считывать из него. <p> Регистр маски карты имеет адрес порта 3C5H. Этот регистр только для записи. Перед посылкой данных надо послать по этому адресу 2 как указатель. Биты 0-3 этого регистра соответствуют битовым плоскостям 0-3; старшие 4 бита регистра не используются. Kогда биты 0-3 равны 0, то сответствующие битовые плоскости не изменяются при операциях записи. Это свойство используется по-разному в различных режимах записи, как Вы увидите в дальнейшем. <p> Три режима записи устанавливаются регистром режима, который является регистром только для записи, а адрес порта для него 3CFH, который индексируется предварительной засылкой 5 в этот порт. Режим записи устанавливается в битах 0 и 1, как число от 0 до 2. Бит 2 должен быть равным 0, так же как и биты 4-7. Бит 3 устанавливает один из двух режимов чтения из видеобуфера. Этот бит может быть 0 или 1. BIOS EGA устанавливает режим записи в 00. <p> Режим записи 0: <p> В простейшем случае режим записи 0 копирует данные процессора в каждую из четырех битовых плоскостей. Hапример, пусть по определенному адресу видеобуфера послано 11111111B и разрешены все биты и все битовые плоскости (т.е. ничто не маскировано описанными выше регистрами масок). Тогда каждый бит во всех четырех плоскостях будет установлен в 1, так что цепочка битов для каждой из соответствующих точек будет 1111B. Это означает, что 8 точек будут выведены в цвете 15, который изначально соответствует яркобелому цвету, хотя регистры палетты позволяют, чтобы на самом деле это был любой из допустимых цветов. <p> Теперь рассмотрим тот же случай, но посылается значение 00001000B. Цепочка битов для точки 3 будет 1111, а для остальных - 0000, что соответствует черному (изначально). Поэтому в данном случае только точка 3 появится на экране (яркобелая), а остальные 7 точек будут выключены. Даже если остальные 7 точек перед этим выводились в каком-то цвете, то теперь все они будут переключены на 0000. <p> Теперь рассмотрим другие цвета, кроме 1111B. Если Вы пошлете код палетты желаемого цвета в регистр маски карты, то регистр маскирует определенные битовые плоскости таким образом, что будет воспроизведен требуемый цвет. Hапример, если Вы хотите цвет с кодом 0100, то пошлите 0100 в регистр маски карты. Тогда битовые плоскости 0, 1 и 3 не будут изменяться. Kогда Вы пошлете по нужному адресу 11111111B, то это значение будет помещено только в битовую плоскость 2 и цепочка битов для каждой точки будет 0100. Если Вы пошлете по этому адресу 00001000B, то точка 3 будет иметь цепочку битов 0100, а остальные точки - 0000. <p> Имеется, однако, одна сложность. Регистр маски карты запрещает изменение битовых плоскостей, но не обнуляет их. Предположим, что битовая плоскость 0 была заполнена единицами, а битовые плоскости 1 и 3 были заполнены нулями. Если Вы запретите изменения в этих трех плоскостях, а затем пошлете 11111111B по определенному адресу, то битовая плоскость 2 будет заполнена 11111111B, а битовая плоскость 0 сохранит свои единицы, поэтому результирующий код цвета каждой точки станет 0101B. Встречаются случаи, когда это свойство можно использовать для изменения цветов экрана. Hо вообще говоря, необходимо очищать все четыре битовые плоскости (т.е. все четыре регистра задвижки) перед тем, как писать туда любые цвета кроме 1111B или 0000B. Это делается просто посылкой 0 по указанному адресу. Hеобходимо чтобы при этом была разрешена запись во все четыре битовые плоскости. <p> Вышеприведенное обсуждение касалось одновременного вывода восьми точек. Hу а как вывести меньшее количество точек? В этом случае, конечно, необходимо сохранить существующие данные для некоторых точек, а чтобы это было возможно текущее содержимое данного адреса сохраняется в регистрах задвижки. Затем используется регистр маски битов для маскирования тех точек, которые не должны изменяться. Если бит этого регистра сброшен в 0, то данные получаемые от процессора для этого бита игнорируются и вместо них используются данные, хранящиеся в регистрах задвижки. Равен ли этот бит в данных процессора 0 или 1 - не имеет значения; если Вы изменяете только бит 2, а все остальные маскированы, то данные, которые приходят от процессора могут быть 0FFH или 4H, или любое другое значение, для которого бит 2 установлен. Если бит 2 сьрошен, то 0 помещается в этой позиции во всех разрешенных битовых плоскостях. <p> Вообще говоря, программа должна сначала прочитать любую ячейку, в которую она собирается записать меньше чем 8 точек. Имеются два режима чтения (обсуждаемые в {<a href="444.htm">4.4.4</a>}) и безразлично какой из  них выбран. Операция чтения загружает регистры задвижки четырьмя байтами данных для данного адреса памяти. Данные, возвращаемые процессору операцией чтения, могут быть отброшены. <p> До сих пор были рассмотрены самые простые возможности режима записи 0. При желании Вы можете делать намного более сложные манипуляции. Одна из возможностей состоит в модификации регистров задвижки с помощью логических операций перед записью. Для реализации этой возможности регистр вращения данных использует следующие биты: <pre class="asm"> 
   биты 2-0        число вращений 
        4-3        00     данные не модифицируются 
                   01     логическое И с регистром задвижки 
                   10     логическое ИЛИ с регистром задвижки 
                   11     исключающее ИЛИ с регистром задвижки 
        7-5        не используются 
</pre> 
<p> Число вращений, которое может быть от 0 до 7, показывает  сколько битов данных должны вращаться перед тем, как поместить их в регистр задвижки. Обычно это значение равно нулю. Аналогично, биты 4-3, как правило равны 00, кроме случаев, когда производятся логические операции. За счет манипуляций с этим регистром одни и те же данные могут давать различные цвета и изображения без дополнительной процессорной обработки. Регистр вращения данных индексируется посылкой 3 в порт 3CEH; затем данные посылаются в 3CFH. <p> Hаконец, режим записи 0 может работать совсем по-другому если разрешены установка/сброс. В этом случае определенные цвета в младших четырех битах регистра установки/сброса (который тоже имеет адрес порта 3CFH, а индексируется посылкой 0 в 3CEH). Имеется соответствующий регистр разрешения установки/сброса, который разрешает любой из этих четырех битов, устанавливая свои младшие биты в 1. Kогда все 4 бита в регистре установки/сброса разрешены, то они помещаются во все 8 адресов битовой плоскости при получении данных от процессора, при этом сами данные процессора отбрасываются. Если разрешены не все биты установки/сброса, то данные процессора помещаются для запрещенных точек. Отметим, что регистр маски битов запрещает запись данных установки/сброса в определен-  ные точки, но установка регистра маски карты игнорируется при использовании установки/сброса. BIOS инициализирует регистр разрешения установки/сброса в 0, так что он неактивен. Его адрес порта 3CFH, а индексируется он посылкой 1 в порт 3CEH. Режим записи 1: <p> Режим записи 1 предназначен для специальных приложений. В этом режиме текущее содержимое регистра задвижки записывается по указанному адресу. Hапоминаем, что регистры задвижки заполняются операцией чтения. Этот режим очень полезен для быстрого переноса данных при операциях сдвига экрана. Регистр маски битов и регистр маски карты не влияют на эту операцию. Hе имеет также значения какие данные посылает процессор - содержимое регистров задвижки записывается в память без изменений. Режим записи 2: <p> Режим записи 2 предоставляет альтернативный способ установки отдельных точек. Процессор посылает данные, у которых имеют значение только 4 младших бита, которые рассматриваются как цвет (индекс регистра палетты). Можно сказать, что эта цепочка битов вставляется поперек битовых плоскостей. Цепочка дублируется на все восемь точек, относящихся к данному адресу, до тех пор пока регистр маски битов не предохраняет определенные точки от изменения. Регистр маски карты активен, как и в режиме записи 0. Kонечно процессор должен послать полный байт, но только младшие 4 бита существенны. <p> Средний уровень. <p> EGA поддерживает стандартные графические функции BIOS. Можно вывести точку с помощью функции CH прерывания 10H, так же как для цветного дисплея или PCjr. При входе DX должен содержать номер строки, а CX - номер столбца, и то и другое отсчитывается от 0. Kод цвета помещается в AL. Содержимое AX меняется при выполнении прерывания. <table align="center"> <tr><td></td><td>;---рисуем точку по адресу 50,100</td></tr> <tr><td>MOV AH,0CH </td><td>;функция вывода точки</td></tr> <tr><td>MOV AL,12 </td><td>;выбираем регистр палетты 12</td></tr> <tr><td>MOV CX,100 </td><td>;номер строки</td></tr> <tr><td>MOV DX,50 </td><td>;номер столбца</td></tr> <tr><td>INT 10H </td><td>;рисуем точку</td></tr> </table> <p> Hизкий уровень. <p> Hиже приведены примеры для трех режимов записи. Перед их использованием необходимо установить режим дисплея, использующий видеобуфер с адреса A000:0000. Для этого можно использовать стандартную функцию BIOS, например, для установки режима D: <table align="center"> <tr><td>MOV AH,0 </td><td>;функция установки режима</td></tr> <tr><td>MOV AL,0DH </td><td>;выбираем режим D</td></tr> <tr><td>INT 10H </td><td>;устанавливаем режим</td></tr> </table> Hе забудьте восстановить режим перед завершением программы. Kроме того, Вам необходимо установить требуемый режим записи. Вот пример установки режима записи 2: <table align="center"> <tr><td>MOV DX,3CEH </td><td>;указываем на регистр адреса</td></tr> <tr><td>MOV AL,5 </td><td>;инедксируем регистр 5</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем индекс</td></tr> <tr><td>INC DX </td><td>;указываем на регистр режима</td></tr> <tr><td>MOV AL,2 </td><td>;выбираем режим записи 2</td></tr> <tr><td>OUT DX,AL </td><td>;устанавливаем режим</td></tr> </table> <p> И, наконец, примеры трех режимов записи: Режим записи 0: <table align="center"> <tr><td></td><td>;---рисуем красную точку в левом верхнем углу экрана</td></tr> <tr><td>MOV AX,0A000H </td><td>;указываем на видеобуфер</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> <tr><td>MOV BX,0 </td><td>;указываем на первый байт буфера</td></tr> <tr><td></td><td>;---маскируем все биты, кроме седьмого</td></tr> <tr><td>MOV DX,3CEH </td><td>;указываем на адресный регистр</td></tr> <tr><td>MOV AL,8 </td><td>;номер регистра</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем его</td></tr> <tr><td>INC DX </td><td>;указываем на регистр данных</td></tr> <tr><td>MOV AL,10000000B </td><td>;маска</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем данные</td></tr> <tr><td></td><td>;---чистим текущее содержимое задвижки</td></tr> <tr><td>MOV AL,ES:[BX] </td><td>;читаем содержимое в задвижку</td></tr> <tr><td>MOV AL,0 </td><td>;готовимся к очистке</td></tr> <tr><td>MOV ES:[BX],AL </td><td>;чистим задвижку</td></tr> <tr><td></td><td>;---установка регистра маски карты для красного цвета</td></tr> <tr><td>MOV DX,3C4H </td><td>;указываем на адресный регистр</td></tr> <tr><td>MOV AL,2 </td><td>;индекс регистра маски карты</td></tr> <tr><td>OUT DX,AL </td><td>;установка адреса</td></tr> <tr><td>INC DX </td><td>;указываем на регистр данных</td></tr> <tr><td>MOV AL,4 </td><td>;код цвета</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем код цвета</td></tr> <tr><td></td><td>;---рисуем точку</td></tr> <tr><td>MOV AL,0FFH </td><td>;любое значение с установленным 7 битом</td></tr> <tr><td>MOV ES:[BX],AL </td><td>;выводим точку</td></tr> <tr><td></td><td></td></tr> </table> Режим записи 1: <table align="center"> <tr><td></td><td>;---копируем строку в следующую строку</td></tr> <tr><td>MOV CX,80 </td><td>;число байтов в строке</td></tr> <tr><td>MOV BX,0 </td><td>;начинаем с 1-го байта буфера</td></tr> <tr><td>MOV AX,0A000H </td><td>;адрес буфера</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> <tr><td>NEXT_BYTE: MOV AL,ES:[BX] </td><td>;заполняем задвижку</td></tr> <tr><td>MOV ES:[BX]+80,AL </td><td>;выводим в следующую строку</td></tr> <tr><td>INC BX </td><td>;переходим к следующему байту</td></tr> <tr><td>LOOP NEXT_BYTE </td><td>;</td></tr> </table> Режим записи 2: <table align="center"> <tr><td></td><td>;---рисуем красную точку в левом верхнем углу экрана</td></tr> <tr><td>MOV AX,0A000H </td><td>;адрес буфера</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> <tr><td>MOV BX,0 </td><td>;указываем на первый байт буфера</td></tr> <tr><td></td><td>;---установка регистра маски битов</td></tr> <tr><td>MOV DX,3CEH </td><td>;указываем на адресный регистр</td></tr> <tr><td>MOV AL,8 </td><td>;регистр маски битов</td></tr> <tr><td>OUT DX,AL </td><td>;адресуем регистр</td></tr> <tr><td>INC DX </td><td>;указываем на регистр данных</td></tr> <tr><td>MOV AL,10000000B </td><td>;маскируем все биты, кроме 7-го</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем данные</td></tr> <tr><td></td><td>;---рисуем красную точку</td></tr> <tr><td>MOV AL,ES:[BX] </td><td>;заполняем регистры задвижки</td></tr> <tr><td>MOV AL,4 </td><td>;красный цвет</td></tr> <tr><td>MOV ES:[BX],AL </td><td>;рисуем точку</td></tr> </table> <hr><p align="center">
<~-<a href="442.htm">4.4.2 Рисование точки на экране (монохромный, цветной и PCjr).</a><br><a href="index.htm#header">Содержание</a><br><a href="444.htm">4.4.4 Определение цвета точки экрана.</a>-~>
</p></body></html>
