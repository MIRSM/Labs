<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 1. Системные ресурсы.</p> <p class="hdr2">Раздел 2. Управление прерываниями.</p> <p class="hdr3">1.2.4 Дополнение к существующему прерыванию.</p> <p> Хотя и не часто, но иногда бывает полезно добавить код к существующему прерыванию. В качестве примера рассмотрим программы, которые преобразуют одно нажатие клавиши в длинные определяемые пользователем символьные строки (макроопределения клавиатуры). Эти программы используют факт, что весь ввод с клавиатуры поступает поступает через функцию 0 прерывания 16H BIOS {<a href="313.htm">3.1.3</a>}. Все прерывания ввода с клавиатуры DOS вызывают прерывание BIOS для получения символа из буфера клавиатуры. Поэтому необходимо модифицировать лишь прерывание 16H, таким образом, чтобы оно служило шлагбаумом для макроопределений, после чего любая программа будет получать макроопределения, независимо от того, какое прерывание ввода с клавиатуры она использует. <p> Kонечно, модифицировать прерывания BIOS и DOS непросто, поскольку BIOS расположена в ПЗУ, а DOS поступает без листинга и они ограничены размерами отведенной для них памяти. Hо Вы можете написать процедуру, которая предшествует и/или следует за соответствующим прерыванием, и эта процедура может вызываться при вызове прерывания DOS или BIOS. Hапример, в случае прерывания 16H, Вам нужно написать процедуру и указать на нее вектором прерывания для 16H. Оригинальное значение вектора 16H тем временем переносится в какой-либо неиспользуемый вектор, скажем, 60H. Hовая процедура просто вызывает прерывание 60H, чтобы использовать оригинальное прерывание 16H; поэтому когда программа вызывает прерывание 16H, управление передается Вашей процедуре, которая затем вызывает оригинальное прерывание 16H, которая по завершении опять возвращает управление Вашей процедуре, а из нее уже Вы возвращаетесь в то место программы, из которого был вызов прерывания 16H. После того как это сделано, в новой процедуре может содержаться любой код, как до, так и после вызова прерывания 60H. Hа рис. 1-3 показана диаграмма этой процедуры. Вот краткая сводка необходимых действий: <OL class="a"> <LI> 1. Создать новую процедуру, вызывающую прерывание 60H. <LI> 2. Перенести вектор прерывания для 16H в 60H. <LI> 3. Изменить вектор 16H, чтобы он указывал на новую процедуру. <LI> 4. Завершить программу, оставляя ее резидентной {<a href="134.htm">1.3.4</a>}. </OL> <hr><p align="center">
<~-<a href="123.htm">1.2.3 Hаписание собственного прерывания.</a><br><a href="index.htm#header">Содержание</a><br><a href="130.htm">Раздел 3. Управление программами.</a>-~>
</p></body></html>
