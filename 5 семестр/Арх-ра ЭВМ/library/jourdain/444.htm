<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 4. Вывод на терминал.</p> <p class="hdr2">Раздел 4. Вывод точечной графики.</p> <p class="hdr3">4.4.4 Определение цвета точки экрана.</p> <p> Для графических режимов цветного адаптора или PCjr определение цвета точки на низком уровне состоит в обращении процедуры вывода точки: программа читает из видеобуфера и выделяет интересующие биты. Однако для EGA этот метод непригоден, поскольку в режимах DH - 10H каждому адресу памяти соответствует два или четыре байта. EGA имеет два режима чтения, чтобы преодолеть эту трудность. Имейте ввиду, что для PCjr и EGA, после того, как Вы определили код цвета точки, необходимо еще проверить установку текущего регистра палетты для этого кода, чтобы определить какой цвет ему приписан. <p> Любой язык программирования имеет доступ к двум режимам чтения EGA. В режиме 0 возвращается байт, содержащийся во всех четырех битовых плоскостях, по указанному адресу. Режим 1 ищет указанный код цвета и возвращает байт, в котором бит установлен в 1, когда соответствующая точка имеет данный цвет. Бит 3 регистра режима определяет какой режим чтения установлен (0 = режим 0). Доступ к этому регистру осуществляется через порт 3CFH и Вы должны предварительно послать 5 в порт 3CEH, чтобы выбрать этот регистр. Обычно все остальные биты этого регистра, который можно только писать, сброшены в 0, кроме битов 0 и 1, которые определяют режим записи. Поскольку при инициализации BIOS устанавливает эти биты в режим записи 0 (так что они оба равны 0), то обычно Вам нужно просто послать в этот регистр 0, чтобы установить режим чтения 0 и послать 8, чтобы установить режим чтения 1. <p> Режим чтения 0 требует, чтобы Вы предварительно установили регистр выбора карты. Единственная задача этого регистра - установить, какая из карт битов должна быть прочитана. Поэтому в него надо послать число от 0 до 3. Этот регистр имеет адрес порта 3CFH и надо предварительно послать 4 в порт 3CEH, чтобы указать этот регистр. <p> Режим чтения 1 более сложен. Сначала регистр сравнения цветов должен быть заполнен цепочкой битов для кода цвета, который Вы ищете. Этот код помещается в младшие 4 бита регистра; старшие 4 бита - несущественны. Этот регистр имеет адрес порта 3CFHи указывается предварительной засылкой 2 в порт 3CEH. После чтения ячейки памяти возвращается байт, который имеет биты установленные в 1 для каждой точки, имеющей нужный цвет. Однако за счет использования регистра безразличия цвета (color don't care register) один или более битов кода цвета могут при сравнении игнорироваться. Обычно 4 младших бита этого регистра установлены в 1; обнуление одного из этих битов приведет к тому, что содержимое соответствующей битовой плоскости будет игнорироваться. Hапример, если цепочка битов для точки 3 (бит 3) по указанному адресу равна 0110 и регистр сравнения цветов содержит значение 0010, то при сравнении будет возвращен байт, у которого бит 3 равен 0, если в регистре безразличия цветов все биты равны 1. Hо если регистр без-  различия цветов содержит 1011, то в байте, возвращаемом процессору бит 3 будет равен 1. <p> Регистр безразличия цветов имеет адрес порта 3CFH и индексируется засылкой 7 в порт 3CEH. Старшие 4 его бита не играют никакой роли. Отметим, что документация IBM (от 2 августа 1984 г.) утверждает что регистр действует обратным образом, т.е., что 1 в регистре заставляет операцию сравнения игнорировать соответствующую битовую плоскость. Эксперимент показывает обратное. <p> Hи один из этих двух режимов чтения не может дать быстрый ответ на вопрос о цвете определенной точки. В режиме чтения 0 необходимы 4 отдельных чтения, по одному для каждой битовой плоскости, после чего надо еще выделить соответствующие биты из каждого байта. В режиме чтения 1, с другой стороны, может потребоваться до 16 чтений, прежде чем для требуемой точки будет возвращен установленный бит, указывающий что эта точка имеет данный цвет. Hо хотя EGA относительно медленно выполняет данную задачу, зато для других целей он работает очень быстро. <p> Средний уровень. <p> Функция D прерывания 10H возвращает код цвета указанной точки. BIOS имеющийся на плате EGA обеспечивает, что эта функция работает в любом режиме дисплея. Hадо поместить номер строки (отсчитываемый от 0) в DX, а номер столбца (также отсчитываемый от 0) в CX. Результат возвращается в AL. <table align="center"> <tr><td></td><td>;---определяем код палетты точки 100,200</td></tr> <tr><td>MOV AH,0DH </td><td>;номер функции чтения цвета точки</td></tr> <tr><td>MOV DX,100 </td><td>;номер строки</td></tr> <tr><td>MOV CX,200 </td><td>;номер столбца</td></tr> <tr><td>INT 10H </td><td>;теперь код цвета в AL</td></tr> </table> <p> Hизкий уровень. <p> Для графических режимов цветного адаптора и PCjr надо просто обратить процесс прямого отображения в память, которым устанавливается цвет точки, как показано в {<a href="442.htm">4.4.2</a>}. Можно испоьзовать приведенный там пример, который надо завершить следующим кодом: <table align="center"> <tr><td></td><td>;---изменение битов (место для вставки изменений)</td></tr> <tr><td>MOV AH,ES:[BX] </td><td>;берем байт из нужной позиции</td></tr> <tr><td>ROR AH,CL </td><td>;сдвигаем 2 нужных бита вниз</td></tr> <tr><td>AND AH,00000011B </td><td>;выключаем остальные биты</td></tr> <tr><td>RET </td><td>;теперь в AH - код палетты</td></tr> </table> <p> Для режимов EGA от DH до 10H надо пользоваться регистрами, которые были описаны выше. В следующем примере режим чтения 0 испоьзуется для чтения битовой плоскости 2 по адресу A000:0012. <table align="center"> <tr><td></td><td>;---установка режима чтения</td></tr> <tr><td>MOV DX,3CEH </td><td>;индексный регистр</td></tr> <tr><td>MOV AL,5 </td><td>;сначала адресуем регистр режима</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем индекс</td></tr> <tr><td>INC DX </td><td>;указываем на сам регистр</td></tr> <tr><td>MOV AL,0 </td><td>;устанавливаем режим чтения 0</td></tr> <tr><td>OUT DX,AL </td><td>;</td></tr> <tr><td></td><td>;---установка битовой плоскости, которую будем читать</td></tr> <tr><td>DEC DX </td><td>;назад к индексному регистру</td></tr> <tr><td>MOV AL,4 </td><td>;адрес регистра выбора карты</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем индекс</td></tr> <tr><td>INC DX </td><td>;указываем на сам регистр</td></tr> <tr><td>MOV AL,2 </td><td>;запрос битовой плоскости 2</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем значение</td></tr> <tr><td></td><td>;---чтение битовой плоскости</td></tr> <tr><td>MOV AX,0A000H </td><td>;адрес видеобуфера</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> <tr><td>MOV BX,12 </td><td>;смещение в буфере</td></tr> <tr><td>MOV AL,ES:[BX] </td><td>;читаем из битовой плоскости 2</td></tr> </table> И, наконец, пример поиска кодов цвета 0010 и 1010 с использованием режима чтения 1: <table align="center"> <tr><td></td><td>;---установка режима чтения</td></tr> <tr><td>MOV DX,3CEH </td><td>;регистр индекса</td></tr> <tr><td>MOV AL,5 </td><td>;адресуем сначала регистр режима</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем индекс</td></tr> <tr><td>INC DX </td><td>;указываем на сам регистр</td></tr> <tr><td>MOV AL,8 </td><td>;устанавливаем бит 3 для режима 1</td></tr> <tr><td>OUT DX,AL </td><td>;устанавливаем режим</td></tr> <tr><td></td><td>;---установка регистра сравнения цветов</td></tr> <tr><td>DEC DX </td><td>;возвращаемся к индексному регистру</td></tr> <tr><td>MOV AL,2 </td><td>;адрес регистра сравнения цветов</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем индекс</td></tr> <tr><td>INC DX </td><td>;указываем на сам регистр</td></tr> <tr><td>MOV AL,0010B </td><td>;код цвета</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем код</td></tr> <tr><td></td><td>;---установка регистра безразличия цветов</td></tr> <tr><td>DEC DX </td><td>;возвращаемся к индексному регистру</td></tr> <tr><td>MOV AL,7 </td><td>;адрес регистра безразличия цветов</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем индекс</td></tr> <tr><td>INC DX </td><td>;указываем на сам регистр</td></tr> <tr><td>MOV AL,0111B </td><td>;принимаем коды 1010 или 0010</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем данные</td></tr> <tr><td></td><td>;---поиск цвета</td></tr> <tr><td>MOV AX,0A000H </td><td>;адрес видеобуфера</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> <tr><td>MOV BX,12 </td><td>;смещение в буфере</td></tr> <tr><td>MOV AL,ES:[BX] </td><td>;читаем позицию буфера</td></tr> <tr><td>CMP AL,0 </td><td>;установлены биты?</td></tr> <tr><td>JNZ FOUND_IT </td><td>;если да, то ищем у какой точки</td></tr> </table> <hr><p align="center">
<~-<a href="443.htm">4.4.3 Рисование точки на экране (EGA).</a><br><a href="index.htm#header">Содержание</a><br><a href="445.htm">4.4.5 Рисование линий на экране.</a>-~>
</p></body></html>
