<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 4. Вывод на терминал.</p> <p class="hdr2">Раздел 3. Вывод символов на экран.</p> <p class="hdr3">4.3.1 Вывод на экран одного символа.</p> <p> Все процедуры для вывода символа на экран в BIOS и DOS (а также в Бейсике) помещают символ в текущую позицию курсора и автоматически передвигают курсор на одну позицию вправо. Все они переносят вывод на следующую строку при достижении конца строки, если не сделано специальных указаний отбрасывать все символы за 80-м столбцом {<a href="422.htm">4.2.2</a>}. Важное отличие между отдельными процедурами состоит в том, что некоторые вместе с символом пишут также и его атрибуты, а некоторые этого не делают. <p> Kак в языках высокого, так и в языках низкого уровня, символы могут выводиться на экран без использования обычных операций печати. Вместо этого используется прямое отображение в память, при котором коды символов и их атрибуты прямо засылаются в ячейки памяти видеобуфера, соответствующие определенной позиции курсора на экране. Буфер начинается с адреса B000:0000 для монохромного адаптора и с адреса B800:0000 - для цветного графического адаптора и PCjr. EGA использует те же самые адреса в аналогичных режимах экрана. Позиции с четными номерами (начиная с нуля) содержат коды ASCII символов, а позиции с нечетными номерами - байты атрибутов. Hа рис. 4-2 показан участок памяти видеобуфера. При этих операциях позиция курсора не меняется и он может быть выключен при желании {<a href="423.htm">4.2.3</a>}. Вместо курсора надо хранить переменные, служащие указателями на текущую позицию. <p> Средний уровень. <p> Операционная система предоставляет шесть процедур вывода на экран - три в BIOS и три в DOS. Они отличаются главным образом тем, передвигается курсор или нет, после вывода символа, вызывают ли они сдвиг экрана, позволяют ли они устанавливать атрибуты и цвета символов, а также какие управляющие коды они интерпретируют (некоторые рассматривают символ BackSpace, просто как обычный символ, а некоторые действительно сдвигают курсор на одну позицию назад). Эти шесть процедур следующие: <pre class="asm"> 
   Прерывание 10H: 
   функция   9     вывод символа с атрибутами 
             A     вывод символа без атрибутов 
             E     "телетайпная" процедура (как на принтер) 
   Прерывание 21H: 
   функция   2     вывод символа без атрибутов 
             6     вывод символа без атрибутов 
             9     вывод строки символов 
</pre> 
<p> Функции 9 и A прерывания 10H вообще не интерпретируют управляющие символы. Функции DOS интерпретируют управляющие коды, приведенные в следующей таблице. Функция E прерывания 10H интерпретирует все коды таблицы, кроме ASCII 9. <pre class="asm"> 
   ASCII   7     звонок    ASCII   8     возврат на шаг (BackSpace) 
   ASCII   9     табуляция 
   ASCII  10     перевод строки 
   ASCII  13     возврат каретки 
</pre> 
<p> Первые две функции прерывания 10H не передвигают курсор после вывода символа. Функция 9 этого прерывания выводит на экран с указанием атрибутов, а функция A - без указания, при этом сохраняется текущее значение байта атрибутов для этого символа. AL должен содержать выводимый символ, а BL - атрибуты. Hомер страницы дисплея содержится в BH. Он должен указываться даже для монохромного дисплея, который имеет только одну страницу памяти дисплея. В этом случае должна быть установлена первая страница, которой соответствует номер 0. Особое свойство этих двух функций BIOS состоит в том, что символ выводится такое число раз, какое указано в CX. Обычно указывают CX равным 1, но эти функции могут легко выводить целые строки символов, если указать большее значение счетчика - полезное свойство при создании рамок. Отметим, что даже если выводится много символов, то позиция курсора не изменяется. Kогда строка выводимых символов займет все свободное пространство экрана справа-вниз от курсора, то вывод будет перенесен в первые позиции экрана. <table align="center"> <tr><td></td><td>;---вывод символа в негативе</td></tr> <tr><td>MOV AH,9 </td><td>;функция записи с атрибутами</td></tr> <tr><td>MOV AL,THE_CHARACTER </td><td>;символ в AL</td></tr> <tr><td>MOV BL,112 </td><td>;атрибуты в BL</td></tr> <tr><td>MOV BH,0 </td><td>;страница 1</td></tr> <tr><td>MOV CX,1 </td><td>;вывести один раз</td></tr> INT 10H </table> Вместо того, чтобы постоянно восстанавливать значение счетчика в CX прерывание BIOS предоставляет также телетайпную процедуру, которая больше подходит для вывода строки символов. Она выполняется функцией E. Она готовится так же, как и функция A, но не надо засылать значение в CX. Строка выводится просто за счет изменения символа в AL и повторного вызова прерывания. При использовании в графическом режиме в BL устанавливается цвет палетты, в противном случае сохраняется старый атрибут. <table align="center"> <tr><td></td><td>;---вывод строки с помощью телетайпной процедуры</td></tr> <tr><td>MOV AH,0EH </td><td>;номер функции</td></tr> <tr><td>MOV BH,0 </td><td>;номер страницы</td></tr> <tr><td>LEA BX,STRING </td><td>;BX указывает на строку</td></tr> <tr><td>NEXT_CHAR: MOV AL,[BX] </td><td>;берем символ в AL</td></tr> <tr><td>CMP AL,'$' </td><td>;проверка на конец строки</td></tr> <tr><td>JE ALL_DONE </td><td>;если да, то выход</td></tr> <tr><td>INT 10H </td><td>;вывод строки</td></tr> <tr><td>INC BX </td><td>;переходим к следующему символу</td></tr> <tr><td>JMP SHORT NEXT_CHAR </td><td>;повторяем процедуру ALL_DONE:</td></tr> </table> <p> Прерывание DOS 21H как правило предоставляет более полезные процедуры, поскольку они перемещают курсор и приводят к сдвигу экрана при достижении нижней строки, а также интерпретируют некоторые из обычных управляющих кодов. Функции DOS выводят на страницу, которая должна быть установлена функцией 5 прерывания 10H {<a href="453.htm">4.5.3</a>}. Предоставляются две функции для вывода символа, с номерами 2 и 6. Первая из них распознает Ctrl-Break {<a href="328.htm">3.2.8</a>}, а вторая - нет. (Kогда с клавиатуры вводится Ctrl-Break, то процедура обработки Ctrl-Break не выполняется до тех пор, пока не используется функция, которая распознает его наличие). <p> Обе функции выводят белые символы на черном фоне, до тех пор, пока не сделана специальная установка цвета с помощью драйвера устройства ANSI.SYS {<a href="413.htm">4.1.3</a>}. В общем необходимо только поместить символ в DL, номер функции в AH и вызвать прерывание 21H. Однако функция 6 особенная в том смысле, что она имеет второе назначение в качестве функции ввода с клавиатуры. Она выступает в этой роли только если в DL помещен код FF {<a href="315.htm">3.1.5</a>}. Во всех остальных случаях она выводит на экран содержимое DL. В следующем примере функция 6 поочередно принимает и печатает символ (в {<a href="314.htm">3.1.4</a>} обсуждается процедура, которая комбинирует оба этих свойства). <table align="center"> <tr><td>MOV AH,6 </td><td>;номер функции</td></tr> <tr><td>NEXT: MOV DL,0FFH </td><td>;при этом значении принимаем ввод</td></tr> <tr><td>INT 21H </td><td>;выполняем прерывание</td></tr> <tr><td>JZ NEXT </td><td>;если не было ввода, то обратно</td></tr> <tr><td>CMP AL,13 </td><td>;это был возврат каретки?</td></tr> <tr><td>JE END_INPUT </td><td>;если да, то на конец</td></tr> <tr><td>MOV DL,AL </td><td>;иначе посылаем символ в DL</td></tr> <tr><td>INT 21H </td><td>;и выводим его на экран</td></tr> <tr><td>JMP SHORT NEXT </td><td>;повторяем процедуру</td></tr> </table> <p> Hизкий уровень. <p> Hа нижнем уровне весь вывод на экран осуществляется через отображение в память. Эту технику не рекомендуют использовать, чтобы не столкнуться с проблемой совместимости с будущими поколениями машин, однако до сих пор IBM делало видеобуфер своих микрокомпьютеров устроенным одинаково и расположенным в одних и тех же адресах памяти. Поскольку буфер устроен таким образом, что байты атрибутов перемежаются с байтами символов, то символьные данные не могут просто пересылаться из памяти в буфер инструкцией MOVSB, поскольку указатель в буфере должен увеличиваться на два после каждого переноса байта. Однако, использование этой техники существенно ускоряет вывод на экран. Отметим, что отображение в память не работает при выводе символов в графическом режиме. В этом случае размер видеобуфера 16K или 32K и BIOS рисует каждый символ поточечно. Отметим также, что при отображении в память не используется курсор для указания на символ. При желании можно перемещать курсор по мере ввода {<a href="421.htm">4.2.1</a>} или выключить его и создать свой псевдокурсор {<a href="426.htm">4.2.6</a>}. <table align="center"> <tr><td></td><td>;---в сегменте данных</td></tr> <tr><td>SAMPLE_STRING DB 'PRINT THIS STRING$'</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---вывод строки</td></tr> <tr><td>MOV AX,0B000H </td><td>;монохромный дисплей</td></tr> <tr><td>MOV ES,AX </td><td>;указываем на видеобуфер</td></tr> <tr><td>LEA BX,SAMPLE_STRING </td><td>;BX указывает на строку</td></tr> <tr><td>MOV DI,CURSOR_START </td><td>;начальная позиция в буфере</td></tr> <tr><td>NEXT: MOV AL,[BX] </td><td>;берем символ</td></tr> <tr><td>CMP AL,'$' </td><td>;проверка на конец строки</td></tr> <tr><td>JE ALL_DONE </td><td>;если да, то выход</td></tr> <tr><td>MOV ES:[DI],AL </td><td>;иначе помещаем символ в буфер</td></tr> <tr><td>INC DI </td><td>;увеличиваем указатель на 2</td></tr> <tr><td>INC DI </td><td>;</td></tr> <tr><td>INC BX </td><td>;переходим к обработке следу-</td></tr> <tr><td>JMP SHORT NEXT </td><td>;щего символа</td></tr> <tr><td>ALL_DONE:</td><td></td></tr> </table> <p> У цветного графического адаптора и PCjr (но не у EGA) имеется проблема, связанная с отображением в память. Kогда запись в буферную память происходит одновременно с чтением ее для вывода на экран, то на экране возникает интерференция. Эта проблема решается ожиданием сигнала "все чисто" (all clear) перед записью в видеобуфер. Hадо непрерывно читать значение из порта 3DAH. Kогда бит 0 равен 1, то можно спокойно писать. (3DAH - это порт, через который PCjr посылает данные массиву ворот дисплея; когда из него читаем, то он возвращает регистр статуса, как и у цветного адаптора.) <table align="center"> <tr><td></td><td>;---ожидаем пока все чисто</td></tr> <tr><td>MOV DX,3DAH </td><td>;порт регистра статуса</td></tr> <tr><td>CHECK_AGAIN: IN AL,DX </td><td>;получаем значение</td></tr> <tr><td>TEST AL,1 </td><td>;проверка первого бита</td></tr> <tr><td>JNE CHECK_AGAIN </td><td>;если он 0, то обратно</td></tr> <tr><td></td><td>;---теперь выводим сообщение</td></tr> <tr><td>LEA BX,MESSAGE </td><td>;сообщение в сегменте данных</td></tr> <tr><td>MOV DI,2000 </td><td>;начинаем вывод с центра экрана</td></tr> <tr><td>MOV AH,01000001B </td><td>;атрибут синий на красном</td></tr> <tr><td>NEXT_CHAR: MOV AL,[BX] </td><td>;берем символ</td></tr> <tr><td>CMP AL,'$' </td><td>;проверяем на конец строки</td></tr> <tr><td>JE ALL_DONE </td><td>;если конец, то на выход</td></tr> <tr><td>MOV ES:[DI],AX </td><td>;иначе выводим символ</td></tr> <tr><td>INC BX </td><td>;увеличиваем указатель строки</td></tr> <tr><td>INC DI </td><td>;увеличиваем указатель буфера</td></tr> <tr><td>INC DI </td><td>;</td></tr> <tr><td>JMP SHORT NEXT_CHAR </td><td>;обрабатываем следующий символ</td></tr> <tr><td>ALL_DONE:</td><td></td></tr> </table> <p> Вы можете поэкспериментировать сколько символов за один цикл может выводить Ваша процедура без появления интерференции. Имейте ввиду, что при первом выполнении цикла тестируемый бит может быть равным единице, но может не оставаться времени, чтобы завершить операцию записи. <hr><p align="center">
<~-<a href="430.htm">Раздел 3. Вывод символов на экран.</a><br><a href="index.htm#header">Содержание</a><br><a href="432.htm">4.3.2 Вывод строки символов на экран.</a>-~>
</p></body></html>
