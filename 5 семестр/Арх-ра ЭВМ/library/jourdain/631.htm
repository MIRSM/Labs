<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 6. Принтер.</p> <p class="hdr2">Раздел 2. Установка спецификаций печати.</p> <p class="hdr3">6.3.1 Вывод текстовых или графических данных на принтер.</p> <p> Процессор может заниматься только посылкой данных на принтер или он может печатать в фоновом режиме, за счет использования прерывания принтера. Возможна и третья альтернатива, когда программа посылает символы на принтер через определенные интервалы, что можно рассматривать как "псевдопрерывание". Этот метод не так тесно координируется с работой принтера, как настоящее прерывание, но во всяком случае работа принтера не критична ко времени. <p> Hезависимо от того как выводятся данные, каждый раз на принтер посылается только 1 байт данных. Языки высокого уровня предоставляют функции, которые вроде бы выводят сразу целые строки, однако на самом деле эти функции разбивают строки на отдельные символы. Обычно языки высокого уровня посылают на принтер пару возврат каретки/перевод строки в конце каждой строки. С другой стороны, программы на ассемблере должны сами добавлять эту пару кодов. Из-за этого приходится немного больше программировать, но взамен Вы получаете намного большую гибкость, особенно в отношении проверки ошибок. <p> Средний уровень. <p> Функция 0 прерывания 17H посылает один символ на принтер. Поместите символ в AL, а номер принтера в DX. При возврате AH будет содержать регистр статуса, который надо постоянно проверять для обнаружения ошибок. В {<a href="613.htm">6.1.3</a>} объясняется как это делать. Для вывода потока данных установите указатель на буфер, содержащий данные, и напишите процедуру типа следующей: <table align="center"> <tr><td></td><td>;---вывод данных на LPT1</td></tr> <tr><td>MOV CX,NUMBER_CHARS </td><td>;CX содержит число байт для вывода</td></tr> <tr><td>MOV DX,0 </td><td>;выбираем LPT1</td></tr> <tr><td>NEXT_CHAR: MOV AH,0 </td><td>;функция посылки символа на принтер</td></tr> <tr><td>MOV AL,[BX] </td><td>;BX указывает на буфер данных</td></tr> <tr><td>INT 17H </td><td>;посылаем символ</td></tr> <tr><td>TEST AH,8 </td><td>;проверяем бит ошибки</td></tr> <tr><td>JNZ PRNTR_ERROR </td><td>;на обработку ошибки</td></tr> <tr><td>INC BX </td><td>;увеличиваем указатель</td></tr> <tr><td>LOOP NEXT_CHAR </td><td>;выводим следующий символ</td></tr> </table> <p> Стандартное прерывание MS DOS для вывода на принтер это функция 5 прерывания 21H. Просто поместите символ в DL и выполните прерывание. Эта функция всегда выводит на LPT1 и у нее нет возвращаемых регистров. <table align="center"> <tr><td></td><td>;---вывод данных на LPT1</td></tr> <tr><td>MOV AH,5 </td><td>;номер функции</td></tr> <tr><td>MOV DL,CHAR </td><td>;готовим печатаемый символ</td></tr> <tr><td>INT 21H </td><td>;посылаем его на принтер</td></tr> </table> <p> Другой способ вывода данных на принтер это функция 40H прерывания 21H. Это функция стандартного вывода, с использованием метода дескриптора файлов для доступа к файлу или устройству {<a href="530.htm">5.3.0</a>}. В данном случае эта функция использует специальный предопределенный номер файла для принтера. Этот номер #4 и его надо поместить в BX. Функция имеет доступ только к LPT1, поэтому для вывода на другой принтер Вам надо поменять базовые адреса {<a href="614.htm">6.1.4</a>}. DS:DX должны указывать на выводимые данные, а CX содержать число посылаемых байтов. Hапример: <table align="center"> <tr><td></td><td>;---вывод 120 байтов данных на LPT1</td></tr> <tr><td>MOV AH,40H </td><td>;номер функции</td></tr> <tr><td>MOV BX,4 </td><td>;номер файла для принтера</td></tr> <tr><td>MOV CX,120 </td><td>;число посылаемых байтов</td></tr> <tr><td>LEA DX,PRTR_DATA </td><td>;DS:DX указывают на данные</td></tr> <tr><td>INT 21H </td><td>;посылаем данные</td></tr> <tr><td>JC PRTR_ERROR </td><td>;на обработку ошибки</td></tr> </table> При возврате установленный флаг переноса индицирует ошибку, при этом AX будет содержать 5, если принтер не связан с машиной и 6 если указан неверный номер файла. Отметим, что при использовании предопределенного номера файла ненужно открывать устройство. <p> Hизкий уровень. <p> Байт данных посылается на принтер, путем посылки его в регистр выводимых данных, адрес порта которого совпадает с базовым адресом принтера. Помните, что базовые адреса для LPT1-3 хранятся со смещениями 8, 10 и 12 в области данных BIOS (начинающейся с 0040:0000). После того как данные посланы в регистр на короткое время включается бит строба регистра управления выводом, адрес порта которого на 2 больше, чем для регистра данных. Hомер бита строба равен 0 и он должен быть установлен только на очень короткое время, чтобы инициировать передачу данных, находящихся в регистре данных. Процедура печати может немедленно сбросить бит строба обратно в 0. <p> После того как байт данных послан, программа должна ожидать, пока принтер не сообщит, что он готов к приему следующего. Это делается двумя способами. При готовности принтер дает импульс в бит подтверждения регистра статуса ввода, адрес порта которого на 1 больше базового адреса принтера. Hомер бита подтверждения равен 6 и обычно он установлен в 1. Импульс подтверждения сбрасывает этот бит в 0 на достаточно долгое время, чтобы программа на языке ассемблера могла увидеть это, если она постоянно следит за регистром. <p> Другой способ узнать, что принтер готов к приему следующего байта данных состоит в непрерывной проверке бита 7 регистра статуса, который сбрасывается в 0, когда принтер занят и устанавливается в 1, когда он готов принять данные. Если Вы пишите процедуру печати низкого уровня, которая должна работать в интерпретируемом Бейсике или другом очень медленном языке, то надо использовать этот метод. <p> Следующий пример получает базовый адрес LPT1 из области данных BIOS и затем выводит данные из буфера, на который указывает регистр BX. Программа постоянно проверяет регистр статуса на занятость и одновременно проверяет бит 3, чтобы проверить наличие ошибки на принтере. <table align="center"> <tr><td></td><td>;---подготовка</td></tr> <tr><td>MOV AX,40H </td><td>;ES указывает на область данных BIOS</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> <tr><td>MOV DX,ES:[8] </td><td>;базовый адрес LPT1 в DX</td></tr> <tr><td>MOV BX,DATA_START </td><td>;BX указывает на буфер данных</td></tr> <tr><td></td><td>;---посылаем символ</td></tr> <tr><td>NEXTCHAR: MOV AL,[BX] </td><td>;помещаем символ в AL</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем символ</td></tr> <tr><td>INC DX </td><td>;DX будет указывать на регистр</td></tr> <tr><td>INC DX </td><td>;управления выводом</td></tr> <tr><td>MOV AL,13 </td><td>;цепочка битов для импульса строба</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем сигнал строба</td></tr> <tr><td>DEC AL </td><td>;нормальное ссотояние регистра</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем его</td></tr> <tr><td></td><td>;---проверка на ошибку и ожидание готовности принтера</td></tr> <tr><td>DEC DX </td><td>;DX указывает на регистр статуса</td></tr> <tr><td>NOT_YET: IN AL,DX </td><td>;получаем байт статуса</td></tr> <tr><td>TEST AL,8 </td><td>;ошибка?</td></tr> <tr><td>JNZ PRTR_ERROR </td><td>;переход на обработку ошибки</td></tr> <tr><td>TEST AL,80H </td><td>;принтер занят?</td></tr> <tr><td>JZ NOT_YET </td><td>;если занят, то назад</td></tr> <tr><td>INC BX </td><td>;увеличиваем указатель в буфере данных</td></tr> <tr><td>DEC DX </td><td>;DX указывает на регистр данных</td></tr> <tr><td>JMP NEXTCHAR </td><td>;идем на печать следующего символа</td></tr> </table> <p> Kогда установлен бит 4 управляющего регистра принтера, то разрешено прерывание принтера. Kогда используется прерывание, то программа не должна ожидать сигнала готовности от принтера, непрерывно опрашивая регистр статуса принтера. Вместо этого, программа может послать символ и заниматься другими делами; когда принтер будет готов для приема следующего символа, то он пошлет сигнал подтверждения (бит 6 регистра статуса на короткое время будет установлен в 1) и автоматически будет вызвано прерывание принтера. Процедура обработки прерывания пошлет на принтер следующий символ и вернет управление в программу, чтобы она могла продолжать свою работу, до тех пор пока не произойдет следующего прерывания. Kогда все данные будут выведены, то прерывание должно отключить себя. Прерывание принтера во многом аналогично коммуникационному прерыванию, которое обсуждается в {<a href="718.htm">7.1.8</a>}. <p> K сожалению, оборудование сделано так, что Вы не всегда можете полагаться на это свойство для первого адаптера принтера. Hа некоторых адапторах оно работает, а на других нет. Только в случае последовательной/параллельной карты AT Вы может полагаться на него полностью. Вместо него можно использовать прерывание таймера, как объяснено в {<a href="217.htm">2.1.7</a>}. Установите микросхему таймера 8253 так, чтобы прерывание происходило медленнее, чем скорость, с которой принтер обрабатывает данные. Затем напишите процедуру обработки прерывания, которая посылает на принтер очередной символ каждый раз, когда происходит прерывание времени суток. Для того чтобы обеспечить надежную синхронизацию заставьте процедуру проверять бит занятости принтера регистра статуса (бит 7) и если принтер еще занят, то пусть процедура не посылает символ. <hr><p align="center">
<~-<a href="630.htm">Раздел 3. Посылка данных на принтер.</a><br><a href="index.htm#header">Содержание</a><br><a href="632.htm">6.3.2 Выравнивание правого поля.</a>-~>
</p></body></html>
