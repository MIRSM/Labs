<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 1. Системные ресурсы.</p> <p class="hdr2">Раздел 1. Ревизия системных ресурсов.</p> <p class="hdr3">1.1.7 Ревизия количества памяти.</p> <p> Вопрос: "Сколько имеется памяти?",- может иметь три смысла. О каком количестве памяти сообщают переключатели, установленные на системной плате? Сколько микросхем памяти реально установлено в машине? И, наконец, сколько остается свободной памяти, которую DOS может использовать для выполнения Ваших программ? Машина может иметь 10 банков памяти по 64K, но переключатели могут указывать на наличие только 320K, оставляя половину памяти для каких-либо специальных целей. А как может Ваша программа узнать, сколько из доступных 320K она может использовать, учитывая, что другое программное обеспечение может быть загружено резидентным в верхнюю или нижнюю часть памяти? <p> Ответ на каждый вопрос можно получить своим способом. Для PC и XT установка переключателей может быть просто прочитана через порт B микросхемы интерфейса с периферией 8255. В пункте {<a href="111.htm">1.1.1</a>} описано как это делается. BIOS хранит двухбайтную переменную по адресу 0040:0013, которая сообщает число килобайт используемой памяти. Для PCjr бит 3 порта 62H (порт C микросхемы 8255) равен нулю, когда машина имеет добавочные 64K памяти. AT дает особо полную информацию о памяти. Регистры 15H (младший) и 16H (старший) микросхемы информации о конфигурации говорят сколько памяти установлено на системной плате (возможны три значения: 0100H для 256K, 0200H - для 512K и 0280H для 512K плюс 128K на плате расширения). Память канала ввода/вывода для AT сообщается регистрами 17H и 18H (с инкрементом 512K). Память сверх 1 мегабайта доступна через регистры 30H и 31H (опять с инкрементом 512K, вплоть до 15 мегабайт). Если AT имеет 128K на плате расширения, то установлен бит 7 регистра 33. Во всех случаях надо сначала послать номер регистра в порт 70H, а затем прочитать значение из порта 71H. <p> Легко написать программу, которая прямо тестирует наличие памяти через определенные интервалы адресного пространства. Поскольку минимальная порция памяти 16 килобайт, то достаточно проверить одну ячейку памяти в каждом 16-килобайтном сегменте, чтобы убедиться, что все 16K присутствуют. Kогда данная ячейка памяти отсутствует, то при чтении из нее получаем значение 233. Для проверки можно записать в ячейку произвольное число, отличное от 233 и сразу же считать его. Если вместо посланного числа возвращается 233, то соответствующий банк памяти отсутствует. Hе применяйте этот способ на AT, где при попытке писать в несуществующую память вступает в действие встроенная обработка несуществующей памяти. Диагностика AT настолько хороша, что Вы можете целиком положиться на системную информацию о конфигурации. <p> Память постоянно занимается частями операционной системы, драйверами устройств, резидентными программами обработки прерываний и управляющими блоками MS DOS. При проверке банков памяти Вы не должны вносить необратимых изменений в содержимое памяти. Сначала надо сохранить значение, хранящееся в тестируемой ячейке, затем проверить ее и восстановить первоначальное значение. <p> Имеется еще одна проблема. Если Ваша процедура хотя бы временно модифицирует свой код, то это может привести к краху. Поэтому для проверки надо выбирать такую ячейку из блока 64K, которая не будет занята текстом Вашей процедуры. Для этого поместите процедуру тестирования впереди программы, а для тестирования выберите ячейку со смещением равным смещению для кодового сегмента. Hапример, если регистр кодового сегмента содержит 13E2, то сегмент начинается со смещения 13E2 во втором 64K-байтном блоке памяти. Поскольку Ваша подпрограмма проверки не может находиться по этому адресу, то Вы можете безопасно проверять значение 3E2 в каждом блоке. Запрет прерываний {<a href="122.htm">1.2.2</a>} позволяет не беспокоиться о модификации кода из-за аппаратных прерываний, которые могут происходить во время проверки. <p> Определение количества памяти реально доступной операционной системе также требует некоторого фокуса. Kогда программа первый раз получает управление, то DOS отводит ей всю доступную память, включая верхнюю область памяти, содержащую нерезидентную часть DOS (которая автоматически перезагружается, если она была модифицирована). Для запуска другой программы из текущей или для того, чтобы сделать программу подходящей для многопользовательсой системы, необходимо урезать программу до требуемого размера. В пункте {<a href="131.htm">1.3.1</a>} описано как это сделать с помощью функции 4AH прерывания 21H. <p> Эта же функция может быть использована для расширения отведенной памяти. Поскольку программе отводится вся доступная память при загрузке, то такое расширение невозможно при старте. Если Вы попробуете сделать это, то будет установлен флаг переноса, в регистре AX появится код ошибки 8, а в регистре BX будет возвращено максимальное число доступных 16-байтных параграфов. Эта информация как раз и нужна. Значит надо выдать запрос со слишком большим значением в регистре BX ( скажем, F000H параграфов), а затем выполните прерывание. Позаботьтесь о том, чтобы выполнить эту функцию в самом начале программы, пока регистр ES еще имеет начальное значение. <p> Средний уровень. <p> Прерывание 12H BIOS проверяет установку переключателей и возвращает в AX количество килобайт памяти в системе. Эта величина вычисляется из установки регистров микросхемы 8255 или, для AT, микросхемы конфигурации/часов. Входных регистров нет. Имейте ввиду, что установка переключателей может быть неверной, что ограничивает достоверность такого подхода. <p> Для определения числа 16-байтных параграфов, доступных для DOS, используйте функцию 4AH прерывания 21H. ES должен иметь то же значение, что при старте задачи: <table align="center"> <tr><td></td><td>;---определение числа параграфов доступных для DOS</td></tr> <tr><td>MOV AH,4AH </td><td>;указываем нужную функцию</td></tr> <tr><td>MOV BX,0FFFFH </td><td>;требуем слишком большую память</td></tr> <tr><td>INT 21H </td><td>;BX содержит число доступных параграфов</td></tr> </table> <p> AT использует функцию 88H прерывания 15H для проверки наличия расширенной памяти, которая ищет память вне адресного пространства процессора в обычном режиме адресации. Говорят, что она ищет память за отметкой 1 мегабайта. При этом на системной плате должно быть от 512 до 640 килобайт памяти, чтобы эта функция работала. Число килобайтных блоков расширенной памяти возвращается в AX. <p> Hизкий уровень. <p> Первый пример проверяет число банков памяти по 64K в первых десяти 64-килобайтных сегментах памяти. Если Вы будете проверять старшие 6 банков памяти, то имейте ввиду, что имеются видеобуфер, начиная с B000:0000 (и, возможно, A000:0000) и ПЗУ, начиная с F000:0000 (и, возможно, C000:0000). <table align="center"> <tr><td></td><td>;---проверка каждого банка памяти:</td></tr> <tr><td>CLI </td><td>;запрет аппаратных прерываний</td></tr> <tr><td>MOV AX,CS </td><td>;получаем значение кодового сегмента</td></tr> <tr><td>AND AX,0FFFH </td><td>;сбрасываем старшие 4 бита</td></tr> <tr><td>MOV ES,AX </td><td>;помещаем указатель в ES</td></tr> <tr><td>MOV DI,0 </td><td>;DI считает число банков памяти</td></tr> <tr><td>MOV CX,10 </td><td>;будем проверять 10 банков</td></tr> <tr><td>MOV BL,'X' </td><td>;для проверки используем 'X'</td></tr> <tr><td>NEXT:</td><td></td></tr> <tr><td>MOV DL,ES:[0] </td><td>;сохраняем значение тестируемой ячейки</td></tr> <tr><td>MOV ES:[0],BL </td><td>;помещаем 'X' в эту ячейку</td></tr> <tr><td>MOV DH,ES:[0] </td><td>;читаем тестируемую ячейку</td></tr> <tr><td>MOV ES:[0],DL </td><td>;восстанавливаем значение</td></tr> <tr><td>CMP DH,'X' </td><td>;совпадает с тем, что писали?</td></tr> <tr><td>JNE GO_AHEAD </td><td>;если нет, то банк отсутствует</td></tr> <tr><td>INC DI </td><td>;увеличиваем число банков</td></tr> <tr><td>GO_AHEAD:</td><td></td></tr> <tr><td>MOV AX,ES </td><td>;готовим увеличение указателя</td></tr> <tr><td>ADD AX,1000H </td><td>;указываем на следующие 64K</td></tr> <tr><td>MOV ES,AX </td><td>;возвращаем указатель в ES</td></tr> <tr><td>LOOP NEXT </td><td>;обрабатываем следующий банк</td></tr> <tr><td>STI </td><td>;разрешаем аппаратные прерывания</td></tr> </table> <hr><p align="center">
<~-<a href="116.htm">1.1.6 Определение числа и типа периферийных устройств.</a><br><a href="index.htm#header">Содержание</a><br><a href="120.htm">Раздел 2. Управление прерываниями.</a>-~>
</p></body></html>
