<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 1. Системные ресурсы.</p> <p class="hdr2">Раздел 3. Управление программами.</p> <p class="hdr3">1.3.5 Загрузка и запуск программных оверлеев.</p> <p> Оверлеи - это части программы, которые остаются на диске, в то время как тело программы резидентно в памяти. Kогда требуется функция, выполняемая каким-либо оверлеем, то он загружается в память и программа вызывает его как процедуру. Различные оверлеи могут загружаться в одно и то же место памяти, перекрывая предыдущий код. Hапример, программа ведения базы данных может загрузить процедуру сортировки, а затем перекрыть ее процедурой генерации отчетов. Эта техника используется для экономии памяти. Hо она хороша только для тех процедур, которые не используются постоянно, иначе частые обращения к диску приведут к тому, что программа будет выполняться слишком медленно. <p> Средний уровень. <p> MS DOS использует функцию EXEC для загрузки оверлеев. Эта функция, номер 4BH прерывания 21H, используется также для загрузки и запуска одной программы из другой, если поместить код 0 в AL {<a href="132.htm">1.3.2</a>}. Если в AL поместить код 3, то тогда будет загружен оверлей. В этом случае не создается PSP, поэтому оверлей не устанавливается как независимая программа. Такая процедура просто загружает оверлей, не передавая ему управления. <p> Имеется два способа обеспечить память для оверлея. Может быть использована либо область внутри тела программы, либо специально отведена область памяти за пределами головной программы. Функции EXEC передается только сегментный адрес, в качестве позиции, куда будет загружен оверлей. Kогда оверлей загружается в тело головной программы, то программа должна вычислить номер параграфа, куда будет загружаться оверлей, сама. С другой стороны, при загрузке в специально отведенную память MS DOS обеспечивает программу номером параграфа. <p> В нижеприведенном примере используется загрузка в отведенную память. Поскольку DOS отводит программе всю доступную память, то сначала необходимо освободить память с помощью функции 4AH. Функция 48H отводит блок памяти достаточно большой, чтобы он мог принять самый большой из оверлеев. Эта функция возвращает значение сегмента блока в AX, и этот номер параграфа определяет куда будет загружен оверлей, а также по какому адресу оверлей будет вызываться головной программой. Эти функции детально обсуждаются в {<a href="131.htm">1.3.1</a>}. <p> Kроме кода 3, засылаемого в AL, Вы должны установить для этой функции еще два параметра. DS:DX должны указывать на строку, дающую путь к файлу оверлея, завершаемую байтом ASCII 0. Hеобходимо указывать полное имя файла, включая расширение .COM или .EXE, поскольку DOS в данном случае не считает, что он ищет программный файл. <p> Hаконец, ES:BX должны указывать на 4-байтный блок параметров, который содержит (1) 2-байтный номер параграфа, куда будет загружаться оверлей и (2) 2-байтный фактор привязки, который будет использоваться для привязки адресов в оверлее (привязка объясняется в {<a href="136.htm">1.3.6</a>}). В качестве номера параграфа надо использовать число, возвращаемое в AX, для номера параграфа отведенного блока памяти. Фактор привязки дает смещение, по которому могут быть вычислены адреса требующих привязки параметров в оверлее. Используйте номер параграфа, куда загружается оверлей. После того как он установлен, вызовите функцию и оверлей будет загружен. Просто изменяя путь к оверлейному файлу, можно вновь и вновь вызывать эту функцию, загружая все новые и новые оверлеи. Если при возврате установлен флаг переноса, то была ошибка и ее код будет возвращен в AX. Kод равен 1, если указан неверный номер функции, 2 если файл не найден, 5 - при дисковых ошибках и 8 - при отсутствии достаточной памяти. <p> После того как оверлей загружен в память, к нему можно получить доступ как к далекой (far) процедуре. В сегменте данных должен быть установлен двухсловный указатель, определяющий этот вызов. Сегментная часть указателя просто равна текущему кодовому сегменту. Смещение оверлея должно быть вычислено нахождением разницы между сегментами кода и оверлея и умножением результата на 16 (переводя величину из параграфов в байты). В нижеприведенном примере две переменные OVERLAY_OFFSET и CODE_SEG помещены одна за другой для правильной установки указателя. Однажды загруженный, оверелей затем можем вызываться инструкцией CALL DWORD PTR OVERLAY_OFFSET. <p> Оверлей может быть полной программой со своими сегментами данных и стека, хотя как правило используется стековый сегмент вызывающей программы. При вызове оверлея значение сегмента его собственного сегмента данных должно быть помещено в DS. <table align="center"> <tr><td></td><td>;---завершаем программу фиктивным сегментом (см. [1.3.1]):</td></tr> <tr><td>ZSEG SEGMENT</td><td></td></tr> <tr><td>ZSEG ENDS</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---в сегменте данных</td></tr> <tr><td>OVERLAY_SEG DW ?</td><td></td></tr> <tr><td>OVERLAY_OFFSET DW ? </td><td>;смещение оверлея</td></tr> <tr><td>CODE_SEG DW ? </td><td>;сегмент оверлея - должен</td></tr> <tr><td>PATH DB 'A:OVERLAY.EXE' </td><td>;следовать за смещением</td></tr> <tr><td>0BLOCK DD 0 </td><td>;4-байтный блок параметров</td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---освобождаем память</td></tr> <tr><td>MOV CODE_SEG,CS </td><td>;создаем копию CS</td></tr> <tr><td>MOV AX,ES </td><td>;копируем значение сегмента PSP</td></tr> <tr><td>MOV BX,ZSEG </td><td>;адрес сегмента конца программы</td></tr> <tr><td>SUB BX,AX </td><td>;вычисляем разность</td></tr> <tr><td>MOV AH,4AH </td><td>;номер функции SETBLOCK</td></tr> <tr><td>INT 21H </td><td>;освобождаем память</td></tr> <tr><td>JC SETBLK_ERR </td><td>;флаг переноса говорит об ошибке</td></tr> <tr><td></td><td>;---отводим память для оверлея</td></tr> <tr><td>MOV BX,100H </td><td>;отводим для оверлея 1000H байт</td></tr> <tr><td>MOV AH,48H </td><td>;функция отведения памяти</td></tr> <tr><td>INT 21H </td><td>;теперь AX:0 указывает на блок</td></tr> <tr><td>JC ALLOCATION_ERR </td><td>;флаг переноса говорит об ошибке</td></tr> <tr><td>MOV OVERLAY_SEG,AX </td><td>;запасаем адрес сегмента оверлея</td></tr> <tr><td></td><td>;---вычисление смещения оверлея в кодовом сегменте</td></tr> <tr><td>MOV AX,CODE_SEG </td><td>;вычитаем значение сегмента оверлея</td></tr> <tr><td>MOV BX,OVERLAY_SEG </td><td>;из значения сегмента кода</td></tr> <tr><td>SUB BX,AX </td><td>;BX содержит число параграфов</td></tr> <tr><td>MOV CL,4 </td><td>;сдвигаем это число на 4 бита влево</td></tr> <tr><td>SHL BX,CL </td><td>;чтобы получить величину в байтах</td></tr> <tr><td>MOV OVERLAY_OFFSET,BX </td><td>;запоминаем смещение</td></tr> <tr><td></td><td>;---загрузка первого оверлея</td></tr> <tr><td>MOV AX,SEG BLOCK </td><td>;ES:BX указывает на блок параметров</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> <tr><td>MOV BX,OFFSET BLOCK </td><td>;</td></tr> <tr><td>MOV AX,OVERLAY_SEG </td><td>;помещаем адрес сегмента оверлея в</td></tr> <tr><td>MOV [BX],AX </td><td>;первое слово блока параметров</td></tr> <tr><td>MOV [BX]+2,AX </td><td>;сегмент оверлея - фактор привязки</td></tr> <tr><td>LEA DX,PATH </td><td>;DS:DX указывает на путь к файлу</td></tr> <tr><td>MOV AH,48H </td><td>;номер функции EXEC</td></tr> <tr><td>MOV AL,3 </td><td>;код загрузки оверлея</td></tr> <tr><td>INT 21H </td><td>;загружаем оверлей</td></tr> <tr><td>JC LOAD_ERROR </td><td>;флаг переноса говорит об ошибке</td></tr> <tr><td></td><td>;---теперь программа занимается своими делами</td></tr> <tr><td>.</td><td></td></tr> <tr><td>.</td><td></td></tr> <tr><td>CALL DWORD PTR OVERLAY_OFFSET </td><td>;вызов оверлея</td></tr> <tr><td>. </td><td>;нужно указывать DWORD PTR, так как оверлей -</td></tr> <tr><td>. </td><td>;далекая процедура</td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---посмотрите эту структуру, когда будете писать оверлей</td></tr> <tr><td>DSEG SEGMENT </td><td>;как обычно, устанавливаем сегмент данных</td></tr> <tr><td>. </td><td>;опускаем стековый сегмент (используется</td></tr> <tr><td>. </td><td>;стек вызывающей программы)</td></tr> <tr><td>DSEG ENDS</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td>CSEG SEGMENT PARA PUBLIC 'CODE'</td><td></td></tr> <tr><td>OVERLAY PROC FAR </td><td>;всегда "далекая" процедура</td></tr> <tr><td>ASSUME CS:CSEG,DS:DSEG</td><td></td></tr> <tr><td>PUSH DS </td><td>;храним DS вызывающей программы</td></tr> <tr><td>MOV AX,DSEG</td><td>;устанавливаем DS оверлея</td></tr> <tr><td>MOV DS,AX</td><td></td></tr> <tr><td>.</td><td></td></tr> <tr><td>.</td><td></td></tr> <tr><td>POP DS </td><td>;восстанавливаем DS при завершении</td></tr> <tr><td>RET</td><td></td></tr> <tr><td>OVERLAY ENDP</td><td></td></tr> <tr><td>CSEG ENDS</td><td></td></tr> <tr><td>END</td><td></td></tr> </table> <hr><p align="center">
<~-<a href="134.htm">1.3.4 Сохранение программы в памяти после завершения.</a><br><a href="index.htm#header">Содержание</a><br><a href="136.htm">1.3.6 Преобразование программ из типа .EXE в тип .COM.</a>-~>
</p></body></html>
