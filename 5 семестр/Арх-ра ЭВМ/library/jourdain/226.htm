<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 2. Таймеры и звук.</p> <p class="hdr2">Раздел 2. Создание звука.</p> <p class="hdr3">2.2.6 Генерация строки тонов, одновременно с другими операциями.</p> <p> Хотя в Бейсике это делается очень просто, на самом деле это нетривиальный трюк программирования в реальном времени. Для решения этой задачи нужно использовать генерацию звука через микросхему 8253 {<a href="223.htm">2.2.3</a>}, так как метод, использующий микросхему 8255 {<a href="222.htm">2.2.2</a>}, занимает процессор. Соответственно, только строки чистых музыкальных тонов могут производиться таким методом - всякого рода звуковые эффекты при этом недоступны. Основная техника программирования в реальном времени показана в {<a href="217.htm">2.1.7</a>}. Программы, работающие в реальном времени, модифицируют прерывание таймера, которое останавливает процессор 18.2 раз в секунду, чтобы изменить показание счетчика времени суток. Расширение процедуры прерывания сравнивает новое значение счетчика времени суток со значением, показывающим время завершения генерации тона, и когда это значение достигнуто, прерывает звук, начинает генерацию другого тона и устанавливает время его окончания. <p> Hизкий уровень. <p> Приведенная процедура является развитием процедуры, показанной в предыдущем разделе, на случай реального времени. Она требует понимания, как перепрограммировать прерывание таймера, что обсуждалось в {<a href="217.htm">2.1.7</a>}. Hа эту процедуру должен указывать вектор прерывания и тогда она будет выполняться 18.2 раза в секунду, в те моменты, когда будет обновляться значение счетчика времени суток BIOS. Обычно, будут выполняться только несколько строчек, которых достаточно, чтобы определить, что время изменения звука еще не наступило, - и процедура освождает процессор для решения других задач. <p> Счетчик времени суток BIOS используется для измерения длительности каждой ноты. При переходе от одной ноты к другой, длительность новой ноты вычисляется как число импульсов счетчика и это значение добавляется к текущему его значению. Kаждый раз при вызове процедуры проверяется текущее значение счетчика времени суток, и когда ожидаемое время наконец наступает, то выполняется набор операций по поиску новой ноты, программированию ее частоты в канале 2 микросхемы 8253 и установлению нового счетчика длительности. Добавочный код требуется для обработки специальных случаев первой и последней нот в строке. <table align="center"> <tr><td></td><td>;---в сегменте данных</td></tr> <tr><td>BEAT DB 10,9,8,7,6,5,4,3,2 </td><td>;длительность нот</td></tr> <tr><td>FREQUENCY DW 2280,2031,1809,1709 </td><td>;таблица частот</td></tr> <tr><td>DW 1521,1355,1207,1139 </td><td>;</td></tr> <tr><td>MELODY DB 1,2,3,4,5,6,7,8,0FFH </td><td>;номер частоты в таблице</td></tr> <tr><td>HOLDIP DW 0 </td><td>;запоминаем оригинальный</td></tr> <tr><td>HOLDCS DW 0 </td><td>;вектор прерывания</td></tr> <tr><td>SOUND_NOW? DB 1 </td><td>;звук включен?</td></tr> <tr><td>FIRST_NOTE? DB 1 </td><td>;первая нота?</td></tr> <tr><td>END_NOTE DW 0 </td><td>;счетчик конца ноты</td></tr> <tr><td>WHICH_NOTE DW 0 </td><td>;указатель на текущую ноту</td></tr> <tr><td></td><td>;---инициализация вектора прерывания</td></tr> <tr><td></td><td>;изменение вектора</td></tr> <tr><td>PUSH DS </td><td>;сохраняем регистр</td></tr> <tr><td>MOV AX,SEG MELODY2 </td><td>;сегмент процедуры</td></tr> <tr><td>MOV DS,AX </td><td>;помещаем в DS</td></tr> <tr><td>MOV DX,OFFSET MELODY2 </td><td>;смещение процедуры</td></tr> <tr><td>MOV AL,1CH </td><td>;номер вектора прерывания</td></tr> <tr><td>MOV AH,25H </td><td>;функция установки вектора</td></tr> <tr><td>INT 21H </td><td>;изменение вектора</td></tr> <tr><td>POP DS </td><td>;восстановление регистра</td></tr> <tr><td></td><td>;</td></tr> <tr><td></td><td>;---программа работает дальше, постоянно вызывая процедуру ;</td></tr> <tr><td></td><td>;---в конце программы восстанавливаем вектор прерывания</td></tr> <tr><td>MOV DX,0FF53H </td><td>;восстанавливаем оригинальные</td></tr> <tr><td>MOV AX,0F000H </td><td>;значения для вектора 1CH</td></tr> <tr><td>MOV DS,AX </td><td>;</td></tr> <tr><td>MOV AL,1CH </td><td>;номер прерывания</td></tr> <tr><td>MOV AH,25H </td><td>;функция установки вектора</td></tr> <tr><td>INT 21H </td><td>;восстанавливаем вектор</td></tr> <tr><td>RET </td><td>;</td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---это само прерывание</td></tr> <tr><td>MELODY2 PROC FAR</td><td></td></tr> <tr><td>PUSH AX </td><td>;сохраняем изменяемые регистры</td></tr> <tr><td>PUSH BX </td><td>;</td></tr> <tr><td>PUSH CX </td><td>;</td></tr> <tr><td>PUSH DX </td><td>;</td></tr> <tr><td>PUSH DI </td><td>;</td></tr> <tr><td>PUSH SI </td><td>;</td></tr> <tr><td>PUSH DS </td><td>;</td></tr> <tr><td>MOV AX,SS:[114] </td><td>;берем начальный DS со стека</td></tr> <tr><td>MOV DS,AX </td><td>;восстанавливаем его</td></tr> <tr><td>CMP SOUND_NOW?,1 </td><td>;нужен ли звук?</td></tr> <tr><td>JE PLAY_IT </td><td>;если нет, то выход из прерывания</td></tr> <tr><td>JMP NOT_NOW </td><td>;</td></tr> <tr><td>PLAY_IT: CMP FIRST_NOTE?,0 </td><td>;это первая нота?</td></tr> <tr><td>JE TIME_CHECK </td><td>;если нет, то на установку времени</td></tr> <tr><td></td><td>;---инициализация</td></tr> <tr><td>PORT_B EQU 61H </td><td>;определяем имена портов</td></tr> <tr><td>COMMAND_REG EQU 43H </td><td>;</td></tr> <tr><td>LATCH2 EQU 42H </td><td>;</td></tr> <tr><td>IN AL,PORT_B </td><td>;берем статус порта B</td></tr> <tr><td>OR AL,00000011B </td><td>;разрешаем динамик и таймер</td></tr> <tr><td>OUT PORT_B,AL </td><td>;посылаем байт обратно</td></tr> <tr><td>MOV SI,0 </td><td>;указатель на строки</td></tr> <tr><td>MOV AL,0B6H </td><td>;инициализация канала 2 таймера</td></tr> <tr><td>OUT COMMAND_REG,AL </td><td>;посылаем в командный регистр</td></tr> <tr><td>MOV FIRST_NOTE?,0 </td><td>;сбрасываем флаг первой ноты</td></tr> <tr><td></td><td>;---ищем ноту, получаем ее частоту, посылаем в канал 2</td></tr> <tr><td>NEXT_NOTE: LEA BX,MELODY </td><td>;берем смещение строки мелодии</td></tr> <tr><td>MOV SI,WHICH_NOTE </td><td>;указатель на текущую ноту</td></tr> <tr><td>MOV AL,[BX][SI] </td><td>;код текущей ноты строки</td></tr> <tr><td>CMP AL,0FFH </td><td>;проверяем признак конца</td></tr> <tr><td>JE NO_MORE </td><td>;если да, то на конец</td></tr> <tr><td>CBW </td><td>;иначе в словный формат</td></tr> <tr><td></td><td>;получаем частоту</td></tr> <tr><td>MOV BX,OFFSET FREQUENCY </td><td>;смещение таблицы частот</td></tr> <tr><td>DEC AX </td><td>;начинаем отсчет с нуля</td></tr> <tr><td>SHL AX,1 </td><td>;умножаем на 2, т.к. словная</td></tr> <tr><td>MOV DI,AX </td><td>;адресуемся через DI</td></tr> <tr><td>MOV DX,[BX][DI] </td><td>;получаем частоту из таблицы</td></tr> <tr><td></td><td>;начинаем исполнение ноты</td></tr> <tr><td>MOV AL,DL </td><td>;готовим младший байт частоты</td></tr> <tr><td>OUT LATCH2,AL </td><td>;посылаем в регистр задвижки</td></tr> <tr><td>MOV AL,DH </td><td>;готовим старший байт</td></tr> <tr><td>OUT LATCH2,AL </td><td>;посылаем его</td></tr> <tr><td></td><td>;---пустой цикл, определяющий длительность нот</td></tr> <tr><td>TIME_IT: MOV AH,0 </td><td>;фнукция чтения счетчика</td></tr> <tr><td>INT 1AH </td><td>;получаем значение счетчика</td></tr> <tr><td>MOV BX,OFFSET BEAT </td><td>;смещение строки длин нот</td></tr> <tr><td>MOV CL,[BX][SI] </td><td>;длительность текущей ноты</td></tr> <tr><td>MOV CH,0 </td><td>;</td></tr> <tr><td>MOV BX,DX </td><td>;младшее слово значения счетчика</td></tr> <tr><td>ADD BX,CX </td><td>;добавляем длину в импульсах</td></tr> <tr><td>MOV END_NOTE,BX </td><td>;запоминаем время окончания</td></tr> <tr><td>TIME_CHECK: MOV AH,0 </td><td>;функция чтения счетчика</td></tr> <tr><td>INT 1AH </td><td>;читаем счетчик</td></tr> <tr><td>CMP DX,END_NOTE </td><td>;сравниваем с нужным</td></tr> <tr><td>JNE NOT_NOW </td><td>;если неравно, то выходим</td></tr> <tr><td>MOV SI,WHICH_NOTE </td><td>;иначе, берем следующую ноту</td></tr> <tr><td>INC SI </td><td>;увеличиваем номер ноты</td></tr> <tr><td>MOV WHICH_NOTE,SI </td><td>;запоминаем его</td></tr> <tr><td>JMP NEXT_NOTE </td><td>;начинаем следующую ноту</td></tr> <tr><td></td><td>;---завершение процедуры</td></tr> <tr><td>NO_MORE: IN AL,PORT_B </td><td>;берем статус порта B</td></tr> <tr><td>AND AL,0FCH </td><td>;выключаем динамик</td></tr> <tr><td>OUT 61H,AL </td><td>;возвращаем байт</td></tr> <tr><td>MOV SOUND_NOW?,0 </td><td>;восстанавливаем переменные</td></tr> <tr><td>MOV FIRST_NOTE?,1 </td><td>;</td></tr> <tr><td>NOT_NOW: POP DS </td><td>;восстанавливаем регистры</td></tr> <tr><td>POP SI </td><td>;</td></tr> <tr><td>POP DI </td><td>;</td></tr> <tr><td>POP DX </td><td>;</td></tr> <tr><td>POP CX </td><td>;</td></tr> <tr><td>POP BX </td><td>;</td></tr> <tr><td>POP AX </td><td>;</td></tr> <tr><td>IRET </td><td>;возврат из прерывания</td></tr> <tr><td>MELODY2 ENDP</td><td></td></tr> </table> <hr><p align="center">
<~-<a href="225.htm">2.2.5 Генерация набора тонов.</a><br><a href="index.htm#header">Содержание</a><br><a href="227.htm">2.2.7 Создание плавного перехода тонов.</a>-~>
</p></body></html>
