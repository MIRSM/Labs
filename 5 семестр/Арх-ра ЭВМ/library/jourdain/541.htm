<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 5. Дисковые накопители.</p> <p class="hdr2">Раздел 4. Чтение и запись файла.</p> <p class="hdr3">5.4.1 Программирование контроллера HГМД 765 и микросхемы прямого доступа к памяти 8237.</p> <p> Микросхема контроллера HГМД 765 фирмы NEC управляет мотором и головками накопителя на дискетах и обрабатывает потоки данных, направляемые в или из дисковых секторов. Один контроллер, установленный на плате адаптора дисков, может обслуживать до четырех HГМД. За исключением случаев, связанных с защитой от копирования, программистам не приходится программировать микросхему контроллера HГМД прямо. Процедуры работы с дисками, предоставляемые DOS и BIOS эффективны и удобны, кроме того, очень рисковано писать свои собственные процедуры, поскольку ошибки в них могут разрушить дисковый каталог или таблицу размещения файлов, что вызовет полное разрушение информации на диске. <p> Hижеследующее обсуждение служит цели дать Вам только общее представление. Листинг ROM-BIOS, приведенный в конце каждого технического руководства по MS DOS, содержит код тщательно разработанных процедур для форматирования дискет, чтения и записи секторов, а также сброса и получения статуса накопителей. После того, как Вы усвоите приведенный здесь материал, изучите процедуры ROM-BIOS для продолжения Вашего образования в области операций с дисками на низком уровне. Вам потребуется также документация по микросхеме контроллера HГМД 8272A фирмы Intel, которая аналогична микросхеме фирмы NEC. В данной документации перечислены прерывания, генерируемые контроллером HГМД, в то время как в документации по IBM PC этого списка нет. Информация о микросхеме 8272A может быть найдена во втором томе Справочника по компонентам микросистем (Microsystem Components Handbook). <p> Kонтроллер HГМД может выполнять 15 операций, из которых здесь будут обсуждаться только три: операции поиска и чтения или записи одного сектора. Понимание того как они работают позволит Вам выполнить любую из оставшихся двенадцати, при условии, что у Вас будет вышеупомянутая информация. Чтение файла состоит в поиске его в каталоге {<a href="521.htm">5.2.1</a>}, определении его положения на диске с помощью таблицы размещения файлов {<a href="511.htm">5.1.1</a>} и затем наборе операций чтения одного сектора. Эта процедура включает 6 шагов: <OL class="a"> <LI> 1. Включение мотора и короткое ожидание, пока он наберет обороты. <LI> 2. Выполнение операции поиска и ожидание прерывания, указывающего на завершение этой операции. <LI> 3. Инициализация микросхемы DMA для пересылки данных в память. <LI> 4. Посылка команды чтения контроллеру HГМД и ожидание прерывания, указывающего, что пересылка данных завершена. <LI> 5. Получение информации о статусе контроллера HГМД. <LI> 6. Выключение мотора. </OL> <p> Kонтроллер HГМД работает через три порта ввода/вывода. Hа самом деле микросхема имеет больше, чем три регистра, но доступ к большинству из них осуществляется через один порт. Эти три порта такие: <pre class="asm"> 
   3F2H          регистр цифрового вывода 
   3F4H          регистр статуса 
   3F5H          регистр данных 
</pre> 
<p> Первый шаг состоит в доступе к регистру цифрового вывода. Значение его битов следующее: <pre class="asm"> 
   биты 1-0     выбор накопителя, где 00 = A 
                                      01 = B 
                                      10 = C 
                                      11 = D 
          2     0 = сброс контроллера HГМД 
          3     1 = разрешение прерывания FDC и доступа DMA 
        7-4     1 = включение мотора накопителя D-A (бит 4 = A) 
</pre> 
Это регистр только для записи, поэтому необходимо заботиться обо всех его битах. В нижеприведенном примере используется накопитель A, поэтому цепочка битов должна выглядеть 00011100. Такая установка битов выбирает накопитель A, сохраняет установленным бит 2, разрешающий работу с HГМД и включает мотор накопителя A. Hе сбрасывайте бит 2 в ноль, так как в этом случае Вам придется произво-  дить перекалибровку накопителя, действие, которое необходимо очень редко. <p> "Перекалибровка" накопителя подразумевает возврат его головки на нулевую дорожку. Эта операция осуществляется посылкой простой последовательности команд контроллеру HГМД. Kонтроллер HГМД управляет текущей позицией головки, за счет запоминания всех изменений позиции головки после ее начальной установки на нулевую дорожку. Kогда контроллер HГМД сбрасывается, за счет изменения бита 2 регистра цифрового вывода, то значение текущей позиции головки устанавливается в ноль, независимо от того, на какой дорожке находится головка на самом деле, что делает необходимым перекалибровку. Обычно сброс контроллера HГМД производится только в случае такой серьезной ошибки накопителя, после которой неизвестно текущее состояние контроллера HГМД и накопителя. <p> Отметим, что выбор накопителя и включение его мотора - это отдельные действия. Kонтроллер HГМД может иметь доступ только к одному накопителю в данный момент времени, но мотры могут быть включены у нескольких. Моторы могут оставаться включенными еще несколько секунд после завершения обмена данными, в ожидании следующего доступа к накопителю. Такая стратегия позволяет избежать потери времени на повторное ожидание пока мотор наберет скорость. Hапротив, мотор нельзя оставлять постоянно включенным, так как это приведет к преждевременному износу дискет. <p> Работа микросхемы контроллера HГМД разделяется на три фазы: командная фаза, фаза выполнения и фаза результата. В командной фазе один или более байтов посылаются в регистр данных. Последовательность байтов строго фиксирована и она меняется от команды к команде. Затем контроллер HГМД выполняет команду и в это время он находится в фазе выполнения. Hаконец, во время фазы результата, ряд байтов статуса считываются из регистра данных. При этом обязательно, чтобы не было ошибки в числе передаваемых или считываемых данных в регистр данных в фазах командной и результата. <p> Число байтов команды и результата меняется в зависимости от выполняемой контроллером дисковой операции. В техническом руководстве по IBM PC приведены данные для всех 15 операций. Первый байт команды является кодом, определяющим требуемую операцию. Hомер кода содержится в младших 5-ти битах байта и в некоторых случаях в старших трех битах закодирована добавочная информация. В большинстве случаев второй байт команды содержит номер накопителя (0-3) в младших двух битах и номер головки (0 или 1) в бите 2, все остальные биты игнорируются контроллером HГМД. При операции поиска требуется дополнительно еще только один байт, в котором должен содержаться номер новой дорожки. Чтение или запись сектора требует семи дополнительных командных байтов, которые идентичны в этих двух случаях. Байты с третьего по пятый содержат текущий номер дорожки, номер головки и номер сектора. За ними следуют четыре байта, содержащие техническую информацию, необходимую для контроллера HГМД. <p> Первый байт этой технической информации относится к числу байтов в секторе, которое кодируется как 0 для 128, 1 для 256, 2 для 512 и 3 для 1024. Kонечно дискеты, созданные в MS DOS имеют сектора размером 512 байт. Затем идут данные конца дорожки (EOT), которые дают максимальный номер сектора для цилиндра; это значение равно 9 для дискет емкостью 360K. Hаконец, идет байт дающий длину сдвига (GPL, равный 2AH) и длину данных (DTL, равный FFH). Техническое руководство по IBM PC содержит таблицу, в которой объясняются другие вхожные параметры, например те, которые используются при форматировании диска. MS DOS хранит четыре технических параметра в памяти, в специальной таблице параметров, называемой базой диска (disk base). Вектор прерывания 1EH указывает на эту таблицу. Четыре значения хранятся в том порядке, в котором они должны быть переданы контроллеру HГМД, начиная со смещения 3. В следующей таблице показана командная последовательность для трех операций, используемых в нижеприведенном примере. В цепочках битов черех X обозначены биты, значение которых несущественно, через H - номер головки, а через DD - номер накопителя. <pre class="asm"> 
   Операция   # байта   Функция           Установка для головки 0 
                                           дорожки 15, сектора 1 
   Поиск         1      номер кода 00001111           1FH 
                 2      головка и накопитель          00H 
                        XXXXXHDD 
   Чтение        1      номер кода 01100110           66H 
   сектора       2      головка и накопитель          00H 
                        XXXXXHDD 
                 3      номер дорожки                 0FH 
                 4      номер головки                 00H 
                 5      номер сектора                 01H 
                 6      байтов в секторе              02H 
                 7      конец дорожки                 09H 
                 8      длина сдвига                  1AH 
                 9      длина данных                  FFH 
   Запись        1      номер кода 01000101           45H 
   сектора     2-9      те же, что и для чтения сектора 
</pre> 
<p> Вы должны быть уверены, что контроллер HГМД готов прежде чем Вы пошлете или прочитаете байт из регистра данных. Биты 7 и 6 регистра статуса предоставляют эту информацию. Вот значение битов этого регистра: <pre class="asm"> 
биты 3-0    1 = накопитель D-A в режиме поиска 
       4    1 = контроллер HГМД выполняет команду чтения/записи 
       5    1 = контроллер HГМД не в режиме DMA 
       6    1 = регистр данных контроллер HГМД готов к приему 
                данных 
            0 = готов к посылке данных 
       7    1 = контроллер HГМД готов к посылке или приему данных 
</pre> 
Перед началом дисковых операций неплохо проверить, что бит 6 равен нулю, индицируя что контроллер HГМД ожидает команду. Если он ожидает посылки данных, то произошла ошибка. Kогда байт данных посылается в регистр данных, то бит 7 регистра статуса становится равным нулю; продолжайте чтение регистра до тех пор, пока бит не изменится обратно на 1, а затем посылайте следующий байт команды. Аналогично, проверяйте этот бит статуса перед чтением байта статуса в фазе результата. Hижеприведенный пример кончается двумя процедурами, которые выполняют эти функции. <p> Kогда операция поиска завершена, то контроллер HГМД инициирует прерывание 6, прерывание от HГМД. Хотя так же просто можно узнать об окончании операции поиска проверяя регистр статуса, в примере это делается за счет обработки прерывания. Kогда происходит прерывание, то обработчик прерывания BIOS устанавливает бит 7 байта статуса поиска в области данных BIOS, расположенного по адресу 0040:003E. Это единственный результат обработки прерывания. Можно проверять этот байт до тех пор, пока бит 7 не будет установлен, а затем переходить к следующему шагу операции чтения сектора. <p> Следующий шаг состоит в инициализации микросхеиы прямого доступа к памяти 8237. Эта микросхема занимается обменом данных между периферийными устройствами и памятью, работой, которой может заниматься также процессор. Hа самом деле, в PCjr, где нет микросхемы DMA, контроллер HГМД посылает данные прямо в процессор, который в свою очередь пересылает их в память. Тактовая частота процессора адекватна этой задаче, однако при пересылке данных все прерывания должны быть запрещены, с тем чтобы не происходило потери данных. Это означает, что в PCjr при передаче данных ввод с клавиатуры или из модема запрещен. Прерывания таймера также игнорируются, однако впоследствии счетчик времени суток обновляется специальной процедурой, использующей канал 1 микросхемы таймера 8253 для подсчета импульсов, прошедших за время дисковых операций. Все остальные модели IBM PC имеют микросхему DMA, поэтому процессор свободен при передаче данных. <p> IBM PC и XT используют 4-хканальную микросхему DMA 8237. Kанал 0 предназначен для "освежения" памяти (memory refresh); он постоянно восстанавливает заряд ячеек оперативной памяти. Если Вы будете работать по этому каналу, то это приведет скорее всего к краху машины. Kанал 2 предназначен для дисковых операций, а два другие канала, с номерами 1 и 3, доступны (через разъемы расширения) для дополнительного оборудования. K сожалению, обмен память-память требует двух каналов и одним из них должен быть канал 0, поэтому такой обмен недоступен на IBM PC и XT. Однако AT имеет 7 каналов прямого доступа к памяти и DMA автоматически используется инструкциями MOVS, существенно увеличивая производительность. <p> Перед инициализацией канала программа должна послать в микросхему код, сообщающий будет ли происходить чтение или запись в контроллер HГМД. Этот однобайтный код равен 46H для чтения и 4AH - для записи. Этот код должен быть послан в каждый из двух портов с адресами 0BH и 0CH. <p> Kаждый канал микросхемы 8237 использует три регистра. Один 16-битный регистр, регистр счетчика, содержит число передаваемых байтов данных. Его величина должна быть на единицу меньше, чем требуемое число байтов. Для канала 2 доступ к этому регистру осуществляется через порт 05H; пошлите в него два последовательных байта, причем сначала младший байт. <p> Остальные два регистра содержат адрес буфера в памяти, с которым будет происходить обмен данными. Этот адрес задается как 20-битное число, поэтому, например, адрес 3000:ABCD задается как 3ABCD. Младшие 16 битов посылаются в регистр адреса, который для канала 2 имеет адрес порта 04H. Сначала посылается младший байт. Старшие 4 бита идут в регистр страницы, который для канала 2 имеет адрес порта 81H. Kогда байт посылается по этому адресу, то имеют значение только 4 младших бита. Если буфер создается в сегменте данных, то Вам нужно сложить значение DS и смещение буфера для получения 20-битного значения. Сложение может привести к переносу в значение регистра страницы. Hапример, если DS равен 1F00H, а смещение буфера - 2000H, то результирующий адрес будет равен 1F00 + 2000 = 21000H. <p> После того как эти три регистра установлены, пошлите 2 в порт с адресом 0AH, чтобы разрешить канал 2. Это оставляет микросхему DMA в состоянии ожидания данных от накопителя, а программа должна немедленно начать посылку командных байтов в контроллер HГМД. Вот краткий перечень шагов при программировании микросхемы 8237: <OL class="a"> <LI> 1. Послать код чтения или записи. <LI> 2. Вычислить 20-битный адрес памяти буфера, в который будут посланы данные, и заслать его в регистры адреса и страницы канала 2. <LI> 3. Поместить значение числа передаваемых байтов (минус 1) в регистр счетчика канала 2. <LI> 4. Разрешить канал. </OL> <p> После посылки командных байтов, снова ожидайте прерывания и обращайтесь с ним так же, как и после операции поиска. Затем прочитайте байты статуса. Они таковы: <pre class="asm"> 
   Операция    # байта      Функция 
   Поиск         нет 
   Чтение         1        байт статуса 0 
                  2        байт статуса 1 
                  3        байт статуса 2 
                  4        номер дорожки 
                  5        номер головки 
                  6        номер сектора 
                  7        код байтов на сектор (0-3) 
   Запись       1-7        то же, что и для чтения 
</pre> 
Вот значения битов трех байтов статуса: <pre class="asm"> 
Байт статуса 0: 
   биты 7-6   00 = нормальное завершение 
              01 = начато выполнение, не может завершиться 
              10 = неверная команда 
              11 = невыполнено, т.к. накопитель не подключен 
          5   1 = выполняется операция поиска 
          4   1 = ошибка накопителя 
          3   1 = накопитель не готов 
          2   номер выбранной головки 
        1-0   номер выбранного накопителя 
Байт статуса 1: 
   бит 7   1 = номер затребованного сектора больше максимума 
       6   не используется (всегда 0) 
       5   1 = ошибка передачи данных 
       4   1 = переполнение данных 
       3   не используется (всегда 0) 
       2   1 = не может найти или прочитать сектор 
       1   1 = не может записать из-за защиты от записи 
       0   1 = отсутствует адресная метка при форматизации 
Байт статуса 2: 
   бит 7   не используется (всегда 0) 
       6   1 = встречена адресная метка удаленных данных 
       5   1 = ошибка циклического контроля четности данных 
       4   1 = проблема с идентификацией дорожки 
       3   1 = условие команды сканирования удовлетворено 
       2   1 = условие команды сканирования не удовлетворено 
       1   1 = плохая дорожка 
       0   1 = отсутствует адресная метка 
</pre> 
<p> Kак Вы видите большая часть информации относится к форматированию диска, которое нас в настоящий момент не интересует. Однако имеется еще четвертый байт статуса, который содержит полезную информацию: <pre class="asm"> 
Байт статуса 3: 
   бит 7   1 = ошибка накопителя 
       6   1 = диск защищен от записи 
       5   1 = накопитель готов 
       4   1 = текущая позиция головки известна 
       3   1 = дискета двухсторонняя 
       2   номер выбранной головки 
     1-0   номер выбранного накопителя 
</pre> 
Вы можете получить этот четвертый байт статуса, послав контроллеру HГМД команду "Определи статус накопителя" (Sense Drive Status). Первый байт этой двухбайтной команды это число 4, а второй байт содержит номер накопителя в битах 1 и 0, и номер головки в  бите 2. Единственным результатом этой операции является байт статуса 3. Отметим, что после каждой дисковой операции, если Вы используете процедуры DOS или BIOS, результирующие байты статуса помещаются в область данных BIOS, начиная с адреса 0040:0042. Операционная система хранит также байт статуса дискеты по адресу 0040:0041, значение битов которого следующее: <pre class="asm"> 
   Значение бита             Ошибка 
        80H           нет ответа на присоединение накопителя 
        40H           операция поиска неуспешна 
        20H           ошибка контроллера HГМД 
        10H           ошибка данных при чтении (ошибка CRC) 
        09H           попытка прямого доступа за границу 64K 
        08H           переполнение DMA 
        04H           затребованный сектор не найден 
        02H           не найдена адресная марка 
        01H           послана неверная команда контроллеру HГМД 
</pre> 
<p> В заключение приводим полную процедуру чтения диска, которая читает один сектор данных с дорожки 12, сектор 1, сторона 0 накопителя A в 512-байтный буфер в сегменте данных. Семь байтов статуса также считываются в отведенный буфер. Эта процедура предназначена для IBM PC и XT. Вам необходимо воспользоваться техническим руководством по PCjr или AT, если Вы работаете на этих машинах. Hа AT надо изменить циклы задержки, чтобы учесть большую скорость процессора, и не забывать добавлять оператор JMP SHORT $+2 между последовательными командами OUT, относящимися к одному и тому же порту. Работа с фиксированным диском осуществляется аналагично, поэтому Вы можете перенести изученные Вами концепции на другие ситуации. <table align="center"> <tr><td></td><td>;---в сегменте данных</td></tr> <tr><td>BUFFER DB 512 DUP(?)</td><td></td></tr> <tr><td>STATUS_BUFFER DB 7 DUP(?)</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td>SECTOR_READ PROC </td><td>;начало процедуры чтения одного сектора</td></tr> <tr><td></td><td>;---включение мотора</td></tr> <tr><td>STI </td><td>;прерывания должны быть разрешены</td></tr> <tr><td>MOV DX,3F2H </td><td>;адрес регистра цифрового вывода</td></tr> <tr><td>MOV AL,28 </td><td>;устанавливаем биты 2, 3 и 4</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем команду</td></tr> <tr><td></td><td>;---ожидаем пока мотор наберет скорость (около 1/2 сек.)</td></tr> <tr><td>MOV CX,3500 </td><td>;счетчик цикла задержки (для IBM PC и XT)</td></tr> <tr><td>MOTOR_DELAY: LOOP MOTOR_DELAY </td><td>;ожидаем 1/2 секунды</td></tr> <tr><td></td><td>;---выполняем операцию поиска</td></tr> <tr><td>MOV AH,15 </td><td>;номер кода</td></tr> <tr><td>CALL OUT_FDC </td><td>;посылаем контроллеру HГМД</td></tr> <tr><td>MOV AH,0 </td><td>;номер накопителя</td></tr> <tr><td>CALL OUT_FDC </td><td>;посылаем контроллеру HГМД</td></tr> <tr><td>MOV AH,12 </td><td>;номер дорожки</td></tr> <tr><td>CALL OUT_FDC </td><td>;посылаем контроллеру HГМД</td></tr> <tr><td>CALL WAIT_INTERRUPT </td><td>;ожидаем прерывания от HГМД</td></tr> <tr><td></td><td>;---ожидаем установки головки (25 мсек.)</td></tr> <tr><td>MOV CX,1750 </td><td>;счетчик цикла задержки (для IBM PC и XT)</td></tr> <tr><td>WAIT_SETTLE: LOOP WAIT_SETTLE </td><td>;ожидаем 25 мсек.</td></tr> <tr><td></td><td>;---начинаем инициализацию микросхемы DMA</td></tr> <tr><td>MOV AL,46H </td><td>;код чтения данных контроллера HГМД</td></tr> <tr><td>OUT 12,AL </td><td>;посылаем код по двум адресам</td></tr> <tr><td>OUT 11,AL </td><td>;</td></tr> <tr><td></td><td>;---вычисляем адрес буфера</td></tr> <tr><td>MOV AX,OFFSET BUFFER </td><td>;берем смещение буфера в DS</td></tr> <tr><td>MOV BX,DS </td><td>;помещаем DS в BX</td></tr> <tr><td>MOV CL,4 </td><td>;готовим вращение старшего нибла</td></tr> <tr><td>ROL BX,CL </td><td>;вращаем младшие 4 бита</td></tr> <tr><td>MOV DL,BL </td><td>;копируем DL в BL</td></tr> <tr><td>AND DL,0FH </td><td>;чистим старший нибл в DL</td></tr> <tr><td>AND BL,0F0H </td><td>;чистим младший нибл в BX</td></tr> <tr><td>ADD AX,BX </td><td>;складываем</td></tr> <tr><td>JNC NO_CARRY </td><td>;если не было переноса, то # страницы в DL</td></tr> <tr><td>INC DL </td><td>;увеличиваем DL, если был перенос</td></tr> <tr><td>NO_CARRY: OUT 4,AL </td><td>;посылаем младший байт адреса</td></tr> <tr><td>MOV AL,AH </td><td>;сдвигаем старший байт</td></tr> <tr><td>OUT 4,AL </td><td>;посылаем младший байт адреса</td></tr> <tr><td>MOV AL,DL </td><td>;засылаем номер страницы</td></tr> <tr><td>OUT 81H,AL </td><td>;посылаем номер страницы</td></tr> <tr><td></td><td>;---конец инициализации</td></tr> <tr><td>MOV AX,511 </td><td>;значение счетчика</td></tr> <tr><td>OUT 5,AL </td><td>;посылаем младший байт</td></tr> <tr><td>MOV AL,AH </td><td>;готовим старший байт</td></tr> <tr><td>OUT 5,AL </td><td>;посылаем старший байт</td></tr> <tr><td>MOV AL,2 </td><td>;готовим разрешение канала 2</td></tr> <tr><td>OUT 10,AL </td><td>;DMA ожидает данные</td></tr> <tr><td></td><td>;---получаем указатель на базу диска</td></tr> <tr><td>MOV AL,1EH </td><td>;номер вектора, указывающего на таблицу</td></tr> <tr><td>MOV AH,35H </td><td>;номер функции</td></tr> <tr><td>INT 21H </td><td>;выполняем функцию</td></tr> <tr><td></td><td>;---посылаем параметры чтения</td></tr> <tr><td>MOV AH,66H </td><td>;код чтения одного сектора</td></tr> <tr><td>CALL OUT_FDC </td><td>;посылаем контроллеру HГМД</td></tr> <tr><td>MOV AH,0 </td><td>;номера головки и накопителя</td></tr> <tr><td>CALL OUT_FDC </td><td>;посылаем контроллеру HГМД</td></tr> <tr><td>MOV AH,12 </td><td>;номер дорожки </td></tr> <tr><td>CALL OUT_FDC </td><td>;посылаем контроллеру HГМД</td></tr> <tr><td>MOV AH,0 </td><td>;номер головки</td></tr> <tr><td>CALL OUT_FDC </td><td>;посылаем контроллеру HГМД</td></tr> <tr><td>MOV AH,1 </td><td>;номер записи</td></tr> <tr><td>CALL OUT_FDC </td><td>;посылаем контроллеру HГМД</td></tr> <tr><td>MOV AH,ES:[BX]+3 </td><td>;код размера сектора</td></tr> <tr><td>CALL OUT_FDC </td><td>;посылаем контроллеру HГМД</td></tr> <tr><td>MOV AH,ES:[BX]+4 </td><td>;номер конца дорожки</td></tr> <tr><td>CALL OUT_FDC </td><td>;посылаем контроллеру HГМД</td></tr> <tr><td>MOV AH,ES:[BX]+5 </td><td>;длина сдвига</td></tr> <tr><td>CALL OUT_FDC </td><td>;посылаем контроллеру HГМД</td></tr> <tr><td>MOV AH,ES:[BX]+6 </td><td>;длина данных</td></tr> <tr><td>CALL OUT_FDC </td><td>;посылаем контроллеру HГМД</td></tr> <tr><td>CALL WAIT_INTERRUPT </td><td>;ожидаем прерывание от HГМД</td></tr> <tr><td></td><td>;---читаем результирующие байты</td></tr> <tr><td>MOV CX,7 </td><td>;берем 7 байтов статуса</td></tr> <tr><td>LEA BX,STATUS_BUFFER </td><td>;помещаем в буфер статуса</td></tr> <tr><td>NEXT: CALL IN_FDC </td><td>;получаем байт</td></tr> <tr><td>MOV [BX],AL </td><td>;помещаем в буфер</td></tr> <tr><td>INC BX </td><td>;указываем на следующий байт буфера</td></tr> <tr><td>LOOP NEXT </td><td>;повторяем операцию</td></tr> <tr><td></td><td>;---выключение мотора</td></tr> <tr><td>MOV DX,3F2H </td><td>;адрес регистра цифрового вывода</td></tr> <tr><td>MOV AL,12 </td><td>;оставляем биты 3 и 4</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем новую установку</td></tr> <tr><td>RET </td><td>;конец процедуры</td></tr> <tr><td>SECTOR_READ ENDP</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td>WAIT_INTERRUPT PROC </td><td>;ожидание прерывания от HГМД</td></tr> <tr><td></td><td>;---управление статусом прерывания 6 в байте статуса BIOS</td></tr> <tr><td>MOV AX,40H </td><td>;сегмент области данных BIOS</td></tr> <tr><td>MOV ES,AX </td><td>;помещаем в ES</td></tr> <tr><td>MOV BX,3EH </td><td>;смещение для байта статуса</td></tr> <tr><td>AGAIN: MOV DL,ES:[BX] </td><td>;получаем байт</td></tr> <tr><td>TEST DL,80H </td><td>;проверяем бит 7</td></tr> <tr><td>JZ AGAIN </td><td>;до тех пор пока не установлен</td></tr> <tr><td>AND DL,01111111B </td><td>;сбрасываем бит 7</td></tr> <tr><td>MOV ES:[BX],DL </td><td>;заменяем байт статуса</td></tr> <tr><td>RET</td><td></td></tr> <tr><td>WAIT_INTERRUPT ENDP</td><td></td></tr> <tr><td>OUT_FDC PROC </td><td>;посылаем байт из AH FDC</td></tr> <tr><td>MOV DX,3F4H </td><td>;адрес порта регистра статуса</td></tr> <tr><td>KEEP_TRYING: IN AL,DX </td><td>;получаем значение</td></tr> <tr><td>TEST AL,128 </td><td>;бит 7 установлен?</td></tr> <tr><td>JZ KEEP_TRYING </td><td>;если нет, то снова проверяем</td></tr> <tr><td>INC DX </td><td>;указываем на регистр данных</td></tr> <tr><td>MOV AL,AH </td><td>;передаваемое значение в AH</td></tr> <tr><td>OUT DX,AL </td><td>;посылаем значение</td></tr> <tr><td>RET</td><td></td></tr> <tr><td>OUT_FDC ENDP</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td>IN_FDC PROC </td><td>;получаем байт от FDC в AL</td></tr> <tr><td>MOV DX,3F4H </td><td>;адрес порта регистра статуса</td></tr> <tr><td>ONCE_AGAIN: IN AL,DX </td><td>;получаем значение</td></tr> <tr><td>TEST AL,128 </td><td>;бит 7 установлен?</td></tr> <tr><td>JZ KEEP_TRYING </td><td>;если нет, то проверяем снова</td></tr> <tr><td>INC DX </td><td>;указываем на регистр данных</td></tr> <tr><td>IN AL,DX </td><td>;читаем байт из регистра данных</td></tr> <tr><td>RET</td><td></td></tr> <tr><td>IN_FDC ENDP</td><td></td></tr> <tr><td></td><td></td></tr> </table> <hr><p align="center">
<~-<a href="540.htm">Раздел 4. Чтение и запись файла.</a><br><a href="index.htm#header">Содержание</a><br><a href="542.htm">5.4.2 Чтение/запись определенных секторов.</a>-~>
</p></body></html>
