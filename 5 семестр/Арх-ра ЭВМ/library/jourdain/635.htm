<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 6. Принтер.</p> <p class="hdr2">Раздел 2. Установка спецификаций печати.</p> <p class="hdr3">6.3.5 Kопирование экрана на принтер (дамп экрана).</p> <p> Дамп текстового экрана сделать достаточно просто, если все используемые символы содержатся в ПЗУ принтера и ни один из них не выводится со специальными атрибутами, такими как подчеркивание или негативное изображение. В этом простейшем случае программе нужно лишь установить ширину принтера равной 80 символам, а затем считывать символы поочередно из видеобуфера, посылая их как непрерывный поток данных на принтер. Если в ПЗУ принтера отсутствуют специальные символы, такие как символы псевдографики, то программа должна подготовить свою таблицу данных для этих символов и выводить их на принтер в графическом режиме. Поскольку эти символы могут заходить в межстрочные интервалы, то может потребоваться специальное программирование {<a href="634.htm">6.3.4</a>}. <p> Kаждый из специальных атрибутов символов создает свои проблемы. Проверяйте атрибут каждого символа при считывании его из видеобуфера (в {<a href="413.htm">4.1.3</a>} обсуждается значение битов, соответствующее различным атрибутам). Kогда символ выделен с помощью подчеркивания или повышенной интенсивности, то надо включать подчеркивание или печать жирным шрифтом на принтере. Однако если символ выводится в негативном изображении, то возникают те же проблемы, что и с некоторыми графическими символами: область негативного изображения должна простираться до верхнего края следующей строки. В этом случае надо следуя указаниям {<a href="634.htm">6.3.4</a>} заполнить черным всю область при втором проходе. В зависимости от принтера, Вам может понадобиться создать специальную таблицу данных для вывода символов в негативе, поскольку когда они будут печататься, то окружающие точки могут находиться слишком близко одна к другой, затемняя изображаемый символ. В этом случае не может быть и речи о печати в два прохода. Простым решением проблемы с негативным изображением является использование графического режима экрана для вывода текста, а затем сделать дамп графического экрана. <p> Графические дампы создают свои проблемы. Байт данных принтера соответствует восьми вертикальным точкам, в то время как на экране байт представляет 8 горизонтальных точек. Поэтому требуется процедура преобразования, показанная на рис. 6-4. Hадо сразу получать по 8 байтов памяти экрана, выбирая такие, которые соответствуют области точек 8*8. Затем надо использовать логические операции для перестановки битов, как показано в примерах. <p> Имейте ввиду, что большинство матричных принтеров искажают экранное изображение. Это происходит потому, что они используют масштабный коэффициент 1:1, в то время как экран использует коэффициент 5:6 (масштабный коэффициент сравнивает число горизонтальных точек на дюйм с числом вертикальных точек на дюйм). Точнее говоря, искажение изображения на самом деле возникает из-за масштабного коэффициента экрана, поскольку программы должны специально менять данные для изображения, чтобы оно выглядело так, как нам хочется (например, изображение окружности на экране создается выводом на него эллипса). Kогда данные с экрана выводятся на принтер, то эти искажение должны обращаться. Hекоторые графические принтеры имеют специальные режимы, в которых можно выводить копию экрана без искажения, а цветной принтер IBM может менять масштабный коэффициент в любом из своих графических режимов. <p> Hизкий уровень. <p> Язык ассемблера делает битовые преобразования намного быстрее. Вот процедура, которая делает эти преобразования ужасно быстро, поскольку она держит все в микропроцессоре (она немного великовата, но Вы можете использовать взамен алгоритм, показанный в Бейсике). Процедура работает, храня 8 результирующих байтов в регистрах CX, DX, BP и DI. Байт экранных данных помещается в AL, а затем в AH передвигаются последовательно CL, CH, DL и DH. Kаждый раз из AL в AH сдвигается один бит и когда сделаны 4 сдвига, то CX и DX обмениваются с DX и BP, после чего все это повторяется снова. Этот процесс повторяется для каждого из 8-ми экранных байтов и когда он завершен, то преобразованное изображение хранится в регистрах микропроцессора, причем самый левый байт данных для печати в CL. Содержимое регистров выводится на принтер и обнуляется, после чего процесс повторяется для следующих восьми байтов экрана. Сначала получите 8 байтов из видеобуфера и поместите их в буфер с именем BUFFER. Поместите 0 в AX, CX, DX, BP и DI. Затем: <table align="center"> <tr><td>LEA BX,BUFFER </td><td>;указываем на буфер видеоданных</td></tr> <tr><td>MOV SI,0 </td><td>;смещение в этом буфере</td></tr> <tr><td>GET_BYTE: MOV AL,[BX][SI] </td><td>;берем байт</td></tr> <tr><td>DO_HALF: XCNG AH,CL </td><td>;получаем CL, CH, DL и DH</td></tr> <tr><td>SHL AX,1 </td><td>;сдвигая бит из AL</td></tr> <tr><td>XCNG AH,CL </td><td>;</td></tr> <tr><td>XCNG AH,CH </td><td>;</td></tr> <tr><td>SHL AX,1 </td><td>;</td></tr> <tr><td>XCNG AH,CH </td><td>;</td></tr> <tr><td>XCNG AH,DL </td><td>;</td></tr> <tr><td>SHL AX,1 </td><td>;</td></tr> <tr><td>XCNG AH,DL </td><td>;</td></tr> <tr><td>XCNG AH,DH </td><td>;</td></tr> <tr><td>SHL AX,1 </td><td>;</td></tr> <tr><td>XCNG AH,DH </td><td>;</td></tr> <tr><td></td><td>;---начинаем вторую половину перемещения битов</td></tr> <tr><td>XCNG CX,BP </td><td>;обмениваем содержимое CX и DX</td></tr> <tr><td>XCNG DX,DI </td><td>;</td></tr> <tr><td>CMP SI,7 </td><td>;если все байты преобразованы, то печатаем</td></tr> <tr><td>JE PRINT_BYTES </td><td>;</td></tr> <tr><td>INC SI </td><td>;иначе переходим к следующему байту</td></tr> <tr><td>JMP SHORT GET_BYTE </td><td>;</td></tr> <tr><td></td><td>;---печатаем байты</td></tr> <tr><td>PRINT_BYTES: PUSH DX </td><td>;сохроаняем DX</td></tr> <tr><td>MOV AH,5 </td><td>;функция вывода на принтер</td></tr> <tr><td>MOV DL,27 </td><td>;код Esc</td></tr> <tr><td>INT 21H </td><td>;посылаем его</td></tr> <tr><td>MOV DL,75 </td><td>;код графического режима</td></tr> <tr><td>INT 21H </td><td>;посылаем его</td></tr> <tr><td>MOV DL,6 </td><td>;будет послано 6 байтов</td></tr> <tr><td>INT 21H </td><td>;</td></tr> <tr><td>MOV DL,0 </td><td>;</td></tr> <tr><td>INT 21H </td><td>;</td></tr> <tr><td>CALL PRINT_2_BYTES </td><td>;посылаем содержимое CX</td></tr> <tr><td>POP CX </td><td>;</td></tr> <tr><td>CALL PRINT_2_BYTES </td><td>;посылаем содержимое DX</td></tr> <tr><td>MOV CX,BP </td><td>;</td></tr> <tr><td>CALL PRINT_2_BYTES </td><td>;посылаем содержимое BP</td></tr> <tr><td>MOV DX,DI </td><td>;</td></tr> <tr><td>CALL PRINT_2_BYTES </td><td>;посылаем содержимое DI</td></tr> <tr><td>.</td><td></td></tr> <tr><td>(идем к следующей группе из восьми байтов)</td><td></td></tr> <tr><td>.</td><td></td></tr> <tr><td>PRINT_2_BYTES: PROC NEAR</td><td></td></tr> <tr><td>MOV AH,5 </td><td>;функция печати</td></tr> <tr><td>MOV DL,CL </td><td>;сначала CL</td></tr> <tr><td>INT 21H </td><td>;печатаем</td></tr> <tr><td>MOV DL,CH </td><td>;затем CH</td></tr> <tr><td>INT 21H </td><td>;печатаем</td></tr> <tr><td>RET</td><td></td></tr> <tr><td>PRINT_2_BYTES ENDP</td><td></td></tr> </table> <hr><p align="center">
<~-<a href="634.htm">6.3.4 Печать специальных символов.</a><br><a href="index.htm#header">Содержание</a><br><a href="710.htm">Глава 7. Ввод/вывод.</a>-~>
</p></body></html>
