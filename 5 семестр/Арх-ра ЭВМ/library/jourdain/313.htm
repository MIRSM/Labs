<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 3. Kлавиатура.</p> <p class="hdr2">Раздел 1. Управление клавиатурой.</p> <p class="hdr3">3.1.3 Ожидать ввод символа и не выводить его на экран.</p> <p> Обычно вводимые символы выводятся на экран, чтобы было видно, что напечатано. Hо иногда автоматическое эхо на экране нежелательно. Hапример, выбор пункта меню по нажатию клавиши. Иногда надо сначала проверить вводимые символы на ошибку перед выводом на экран. В частности, любая программа, обрабатывающая расширенные коды, должна избегать автоматического эха, так как при этом первый байт этих кодов (ASCII 0) будет выводиться на экран, вставляя пробелы между символами. <p> Средний уровень. <p> Функции 7 и 8 прерывания 21H ожидают ввода символа, если буфер клавиатуры пуст, а когда он появляется, то не выводится на экран. При этом функция 8 определяет Ctrl-Break (и инициирует процедуру обработки Ctrl-Break{<a href="328.htm">3.2.8</a>}), а функция 7 не реагирует на него. В обоих случаях символ возвращается в AL. Kогда AL содержит ASCII 0, то получен расширенный код. Повторите прерывание и в AL появится второй байт расширенного кода. <table align="center"> <tr><td></td><td>;---получаем введенный символ</td></tr> <tr><td>MOV AH,7 </td><td>;номер функции</td></tr> <tr><td>INT 21H </td><td>;ожидаем ввод символа</td></tr> <tr><td>CMP AL,0 </td><td>;проверка на расширенный код</td></tr> <tr><td>JE EXTENDED_CODE </td><td>;если да, то на особую процедуру</td></tr> <tr><td>. </td><td>;иначе, код символа в AL</td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---процедура обработки расширенных кодов</td></tr> <tr><td>EXTENDED_CODE: INT 21H </td><td>;берем второй байт кода</td></tr> <tr><td>CMP AL,75 </td><td>;проверяем на "стрелку-влево"</td></tr> <tr><td>JNE C_R </td><td>;если нет, то след. проверка</td></tr> <tr><td>JMP CURSOR_LEFT</td><td>;если да, то на процедуру</td></tr> <tr><td>C_R: CMP AL,77 </td><td>;сравниваем дальше и т.д.</td></tr> </table> <p> BIOS обеспечивает процедуру, которая предоставляет те же возможности, что и функции MS DOS. Поместите 0 в AH и вызовите прерывание 16H. Функция ожидает ввода символа и возвращает его в AL. В этом случае и расширенные коды обрабатываются за одно прерывание. Если в AL содержится 0, то в AH будет содержаться номер расширенного кода. При это не обрабатывается Ctrl-Break. <table align="center"> <tr><td></td><td>;---ждем нажатия клавиши</td></tr> <tr><td>MOV AH,0 </td><td>;номер функции ожидания ввода</td></tr> <tr><td>INT 16H </td><td>;получаем введенный код</td></tr> <tr><td>CMP AL,0 </td><td>;проверка на расширенный код</td></tr> <tr><td>JE EXTENDED_CODE </td><td>;если да, то на спец. процедуру</td></tr> <tr><td>. </td><td>;иначе символ в AL</td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---процедура обработки расширенного кода</td></tr> <tr><td>EXTENDED_CODE: CMP AH,75 </td><td>;берем расширенный код из AH</td></tr> <tr><td></td><td>;и т.д.</td></tr> </table> <hr><p align="center">
<~-<a href="312.htm">3.1.2 Проверка символов в буфере.</a><br><a href="index.htm#header">Содержание</a><br><a href="314.htm">3.1.4 Ожидание нажатия клавиши и эхо на экран.</a>-~>
</p></body></html>
