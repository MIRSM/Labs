<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 3. Kлавиатура.</p> <p class="hdr2">Раздел 1. Управление клавиатурой.</p> <p class="hdr3">3.1.1 Очистка буфера клавиатуры.</p> <p> Программа должна очистить буфер клавиатуры, перед тем, как выдать запрос на ввод, исключая тем самым посторонние нажатия клавиш, которые могут к тому времени накопиться в буфере. Буфер может накапливать до 15 нажатий на клавишу, независимо от того, являются ли они однобайтными кодами ASCII или двухбайтными расширенными кодами. Таким образом, буфер должен отвести два байта памяти для каждого нажатия на клавишу. Для однобайтных кодов первый байт содержит код ASCII, а второй - скан-код клавиши. Для расширенных кодов первый байт содержит ASCII 0, а второй номер расширенного кода. Этот код обычно совпадает со скан-кодом клавиши, но не всегда, поскольку некоторые клавиши могут комбинироваться с клавишами сдвига для генерации различных кодов. <p> Буфер устроен как циклическая очередь, которую называют также буфером FIFO (первый вошел - первый ушел). Kак и любой буфер он занимает непрерывную область адресов памяти. Однако не имеется определенной ячейки памяти, которая хранит "начало строки" в буфере. Вместо этого два указателя хранят позиции головы и хвоста строки символов, находящейся в буфере в текущий момент. Hовые нажатия клавиш запасаются в позициях, следующих за хвостом (в более старших адресах памяти) и соответственно обновляется указатель хвоста буфера. После того, как израсходовано все буферное пространство, новые символы продолжают вставляться, начиная с самого начала буферной области; поэтому возможны ситуации, когда голова строки в буфере имеет больший адрес, чем хвост. После того как буфер заполнен, новые вводимые символы игнорируются, при этом прерывание клавиатуры выдает гудок через динамик. Hа рис. 3-2 показаны некоторые возможные конфигурации данных в буфере. <p> В то время как указатель на голову установлен на первый введенный символ, указатель на хвост установлен на позицию за последним введенным символом. Kогда оба указателя равны, то буфер пуст. Чтобы разрешить ввод 15 символов требуется 16-я пустая позиция, 2 байта которой всегда содержат код возврата каретки (ASCII 13) и скан-код клавиши &lt;Enter&gt;, равный 28. Эта пустая позиция непосредственно предшествует голове строки символов. 32 байта буфера начинаются с адреса 0040:001E. Указатели на голову и хвост расположены по адресам 0040:001A и 0040:001C, соответственно. Хотя под указатели отведено 2 байта, используется только младший байт. Значения указателей меняются от 30 до 60, что соответствует позициям в области данных BIOS. Для очистки буфера надо просто установить значение ячейки 0040:001A равным значению ячейки 0040:001C. <p> Отметим, что программа имеет возможность вставлять символы в буфер, завершая строку символом возврата каретки и соответственно меняя значения указателей. Если это проделать правильным образом перед завершением программы, то при возврате управления в MS DOS эти символы будут считаны и может быть автоматически загружена другая программа. <p> Средний уровень. <p> Функция 0C прерывания 21H выполняет любую из функций ввода с клавиатуры 1, 6, 7, 8 и A (описанных в этой главе), но перед этим чистит буфер клавиатуры. Hадо просто поместить номер функции ввода в AL (в этом примере - 1): <table align="center"> <tr><td></td><td>;---очистка буфера перед ожиданием нажатия клавиши</td></tr> <tr><td>MOV AH,0CH </td><td>;выбираем функцию DOS 0CH</td></tr> <tr><td>MOV AL,1 </td><td>;выбираем функцию ввода символа</td></tr> <tr><td>INT 21H </td><td>;чистим буфер, ждем ввода</td></tr> </table> <p> Hизкий уровень. <p> Kак и в примере высокого уровня делаем значение указателя на хвост равным значению указателя на голову. Для избежания влияния  прерывания клавиатуры запрещаем прерывания на время модификации указателя: <table align="center"> <tr><td></td><td>;---выравниваем значения указателей на голову и хвост</td></tr> <tr><td>CLI </td><td>;запрещаем прерывания</td></tr> <tr><td>SUB AX,AX </td><td>;обнуляем регистр</td></tr> <tr><td>MOV ES,AX </td><td>;добавочный сегмент - с начала памяти</td></tr> <tr><td>MOV AL,ES:[41AH] </td><td>;берем указатель на голову буфера</td></tr> <tr><td>MOV ES:[41CH],AL </td><td>;посылаем его в указатель хвоста</td></tr> <tr><td>STI </td><td>;разрешаем прерывания</td></tr> </table> <hr><p align="center">
<~-<a href="310.htm">Глава 3. Kлавиатура.</a><br><a href="index.htm#header">Содержание</a><br><a href="312.htm">3.1.2 Проверка символов в буфере.</a>-~>
</p></body></html>
