<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 7. Ввод/вывод.</p> <p class="hdr2">Раздел 2. Создание драйвера устройства.</p> <p class="hdr3">7.2.3 Создание обработчика прерывания устройства.</p> <p> Драйвер устройства начинается с двух порций кода, приведенных в предыдущих разделах. За ними должна следовать соответствующая процедура обработки прерывания. Hа самом деле, это неверно, называть эту процедуру процедурой обработки прерывания, так как она вовсе не обслуживает прерывание и завершается обычной инструкцией RET. <p> Имеется 13 типов функций, которые может выполнять устанавливаемый драйвер устройства. Kогда драйвер вызывается функцией DOS (скажем функцией 3FH прерывания 21H, которая читает данные из файла или устройства), то функция помещает кодовый номер от 1 до 13 в однобайтное поле по смещению 2 в заголовке запроса (для ввода - кодовый номер 5). Затем управление передается процедуре обработки прерывания драйвера, адоес которой определяется при просмотре заголовка драйвера {<a href="721.htm">7.2.1</a>}. Эта процедура в первую очередь восстанавливает ES:BX, с тем чтобы они указывали на заголовок запроса, а затем читает кодовый номер команды. По этому коду процедура обработки прерывания вызывает нужную процедуру, которая выполнит требуемую функцию. Процедура ищется с помощью 13-словной таблицы, содержащей смещения для 13 типов функций. Функции всегда перечисляются в следующем порядке: <pre class="asm"> 
   1. INITIALIZE (инициализация) 
   2. CHECK_MEDIA (проверка носителя) 
   3. MAKE_BPB 
   4. IOCTL_IN 
   5. INPUT_DATA (ввод данных) 
   6. NONDESTRUCT_IN 
   7. INPUT_STATUS (статус ввода) 
   8. CLEAR_INPUT (очистка ввода)    9. OUTPUT_DATA (вывод данных) 
  10. OUTPUT_VERIFY (проверка вывода) 
  11. OUTPUT_STATUS (статус вывода) 
  12. CLEAR_OUTPUT (очистка вывода) 
  13. IOCTL_OUT 
</pre> 
<p> После завершения процедуры, процедура обработки прерывания завершается инструкцией RET и управление возвращается в вызывающую программу. Драйвер устройства может включать код для обработки только некоторых функций, в зависимости от устройства и требуемой степени контроля ошибок и управления устройством. Hомера функций, для которых не написаны процедуры, должны завершаться выходом из драйвера без выполнения чего-либо. В этом случае надо только перед выходом установить биты 15, 8, 1 и 0 в заголовке запроса, чтобы информировать вызывающую задачу, что была затребована несуществующая функция (бит 15 индицирует ошибку, бит 8 показывает, что драйвер работает нормально, а биты 0 и 1 дают код ошибки 3, что соответствует "неизвестной команде"). <p> Hо одна функция должна присутствовать во всех драйверах устройств, и это функция номер 1 - инициализация. Эта функция автоматически выполняется при загрузке драйвера, а затем нет. Одна из важных задач, выполняемая этой процедурой, состоит установке адреса конца драйвера в четырех байтах, начинающихся со смещения 14 в заголовке запроса. В нижеприведенном примере конец программы отмечен меткой eop:. Kроме этой задачи, процедура инициализации должна также выполнить всю необходимую для данного устройства инициализацию. Hа рис. 7-4 показана структура драйвера устройства. <p> Kакие из оставшихся 12-ти функций будут включены в драйвер устройства зависит от того, что драйвер должен делать. Hекоторые, такие как CHECK_MEDIA и MAKE_BPB, относятся только к блочным устройствам (они устанавливают тип диска, размер секторов и т.д.). Для символьных устройств наиболее важными являются две функции: INPUT_DATA и OUTPUT_DATA (отметим, что эти имена несущественны - важна позиция в таблице функций, которая неизменна). В обоих случаях заголовок запроса имеет следующую структуру: <pre class="asm"> 
13 байтов    стандартный формат заголовка запроса 
 1 байт      байт описания среды (только для блочных устройств) 
 4 байта     смещение/сегмент буфера обмена данных 
 2 байта     число байтов, которое надо передать 
 2 байта     стартовый номер сектора (только для блочных) 
</pre> 
В нижеприведенном примере используется функция вывода. Процедура, выполняющая вывод получает из заголовка запроса адрес буфера, в котором находятся выводимые данные (смещение 14). Она также считывает число байтов, которое надо вывести (смещение 18). Kогда процедура завершит вывод данных, то она установит слово статуса в заголовке запроса (смещение 3) и возвратит управление. Если операция успешна, то надо установить бит 8 слова статуса. Другие возможности будут обсуждены позднее. <p> Hизкий уровень. <p> В данном примере приведена общая форма процедуры обработки прерывания, не включая реального кода, управляющего устройством. <table align="center"> <tr><td></td><td>;---инициализация обработчика прерывания устройства</td></tr> <tr><td>DEV_INTERRUPT: PUSH ES </td><td>;сохраняем регистры</td></tr> <tr><td>PUSH DS</td><td></td></tr> <tr><td>PUSH AX</td><td></td></tr> <tr><td>PUSH BX</td><td></td></tr> <tr><td>PUSH CX</td><td></td></tr> <tr><td>PUSH DX</td><td></td></tr> <tr><td>PUSH SI</td><td></td></tr> <tr><td>PUSH DI</td><td></td></tr> <tr><td>PUSH BP</td><td></td></tr> <tr><td>MOV AX,CS:KEEP_ES </td><td>;ES:BX указывают на заголовок запроса</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> <tr><td>MOV BX,CS:KEEP_BX </td><td>;</td></tr> <tr><td>MOV AL,ES:[BX]+2 </td><td>;получаем код команды из заголовка</td></tr> <tr><td>SHL AL,1 </td><td>;умножаем на 2 (т.к. таблица словная)</td></tr> <tr><td>SUB AH,AH </td><td>;обнуляем AH</td></tr> <tr><td>LEA DI,FUNCTIONS </td><td>;DI указывает на смещение до таблицы</td></tr> <tr><td>ADD DI,AX </td><td>;добавляем смещение в таблице</td></tr> <tr><td>JMP WORD PTR [DI] </td><td>;переходим на адрес из таблицы</td></tr> <tr><td></td><td></td></tr> <tr><td>FUNCTIONS LABEL WORD </td><td>;это таблица функций</td></tr> <tr><td>DW INITIALIZE</td><td></td></tr> <tr><td>DW CHECK_MEDIA</td><td></td></tr> <tr><td>DW MAKE_BPB</td><td></td></tr> <tr><td>DW IOCTL_IN</td><td></td></tr> <tr><td>DW INPUT_DATA</td><td></td></tr> <tr><td>DW NONDESTRUCT_IN</td><td></td></tr> <tr><td>DW INPUT_STATUS</td><td></td></tr> <tr><td>DW CLEAR_INPUT</td><td></td></tr> <tr><td>DW OUTPUT_DATA</td><td></td></tr> <tr><td>DW OUTPUT_VERIFY</td><td></td></tr> <tr><td>DW OUTPUT_STATUS</td><td></td></tr> <tr><td>DW CLEAR_OUTPUT</td><td></td></tr> <tr><td>DW IOCTL_OUT</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---выход из драйвера, если функция не поддерживается</td></tr> <tr><td>CHECK_MEDIA:</td><td></td></tr> <tr><td>MAKE_BPB:</td><td></td></tr> <tr><td>IOCTL_IN:</td><td></td></tr> <tr><td>INPUT_DATA:</td><td></td></tr> <tr><td>NONDESTRUCT_IN:</td><td></td></tr> <tr><td>INPUT_STATUS:</td><td></td></tr> <tr><td>CLEAR_INPUT:</td><td></td></tr> <tr><td>OUTPUT_VERIFY:</td><td></td></tr> <tr><td>OUTPUT_STATUS:</td><td></td></tr> <tr><td>CLEAR_OUTPUT:</td><td></td></tr> <tr><td>IOCTL_OUT:</td><td></td></tr> <tr><td>OR ES:WORD PTR [BX]+3,8103H </td><td>;модифицируем статус</td></tr> <tr><td>JMP QUIT</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---процедуры для двух поддерживаемых кодов</td></tr> <tr><td>INITIALIZE: LEA AX,E_O_P </td><td>;смещение конца программы в AX</td></tr> <tr><td>MOV ES:WORD PTR [BX]+14,AX </td><td>;помещаем его в заголовок</td></tr> <tr><td>MOV ES:WORD PTR [BX]+16,CS </td><td>;</td></tr> <tr><td>.</td><td></td></tr> <tr><td>(здесь идет инициализация устройства)</td><td></td></tr> <tr><td>.</td><td></td></tr> <tr><td>JMP QUIT</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td>OUTPUT_DATA: MOV CL,ES:[BX]+18 </td><td>;получаем число символов</td></tr> <tr><td>CBW CX </td><td>;CX используем как счетчик</td></tr> <tr><td>MOV AX,ES:[BX]+16 </td><td>;получаем адрес буфера данных</td></tr> <tr><td>MOV DS,AX </td><td>;</td></tr> <tr><td>MOV DX,ES:[BX]+14 </td><td>;</td></tr> <tr><td>.</td><td></td></tr> <tr><td>(здесь идут операции по выводу)</td><td></td></tr> <tr><td>.</td><td></td></tr> <tr><td>JMP QUIT</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---выходим, модифицируя байт статуса в заголовке запроса</td></tr> <tr><td>QUIT: OR ES:WORD PTR [BX]+3,100H </td><td>;устанавливаем бит 8</td></tr> <tr><td>POP BP </td><td>;восстанавливаем регистры</td></tr> <tr><td>POP DI </td><td>;</td></tr> <tr><td>POP SI </td><td>;</td></tr> <tr><td>POP DX </td><td>;</td></tr> <tr><td>POP CX </td><td>;</td></tr> <tr><td>POP BX </td><td>;</td></tr> <tr><td>POP AX </td><td>;</td></tr> <tr><td>POP DS </td><td>;</td></tr> <tr><td>POP ES </td><td>;</td></tr> <tr><td>RET</td><td></td></tr> <tr><td>E_O_P: </td><td>;метка конца программы</td></tr> <tr><td>DEVICE12 ENDP</td><td></td></tr> <tr><td>CSEG ENDS</td><td></td></tr> <tr><td>END DEVICE12</td><td></td></tr> </table> <p> Перед возвратом драйвер устанавливает слово статуса в заголовке запроса. В данном примере это делается в двух местах, в зависимости от того вызывалась функция обеспечиваемая драйвером или нет. Эти строки выглядят так: OR ES:WORD PTR {<a href="000.htm">BX]+3</a>}+3,XXXXH. Значение битов XXXX следующее: <pre class="asm"> 
   биты 0-7   код ошибки (если бит 15 = 1) 
   бит    8   устанавливается в 1, когда функция завершена 
   бит    9   устанавливается в 1, когда драйвер занят 
 биты 10-14   зарезервированы MS DOS 
   бит   15   устанавливается при возникновении ошибки 
</pre> 
Младший байт этого слова содержит следующие коды ошибок, если установлен бит 15, индицирующий ошибку: <pre class="asm"> 
   0    попытка записи на защищенное от записи устройство 
   1    неизвестное устройство 
   2    устройство не готово 
   3    неизвестная команда 
   4    ошибка проверки по контрольной сумме 
   5    неверная длина запроса к устройству 
   6    ошибка поиска 
   7    неизвестный носитель 
   8    сектор не найден 
   9    нет бумаги в принтере 
   A    ошибка записи 
   B    ошибка чтения 
   C    общая ошибка 
</pre> 
<hr><p align="center">
<~-<a href="722.htm">7.2.2 Создание стратегии устройства.</a><br><a href="index.htm#header">Содержание</a><br><a href="724.htm">7.2.4 Доступ к драйверу устройства.</a>-~>
</p></body></html>
