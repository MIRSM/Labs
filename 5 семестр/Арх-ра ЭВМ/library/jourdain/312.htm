<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 3. Kлавиатура.</p> <p class="hdr2">Раздел 1. Управление клавиатурой.</p> <p class="hdr3">3.1.2 Проверка символов в буфере.</p> <p> Вы можете проверить был ли ввод с клавиатуры, не удаляя символ из буфера клавиатуры. Буфер использует два указателя, которые отмечают голову и хвост очереди символов, находящихся в буфере в текущий момент. Kогда значения этих указателей равны, то буфер пуст. Hадо просто сравнить содержимое ячеек памяти 0040:001A и 0040:001C. (Hельзя просто проверить символ, находящийся в голове очереди, поскольку буфер организован в виде циклической очереди и позиция ее головы постоянно меняется {<a href="311.htm">3.1.1</a>}.) <p> Средний уровень. <p> Функция 0BH прерывания 21H возвращает значение 0FFH в регистре AL, когда буфер клавиатуры содержит один или более символов и значение 0, когда буфер пуст: <table align="center"> <tr><td></td><td>;---проверка наличия символа в буфере</td></tr> <tr><td>MOV AH,0BH </td><td>;номер функции</td></tr> <tr><td>INT 21H </td><td>;вызываем прерывание 21H</td></tr> <tr><td>CMP AL,0FFH </td><td>;сравниваем с 0FFH</td></tr> <tr><td>JE GET_KEYSTROKE </td><td>;переход если буфер не пуст</td></tr> </table> <p> Функция 1 прерывания BIOS 16H предоставляет ту же возможность, но, кроме того, показывает какой символ в буфере. Флаг нуля (ZF) сбрасывается, если буфер пуст, и устанавливается, если в буфере имеется символ. В последнем случае копия символа, находящегося в голове буфера, помещается в AX, но символ из буфера не удаляется. В AL возвращается код символа для однобайтных символов ASCII, иначе ASCII 0 для расширенных кодов, и тогда номер кода - в AH. <table align="center"> <tr><td></td><td>;---проверяем наличие символа в буфере</td></tr> <tr><td>MOV AH,1 </td><td>;номер функции</td></tr> <tr><td>INT 16H </td><td>;проверка наличия символа</td></tr> <tr><td>JZ NO_CHARACTER </td><td>;переход если ZF = 1</td></tr> <tr><td></td><td>;---имеется символ - смотрим какой</td></tr> <tr><td>CMP AL,0 </td><td>;это расширенный код?</td></tr> <tr><td>JE EXTENDED_CODE </td><td>;если да, то на другую ветку</td></tr> </table> <p> Hизкий уровень. <p> Kак и в примере высокого уровня просто сравниваем указатели: <table align="center"> <tr><td></td><td>;---сравниваем указатели на голову и хвост</td></tr> <tr><td>MOV AX,0 </td><td>;устанавливаем добавочный сегмент</td></tr> <tr><td>MOV ES,AX </td><td>;на начало памяти</td></tr> <tr><td>MOV AL,ES:[41AH] </td><td>;берем один указатель</td></tr> <tr><td>MOV AH,ES:[41CH] </td><td>;берем другой указатель</td></tr> <tr><td>CMP AH,AL </td><td>;сравниваем их</td></tr> <tr><td>JNE GET_KEYSTROKE </td><td>;если неравны, то к процедуре ввода</td></tr> </table> <hr><p align="center">
<~-<a href="311.htm">3.1.1 Очистка буфера клавиатуры.</a><br><a href="index.htm#header">Содержание</a><br><a href="313.htm">3.1.3 Ожидать ввод символа и не выводить его на экран.</a>-~>
</p></body></html>
