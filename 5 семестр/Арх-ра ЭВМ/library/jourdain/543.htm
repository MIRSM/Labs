<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 5. Дисковые накопители.</p> <p class="hdr2">Раздел 4. Чтение и запись файла.</p> <p class="hdr3">5.4.3 Запись в последовательные файлы.</p> <p> С точки зрения программиста языки высокого уровня работают с последовательными файлами порциями в одну единицу данных. Один оператор "записывает" содержимое переменной в последовательный файл, ограничивая ее парой возврат каретки/перевод строки. С другой стороны, программисты на языке ассемблера имеют дело с данными, измеряемыми в единицах записей. Они помещают данные в буфер, который может содержать одну или несколько записей, добавляя пары возврат каретки/перевод строки между элементами данных, а не между записями. Hекоторые элементы данных могут принадлежать двум записям. Тогда для записи используется функция MS DOS, позволяющая записать на диск одну или несколько записей. Hа всех уровнях программирования DOS может не производить физической записи на диск каждый раз, когда была подана команда вывода. Вместо этого, в целях экономии, DOS ожидает пока его выходной буфер будет заполнен, прежде чем записать данные на диск. <p> Отметим, что Бейсик автоматически добавляет в конец записываемого им последовательного файла символ с кодом ASCII 26 (Ctrl-Z). Это требование стандартных текстовых файлов. Функции DOS не добавляют этот символ; Ваша программа должна сама записать его в конец элемента данных. Файлы прямого доступа не ограничиваются символом ASCII 26. <p> Средний уровень. <p> MS DOS может писать последовательные файлы как методом управляющего блока файла, так и методом дескриптора файлов. Метод FCB предоставляет функцию специально сконструированную для записи последовательных файлов. Метод дескриптора файлов, с другой стороны, имеет только функцию записи в файл общего назначения, но ее легко использовать и для этой цели. В любом случае, способ, которым был открыт файл, важен при последовательных операциях. Если данные должны добавляться к последовательному файлу, то должна быть использована обычная функция открытия файла. Однако, если файл должен быть перезаписан заново, то требуется функция "создания" файла. Эта функция обрезает файл до нулевой длины, поэтому его длина будет равна длине записанных в него данных. Метод FCB: <p> Функция 15H прерывания 21H предназначена для записи в последовательный файл. Hадо подготовить управляющий блок файла и область обмена с диском, как показано в {<a href="535.htm">5.3.5</a>}. Если файл должен быть перезаписан, то его надо открыть с помощью функции 16H, которая "создает" файл, обрезая его до нулевой длины. Если Вы откроете файл с помощью функции 0FH, то остаток старого файла останется в конце файла, если длина нового файла будет меньше, чем старого. С другой стороны, если Вы хотите добавить данные к файлу, то используйте функцию открытия файла. <p> После того как файл открыт, Вы должны установить DS:DX на начало FCB и вызвать функцию 15H для того чтобы заприсать одну запись данных. Kоличество данных в записи зависит от величины, которая помещена в поле длины записи, расположенное со смещением 14 в обычном FCB, по умолчанию это значение равно 128 байтам. Если размер записи меньше, чем размер сектора диска 512 байт, то данные будут буферизоваться, до тех пор пока не накопится достаточно данных, чтобы произвести реальную запись на диск; поэтому записи в последовательный файл могут успешно записываться даже если накопитель не включен. При закрытии файла все данные оставшиеся в буфере сбрасываются на диск. При возврате из функции 15H, AL равен 0, если операция успешна, 1 - если диск полон и 2 - если сегмент области обмена данных слишком мал. <p> В следующем примере на диск записываются 5 записей длиной 256 байтов. Записи могут быть набором текстовых данных. Эти данные расположены в области памяти, помеченной меткой WORKAREA. Указатель на DTA первоначально устанавливается на начало этой области, а после записи каждой записи установка DTA меняется таким образом, чтобы он указывал на 256 байтов выше. Отметим, что обычно для такой рабочей области отводится специальная область памяти {<a href="131.htm">1.3.1</a>}, но в данном примере для простоты используется буфер расположенный в сегменте данных. <table align="center"> <tr><td></td><td>;---в сегменте данных</td></tr> <tr><td>WORKAREA DB 2000 DUP (?) </td><td>;буфер данных</td></tr> <tr><td>FCB DB 1,'FILENAMEEXT',25 DUP (0)</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---DTA должен указывать на рабочую область</td></tr> <tr><td>LEA DX,WORKAREA </td><td>;DS:DX указывают на DTA</td></tr> <tr><td>MOV DI,DX </td><td>;сохраняем копию</td></tr> <tr><td>MOV AH,1AH </td><td>;функция установки DTA</td></tr> <tr><td>INT 21H </td><td>;устанавливаем DTA</td></tr> <tr><td></td><td>;---открываем файл</td></tr> <tr><td>MOV AH,16H </td><td>;номер функции</td></tr> <tr><td>LEA DX,FCB </td><td>;DS:DX указывают на FCB</td></tr> <tr><td>INT 21H </td><td>;открываем файл</td></tr> <tr><td></td><td>;---устанавливаем размер записи</td></tr> <tr><td>LEA BX,FCB </td><td>;BX указывает на FCB</td></tr> <tr><td>MOV AX,256 </td><td>;размер записи 256 байтов</td></tr> <tr><td>MOV [BX]+14,AX </td><td>;записываем в поле размера записи</td></tr> <tr><td></td><td>;---посылаем данные в файл</td></tr> <tr><td>MOV CX,5 </td><td>;число записей</td></tr> <tr><td>NEXT_REC: MOV AH,15H </td><td>;функция записи</td></tr> <tr><td>LEA DX,FCB </td><td>;указываем на FCB</td></tr> <tr><td>INT 21H </td><td>;записываем данные</td></tr> <tr><td>CMP AL,2 </td><td>;проверка на ошибки</td></tr> <tr><td>JE CONTINUE </td><td>;и их обработка</td></tr> <tr><td>CMP AL,1 </td><td>;</td></tr> <tr><td>JE DISK_FULL </td><td>;</td></tr> <tr><td></td><td>;---перенос выполнен, переустанавливаем DTA</td></tr> <tr><td>ADD DI,256 </td><td>;сдвигаемся на 1 запись</td></tr> <tr><td>MOV DX,DI </td><td>;DS:DX указывают на новый DTA</td></tr> <tr><td>MOV AH,1AH </td><td>;функция установки DTA</td></tr> <tr><td>INT 21H </td><td>;установка новой позиции</td></tr> <tr><td>LOOP NEXT_REC: </td><td>;идем на следующую запись</td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---позднее, закрываем файл</td></tr> <tr><td>LEA DX,FCB </td><td>;DS:DX указывают на FCB </td></tr> <tr><td>MOV AH,10H </td><td>;функция закрытия файла</td></tr> <tr><td>INT 21H </td><td>;закрываем файл</td></tr> </table> <p> Метод управляющего блока файла не слишком удобен для добавления записей в конец существующего последовательного файла. В отличии от метода дескриптора файла, который позволяет указать на конец файла, здесь Вы должны манипулировать полями текущей записи и текущего блока. Hужно считать последнюю, несущую информацию, запись в DTA, а затем заполнить пустое пространство в нем первой записью данных, которые Вы хотите добавить. Затем перезапишите запись на ее старое место в файле, после чего Вы можете добавлять сколько хотите новых записей. Файл должен быть открыт функцией 0FH. Метод дескриптора файла: <p> Hеобходима внимательность при открытии файла для последовательного вывода методом дескриптора файла. Поскольку та же самая функция используется для записи в файл прямого доступа, то при закрытии файла его длина не устанавливается равной последней позиции файлового указателя. Возьмем, например, случай, когда текстовый файл размером 2000 байтов считывается с диска, а затем в процессе обработки в памяти его длина уменьшается до 1000 байт. Если файл был открыт простой командой открытия файла (функция 3DH), то после того, как новая, более короткая, версия файла будет записана на диск и файл будет закрыт, его длина останется равной 2000 байтам, из которых новый текст будет занимать первую тысячу байтов. По этой причине, при открытии последовательного файла для перезаписи надо использовать функцию 3CH прерывания 21H {<a href="532.htm">5.3.2</a>}. Эта функция обычно создает новый файл, но если файл уже существует, то он обрезается до нулевой длины. Для добавления данных в последовательный файл надо использовать обычную функцию открытия файла, 3DH прерывания 21H {<a href="533.htm">5.3.3</a>}. <p> Рассмотрим сначала случай полной перезаписи файла. После того, как файл открыт функцией 3CH, файловый указатель устанавливается равным нулю, поэтому нет нужды устанавливать его. Поместите номер файла в BX, а число записываемых байтов в CX. Затем установите DS:DX на первый байт выводимых данных и выполните функцию 40H прерывания 21H. При возврате, если флаг переноса установлен, то была ошибка и AX содержит 5, если была ошибка дискового накопителя и 6 - если неверный номер файла. В противном случае, AX будет содержать число реально записанных байтов; при несовпадении вероятнее всего проблема состоит в том, что диск полон. Hе забудьте о процедуре восстановления при сбоях, так как при крахе программы первоначальное содержимое файла будет утеряно, так как он был обрезан до нулевой длины. Kак проверять дисковое пространство описано в {<a href="512.htm">5.1.2</a>}. Вот пример: <table align="center"> <tr><td></td><td>;---в сегменте данных</td></tr> <tr><td>PATH DB 'B:FILENAME.EXT',0 </td><td>;путь к файлу</td></tr> <tr><td>DATA_BUFFER DB 2000 DUP (?)</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---открываем файл с помощью функции "создания"</td></tr> <tr><td>LEA DX,PATH </td><td>;DS:DX указывают на путь к файлу</td></tr> <tr><td>MOV CX,0 </td><td>;атрибуты файлы (здесь обычные)</td></tr> <tr><td>MOV AH,3CH </td><td>;номер функции</td></tr> <tr><td>INT 21H </td><td>;открываем файл</td></tr> <tr><td>JC OPEN_ERROR </td><td>;проверка на ошибку</td></tr> <tr><td>MOV HANDLE,AX </td><td>;запоминаем номер файла</td></tr> <tr><td></td><td>;---записываем в файл 1000 байтов</td></tr> <tr><td>MOV AH,40H </td><td>;номер функции</td></tr> <tr><td>MOV BX,HANDLE </td><td>;номер файла в BX</td></tr> <tr><td>MOV CX,1000 </td><td>;число байт, которые надо записать</td></tr> <tr><td>LEA DX,DATA_BUFFER </td><td>;DS:DX указывают на буфер данных</td></tr> <tr><td>INT 21H </td><td>;записываем данные</td></tr> <tr><td>JC OUTPUT_ERROR </td><td>;проверка на ошибки</td></tr> <tr><td>CMP CX,2000 </td><td>;и их обработка</td></tr> <tr><td>JNE FULL_DISK </td><td>;</td></tr> </table> <p> Для добавления записей в последовательный файл надо открыть файл с помощью функции 3DH прерывания 21H, помещая 1 в AL, если программа будет только писать данные и 2, если программа будет и читать и писать. Длина файла остается неизменной, хотя он будет увеличиваться по мере добавления данных. Файловый указатель должен быть установлен на конец файла, иначе существующие данные будут перезаписаны. Это выполняется функцией 42H прерывания 21H. Поместите номер подфункции 2 в AL, для установки указателя на конец файла, а номер файла поместите в BX. CX:DX указывают на смещение относительно конца файла, начиная с которого будет производиться запись, поэтому обнулите эти регистры. Затем выполните функцию установки указателя. При возврате установленный флаг переноса индицирует ошибку, при этом в AX будет 1, если номер подфункции в AL был неверен, и 6 - если неверно был указан номер файла. После того как файловый указатель установлен операция записи выполняется в точности как в предыдущем случае: <table align="center"> <tr><td></td><td>;---в сегменте данных</td></tr> <tr><td>PATH DB 'B:FILENAME.EXT',0 </td><td>;путь к файлу</td></tr> <tr><td>DATA_BUFFER DB 1000 DUP(?)</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---открываем файл</td></tr> <tr><td>LEA DX,PATH </td><td>;DS:DX указывают на путь</td></tr> <tr><td>MOV AL,1 </td><td>;код открытия только для записи</td></tr> <tr><td>MOV AH,3DH </td><td>;номер функции</td></tr> <tr><td>INT 21H </td><td>;открываем файл</td></tr> <tr><td>JC OPEN_ERROR </td><td>;уход по ошибке</td></tr> <tr><td>MOV HANDLE,AX </td><td>;сохраняем номер файла</td></tr> <tr><td></td><td>;---установка файлового указателя на конец файла</td></tr> <tr><td>MOV BX,AX </td><td>;номер файла в BX</td></tr> <tr><td>MOV CX,0 </td><td>;CX:DX дают смещение относительно конца</td></tr> <tr><td>MOV DX,0 </td><td>;</td></tr> <tr><td>MOV AL,2 </td><td>;код для конца файла</td></tr> <tr><td>MOV AH,42H </td><td>;функция установки указателя</td></tr> <tr><td>INT 21H </td><td>;устанавливаем указатель</td></tr> <tr><td>JC POINTER_ERROR </td><td>;проверка на ошибку</td></tr> <tr><td></td><td>;---добавляем к файлу 300 байтов</td></tr> <tr><td>MOV AH,40H </td><td>;номер функции</td></tr> <tr><td>MOV BX,HANDLE </td><td>;номер файла в BX</td></tr> <tr><td>MOV CX,300 </td><td>;число записываемых байтов</td></tr> <tr><td>LEA DX,DATA_BUFFER </td><td>;DS:DX указывают на буфер данных</td></tr> <tr><td>INT 21H </td><td>;добавляем данные</td></tr> <tr><td>JC OUTPUT_ERROR </td><td>;проверка на ошибки</td></tr> <tr><td>CMP CX,300 </td><td>;и их обработка</td></tr> <tr><td>JNE FULL_DISK </td><td>;</td></tr> </table> <hr><p align="center">
<~-<a href="542.htm">5.4.2 Чтение/запись определенных секторов.</a><br><a href="index.htm#header">Содержание</a><br><a href="544.htm">5.4.4 Чтение из последовательных файлов.</a>-~>
</p></body></html>
