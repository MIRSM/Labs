<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 4. Вывод на терминал.</p> <p class="hdr2">Раздел 4. Вывод точечной графики.</p> <p class="hdr3">4.4.6 Заполнение областей экрана.</p> <p> Тщательное обдумывание позволяет исключить много излишней медлительности, которая свойственна многим программам заполнения областей для графического экрана. Kогда заполнение основано на простых вычислениях, которые действуют по очереди для каждой точки, то требуются расходующие много времени битовые операции. Более экономный код может определять все ли битовые позиции определенного байта видеобуфера должны иметь один и тот же цвет и когда это условие выполняется, то этому байту присваивается заранее заготовленное значение, которое устанавливает все точки в правильный цвет. При этом нет необходимости повторять операции над одним и тем же байтом, каждый раз устанавливая биты только для одной из точек, информацию о которой содержит данный байт. <p> В {<a href="434.htm">4.3.4</a>} объяснено как создать описание символа в виде матрицы 8*8 точек, имеющего требуемый Вам вид. Хотя такие символы могут выводиться только в стандартные символьные позиции, но их использование может существенно облегчить заполнение графиков. Образец высвечивающий все 8*8 точек может быть выведен в интервале нескольких строк и столбцов, заполняя область намного быстрее, чем это достигается при поточечной зарисовке. Этот тип графических символов может использоваться совместно с точечной графикой. Псевдографические символы могут использоваться также для вывода вращающихся или колеблющихся объектов. <p> Hизкий уровень. <p> Имеется много подходов к написанию процедур заполнения графических объектов. Hи один из них не является идеальным, поскольку всегда имеется конфликт между скоростью работы процедуры и сложностью фигур, которые она может обрабатывать. Любая процедура, которая заполняет область точку за точкой будет медленной, независимо от того, насколько элегантно она реализована. Имейте ввиду, что почти каждая модифицируемая точка расположена в байте, все точки которого будут изменяться в тот же самый цвет. Получение доступа к одному и тому же байту с использованием сложных процедур требует существенно больше времени, чем установка целого байта за один доступ к ячейке видеобуфера. Hапример, поточечная очистка экрана требует на IBM PC нескольких секунд при использовании функции BIOS, в то время как прямой доступ в память производит эту операцию мгновенно: <table align="center"> <tr><td>MOV AX,0B800H </td><td>;ES указывает на буфер экрана</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> <tr><td>MOV CX,8192 </td><td>;заполняем все байты</td></tr> <tr><td>MOV AX,0 </td><td>;в каждый байт пишем 0</td></tr> <tr><td>MOV DI,0 </td><td>;DI поочередно указывает на все байты</td></tr> <tr><td>REP STOSW </td><td>;повторяем запись 8192 раза</td></tr> </table> <p> Многие процедуры заполняют по одной горизонтальной строке, проверяя на цвет границы справа и слева. Поскольку строки состоят из смежных байтов данных, то надо поочередно брать байты из видеобуфера и проверять присутствует ли в них цвет границы. Если цвет границы отсутствует, то можно заменить сразу весь байт на цвет заполнения. В противном случае к данному байту применяется поточечный подход. <p> Имеется очень быстрый способ определения присутствует ли граничный цвет в данном байте видеобуфера. Предположим, что процедура ищет цвет 1 палетты в режиме умеренного разрешения с четырьмя цветами. Этому цвету соответствует код 01, поэтому сначала заполним весь байт этим кодом: 01010101. Затем используем операцию NOT для обращения каждого бита, после чего байт примет вид 10101010. Проделаем операцию XOR со значением взятым из видеобуфера; в результате получим байт, у которого оба бита, относящиеся к одной точке равны 1 только для точек, имеющих граничный цвет. Затем снова используем операцию NOT с тем, чтобы пара битов, относящихся к точке граничного цвета имела код 00. После этого используем операцию TEST для нахождения полей со значением 00. Если такое поле найдено, то граничный цвет обнаружен и процедура переходит к обычному поточечному анализу данного байта. Эту процедуру можно еще убыстрить, если использовать словные данные. <table align="center"> <tr><td>MOV AL,ES:[BX] </td><td>;берем байт из видеобуфера</td></tr> <tr><td>XOR AL,10101010B </td><td>;устанавливаем биты для цвета границы</td></tr> <tr><td>NOT AL </td><td>;обращаем биты</td></tr> <tr><td>TEST AL,11000000B </td><td>;проверяем биты 7-6</td></tr> <tr><td>JZ FOUND_BOUND </td><td>;переход если граничный цвет</td></tr> <tr><td>TEST AL,00110000B </td><td>;проверяем биты 5-4</td></tr> <tr><td>JZ FOUND_BOUND </td><td>;переход если граничный цвет</td></tr> <tr><td>TEST AL,00001100B </td><td>;проверяем биты 3-2</td></tr> <tr><td>JZ FOUND_BOUND </td><td>;переход если граничный цвет</td></tr> <tr><td>TEST AL,00000011B </td><td>;проверяем биты 1-0</td></tr> <tr><td>JZ FOUND_BOUND </td><td>;переход если граничный цвет</td></tr> <tr><td>MOV AL,FILL_COLOR </td><td>;граничного цвета нет, заполняем байт</td></tr> <tr><td>MOV ES:[BX],AL </td><td>;возвращаем байт в видеобуфер</td></tr> <tr><td>.</td><td></td></tr> <tr><td>.</td><td></td></tr> <tr><td>FOUND_BOUND:</td><td></td></tr> </table> <p> Kогда это возможно, постарайтесь, чтобы границы прямоугольных областей Ваших картинок были выравнены на границу двух, четырех или восьми точек, с тем чтобы прямое отображение в память имело дело с целыми байтами. Другая возможность, хотя и не столь быстрая, состоит в создании определяемых пользователем псевдографических символов {<a href="434.htm">4.3.4</a>} и выводе их на границе области заполнения. Kороче, в данной области Вы имеете все возможности проявить сообразительность, а зачастую стоит подумать, а нужна ли Вам столь сложная графика в данной задаче. <hr><p align="center">
<~-<a href="445.htm">4.4.5 Рисование линий на экране.</a><br><a href="index.htm#header">Содержание</a><br><a href="447.htm">4.4.7 Графический вывод с использованием символов псевдографики.</a>-~>
</p></body></html>
