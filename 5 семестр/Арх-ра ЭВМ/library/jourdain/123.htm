<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 1. Системные ресурсы.</p> <p class="hdr2">Раздел 2. Управление прерываниями.</p> <p class="hdr3">1.2.3 Hаписание собственного прерывания.</p> <p> Имеется несколько причин для написания собственного прерывания. Во-первых, большинство из готовых прерываний, обеспечиваемых операционной системой, ничто иное, как обычные процедуры, доступные для всех программ, и Вы можете пожелать добавить свое в эту библиотеку. Hапример, многие Ваши программы могут использовать процедуру, выводящую строки на экран вертикально. Вместо того, чтобы включать ее в каждую программу в качестве процедуры Вы можете установить ее как прерывание, написав программу, которая останется резидентной в памяти после завершения {<a href="134.htm">1.3.4</a>}. Тогда Вы можете использовать INT 80H вместо WRITE_VERTICALLY (имейте ввиду, что вызов прерывания несколько медленней, чем вызов процедуры). <p> Второй причиной написания прерывания может быть использование какого-либо отдельного аппаратного прерывания. Это прерывание автоматически вызывается при возникновении определенных условий. В некоторых случаях BIOS инициализирует вектор этого прерывания так, что он указывает на процедуру, которая вообще ничего не делает (она содержит один оператор IRET). Вы можете написать свою процедуру и изменить вектор прерываний, чтобы он указывал на нее. Тогда при возникновении аппаратного прерывания будет выполняться Ваша процедура. Одна из таких процедур это прерывание времени суток {<a href="210.htm">2.1.0</a>}, которое автоматически вызывается 18.2 раза в секунду. Обычно это прерывание только обновляет показание часов, но Вы можете добавить к нему любой код, который Вы пожелаете. Если Ваш код проверяет показания часов и вступает в игру в определенные моменты времени, то возможны операции в реальном времени. Другие возможности - это написание процедур обработки Ctrl-Break {<a href="328.htm">3.2.8</a>}, PrtSC {<a href="329.htm">3.2.9</a>} и возникновения ошибочных ситуаций {<a href="725.htm">7.2.5</a>}. Прерывания принтера {<a href="631.htm">6.3.1</a>} и коммуникационные {<a href="718.htm">7.1.8</a>} позволяют компьютеру быстро переключаться между операциями ввода/вывода и другой обработкой. <p> Hаконец, Вы можете захотеть написать прерывание, которое полностью заменит одну из процедур операционной системы, приспособленное к Вашим программным нуждам. В {<a href="124.htm">1.2.4</a>} показано как написать прерывание внутри прерывания, которое позволяет Вам модифицировать существующие процедуры. <p> Средний уровень. <p> Функция 25H прерывания 21H устанавливает вектор прерывания на указанный адрес. Адреса имеют размер два слова. Старшее слово содержит значение сегмента (CS), младшее содержит смещение (IP). Чтобы установить вектор, указывающим на одну из Ваших процедур, нужно поместить сегмент процедуры в DS, а смещение в DX (следуя порядку нижеприведенного примера). Затем поместите номер прерывания в AL и вызовите функцию. Любая процедура прерывания должна завершаться не обычной инструкцией RET, а IRET. (IRET выталкивает из стека три слова, включая регистр флагов, в то время как RET помещает на стек только два. Если Вы попытаетесь тестировать такую процедуру как обычную процедуру, но кончающуюся IRET, то Вы исчерпаете стек.) Отметим, что функция 25H автоматически запрещает аппаратные прерывания в процессе изменения вектора, поэтому не существует опасности, что посреди дороги произойдет аппаратное прерывание, использующее данный вектор. <table align="center"> ;---установка прерывания <tr><td>PUSH DS </td><td>;сохраняем DS</td></tr> <tr><td>MOV DX,OFFSET ROUT </td><td>;смещение для процедуры в DX</td></tr> <tr><td>MOV AX,SEG ROUT </td><td>;сегмент процедуры</td></tr> <tr><td>MOV DS,AX </td><td>;помещаем в DS</td></tr> <tr><td>MOV AH,25H </td><td>;функция установки вектора</td></tr> <tr><td>MOV AL,60H </td><td>;номер вектора</td></tr> <tr><td>INT 21H </td><td>;меняем прерывание</td></tr> <tr><td>POP DS </td><td>;восстанавливаем DS</td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---процедура прерывания</td></tr> <tr><td>ROUT PROC FAR</td><td></td></tr> <tr><td>PUSH AX </td><td>;сохраняем все изменяемые регистры</td></tr> <tr><td>.</td><td></td></tr> <tr><td>.</td><td></td></tr> <tr><td>POP AX </td><td>;восстанавливаем регистры</td></tr> <tr><td>MOV AL,20H </td><td>;эти две строки надо использовать</td></tr> <tr><td>OUT 20H,AL </td><td>;только для аппаратных прерываний</td></tr> <tr><td>IRET</td><td></td></tr> <tr><td>ROUT ENDP</td><td></td></tr> </table> <p> В конце кода каждого из Ваших аппаратных прерываний Вы должны включить следующие 2 строчки кода: <table align="center"> <tr><td>MOV AL,20H</td><td></td></tr> <tr><td>OUT 20H,AL</td><td></td></tr> </table> <p> Это просто совпадение, что числа (20H) одни и те же в обеих строках. Если аппаратное прерывание не заканчивается этими строками, то микросхема 8259 не очистит информацию регистра обслуживания, с тем чтобы была разрешена обработка прерываний с более низкими уровнями, чем только что обработанное. Отсутствие этих строк легко может привести к краху программы, так как прерывания от клавиатуры скорее всего окажутся замороженными и даже Ctrl-Alt-Del окажется бесполезным. Отметим, что эта добавка не нужна для тех векторов прерываний, которые являются расширениями  существующих прерываний, таким как прерывание 1CH, которое добавляет код к прерыванию времени суток {<a href="217.htm">2.1.7</a>}. <p> Kогда программа завершается, должны быть восстановлены оригинальные вектора прерываний. В противном случае последующая программа может вызвать данное прерывание и передать управление на то место в памяти, в котором Вашей процедуры уже нет. Функция 35 прерывания 21H возвращает текущее значение вектора прерывания, помещая значение сегмента в ES, а смещение в BX. Перед установкой своего прерывания получите текущее значение вектора, используя эту функцию, сохраните эти значения, и затем восстановите их с помощью функции 25H (как выше) перед завершением своей программы. Hапример: <table align="center"> <tr><td></td><td>;---в сегменте данных:</td></tr> <tr><td>KEEP_CS DW 0 </td><td>;хранит сегмент заменяемого прерывания</td></tr> <tr><td>KEEP_IP DW 0 </td><td>;хранит смещение прерывания</td></tr> <tr><td></td><td>;---в начале программы</td></tr> <tr><td>MOV AH,25H </td><td>;функция получения вектора</td></tr> <tr><td>MOV AL,1CH </td><td>;номер вектора</td></tr> <tr><td>INT 21H </td><td>;теперь сегмент в ES, смещение в BX</td></tr> <tr><td>MOV KEEP_IP,BX </td><td>;запоминаем смещение</td></tr> <tr><td>MOV KEEP_CS,ES </td><td>;запоминаем сегмент</td></tr> <tr><td></td><td>; ---в конце программы</td></tr> <tr><td>CLI</td><td></td></tr> <tr><td>PUSH DS </td><td>;DS будет разрушен</td></tr> <tr><td>MOV DX,KEEP_IP </td><td>;подготовка к восстановлению</td></tr> <tr><td>MOV AX,KEEP_CS </td><td>;</td></tr> <tr><td>MOV DS,AX </td><td>;подготовка к восстановлению</td></tr> <tr><td>MOV AH,25H </td><td>;функция установки вектора</td></tr> <tr><td>MOV AL,1CH </td><td>;номер вектора</td></tr> <tr><td>INT 21H </td><td>;восстанавливаем вектор</td></tr> <tr><td>POP DS </td><td>;восстанавливаем DS</td></tr> <tr><td>STI</td><td></td></tr> </table> <p> Имеется пара ловушек, которых следует избегать при написании прерывания. Если новая процедура прерывания должна иметь доступ к данным, то необходимо позаботиться, чтобы DS был правильно установлен (обычно прерывание может использовать стек вызывающей программы). Другая неприятность может заключаться в том, что при завершении программы по Ctrl-Break вектор прерывания не будет восстановлен, если только Вы не предусмотрите, чтобы программа реакции на Ctrl-Break выполняла эту процедуру {<a href="328.htm">3.2.8</a>}. <p> Hизкий уровень. <p> Описанные выше функции MS DOS просто получают или изменяют пару слов в младших ячейках памяти. Смещение вектора может быть вычислено простым умножением номера вектора на 4. Hапример, чтобы получить адрес прерывания 16H в ES:BX: <table align="center"> <tr><td></td><td>;---получение адреса прерывания 16H</td></tr> <tr><td>SUB AX,AX </td><td>;устанавливаем ES на начало памяти</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> <tr><td>MOV DI,16H </td><td>;номер прерывания в DI</td></tr> <tr><td>SHL DI,1 </td><td>;умножаем на 2</td></tr> <tr><td>SHL DI,1 </td><td>;умножаем на 2</td></tr> <tr><td>MOV BX,ES:[DI] </td><td>;берем младший байт в BX</td></tr> <tr><td>MOV AX,ES:[DI]+2 </td><td>;берем старший байт в ES</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> </table> <p> Hе рекомендуется прямо устанавливать вектор прерываний, обходя функцию DOS. В частности в многозадачной среде операционная система может поддерживать несколько таблиц векторов прерываний и реальный физический адрес таблицы может быть известен только DOS. <hr><p align="center">
<~-<a href="122.htm">1.2.2 Запрет/разрешение отдельных аппаратных прерываний.</a><br><a href="index.htm#header">Содержание</a><br><a href="124.htm">1.2.4 Дополнение к существующему прерыванию.</a>-~>
</p></body></html>
