<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 4. Вывод на терминал.</p> <p class="hdr2">Раздел 4. Вывод точечной графики.</p> <p class="hdr3">4.4.2 Рисование точки на экране (монохромный, цветной и PCjr).</p> <p> Вследствие организации графической информации в видеобуфере вывод одной точки подразумевает изменение отдельных битов памяти. Режимы двух, четырех и шестнадцати цветов требуют, чтобы для установки характеристик одной точки были изменены один, два и четыре бита соответственно. Эти операции могут требовать огромного количества процессорного времени, о чем свидетельствует то, что большинство графического программного обеспечения работает очень медленно. Тщательное обдумывание часто позволяет сразу установить все биты одного байта, а не обращаться к одному и тому же байту 4 или 8 раз. Имейте это ввиду, и не следуйте слепо приведенной здесь технике поточечного вывода. <p> Средний уровень. <p> Функция CH прерывания 10H устанавливает точку. DX содержит строку, а CX - столбец, оба отсчитываемые от 0. Kод цвета помещается в AL. Отметим, что содержимое AX будет разрушено при выполнении прерывания. Если Вы используете это прерывание в цикле, то не забудьте сохранить AX на стеке и каждый раз восстанавливать его. <table align="center"> <tr><td></td><td>;---вывод точки с координатами 100,180</td></tr> <tr><td>MOV AH,0CH </td><td>;функция установки точки</td></tr> <tr><td>MOV AL,3 </td><td>;выбираем цвет 3 палетты</td></tr> <tr><td>MOV CX,100 </td><td>;строка</td></tr> <tr><td>MOV DX,180 </td><td>;столбец</td></tr> <tr><td>INT 10H </td><td>;выводим точку</td></tr> <tr><td></td><td>;---стираем точку</td></tr> <tr><td>MOV AH,0CH </td><td>;восстанавливаем функцию</td></tr> <tr><td>MOV AL,0 </td><td>;используем для стирания фоновый цвет</td></tr> <tr><td>MOV DX,100 </td><td>;строка</td></tr> <tr><td>MOV CX,180 </td><td>;столбец</td></tr> <tr><td>INT 10H </td><td>;стираем точку</td></tr> </table> <p> В то время как цвет палетты помещается в младшие биты AL, старший бит также имеет значение. Если он равен 1, то над цветом производится операция исключающего ИЛИ с текущим цветом. Hапомним, что операция исключающего ИЛИ устанавливает бит только в том случае если из двух сравниваемых битов установлен только один. Если оба сравниваемые бита равны 1 или оба равны 0, то результат будет 0. Для двухцветного режима это означает, что такая операция обращает установку бита. Если эту операцию применить ко всем точкам экрана, то будет обращен весь экран. В четырех- и 16-цветном режимах, с другой стороны, области экрана могут менять свои цвета. Hапример, пусть в 4-цветном режиме умеренного разрешения область занята точками либо цвета 1 палетты (установка битов 01B) или цвета 2 палетты (10B). Что произойдет, если применить ко всем точкам этой области операцию исключающего ИЛИ с 11B? 01B перейдет в 10B, а 10B перейдет в 01B - цвета будут обращены. <p> Hизкий уровень. <p> Hа низком уровне мы имеем возможность прямого доступа к видеобуферу (отображение в память). Сначала Вы должны вычислить смещение точки (а) внутри буфера и (б) внутри байта, содержащего биты, относящиеся к данной точке. После этого битовые операции обеспечат соответствующую установку. Отметим, что если Вы станете использовать эту технику на PCjr, когда он работает в одном из 16-цветных режимов, использующих страницу размером 32K, то вывод в адреса, начинающиеся с параграфа B800H не будет перенаправлен верно. Вам необходимо прямо адресовать реальные ячейки, расположенные в сегменте ниже 2000H. <p> Для нахождения точки необходимо прежде всего определить находится ли она в четной или нечетной строке. В данном примере строка помещена в CX, а столбец - в DX. Если бит 0 регистра CX равен 0, то строка имеет четный номер. Четные строки расположены со смещением 0 относительно начала буфера. Если же строка имеет нечетный номер, то необходимо добавить смещение 2000H для указания на начало второй половины буфера. <p> Затем разделите номер строки на 2, необходимо подсчитать число только четных или нечетных строк и умножьте результат на 80, т.к. на одну строку расходуется 80 байт. Для деления можно использовать инструкцию SHL, а результат даст общее число байтов во всех строках, предшествующих строке, в которой расположена искомая точка. <p> Вместо того, чтобы затем вычислять число столбцов в текущей строке, лучше сначала определить позицию пары битов в байте, которые содержат эту точку. Это достигается обращением всех битов в номере столбца (после того как сохранена его копия) и выделения двух младших битов. Эта процедура покажет находятся ли два бита, относящиеся к точке на первой, второй, третьей или четвертой позиции в байте. Умножив это значение на 2 мы получаем номер в байте первого из двух битов, относящихся к данной точке. <p> Затем приходит время подсчитать число байтов в строке, предшествующих байту, содержащему итнформацию о требуемой точке. Для режима умеренного разрешения надо разделить число столбцов на 4, а для высокого разрешения - на 8. После этого надо сложить три смещения: смещение за счет номера строки, за счет номера столбца и смещение начала четных/нечетных строк в буфере. После этого Вы можете получить требуемый байт из буфера. <p> Hаконец, надо произвести операцию над соответствующими битами байта. Вращайте байт до тех пор, пока пара битов относящихся к точке не станет младшими. При вращении необходимо использовать ранее подсчитанное значение позиции битов. Затем выключите оба бита поместите в них инструкцией OR требуемый код палетты. Затем надо произвести обратное вращение и послать байт обратно в буфер. <table align="center"> <tr><td></td><td>;---в сегменте данных</td></tr> <tr><td>PALETTE_COLOR DB 2</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---вызов процедуры</td></tr> <tr><td>MOV AX,0B800H </td><td>;указываем на видеобуфер</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> <tr><td>MOV CX,100 </td><td>;номер строки</td></tr> <tr><td>MOV DX,180 </td><td>;номер столбца</td></tr> <tr><td>CALL SET_DOT </td><td>;</td></tr> <tr><td>.</td><td></td></tr> <tr><td>.</td><td></td></tr> <tr><td></td><td>;---определяем число байтов в предшествующих строках</td></tr> <tr><td>SET_DOT PROC</td><td></td></tr> <tr><td>TEST CL,1 </td><td>;номер строки нечетный?</td></tr> <tr><td>JZ EVEN_ROW </td><td>;если нет, то вперед</td></tr> <tr><td>MOV BX,2000H </td><td>;смещение для нечетных строк</td></tr> <tr><td>JMP SHORT CONTINUE </td><td>;переход вперед</td></tr> <tr><td>EVEN_ROW: MOV BX,0 </td><td>;смещение для четных строк</td></tr> <tr><td>CONTINUE: SHR CX,1 </td><td>;делим число строк на 2 </td></tr> <tr><td>MOV AL,80 </td><td>;умножаем на 80</td></tr> <tr><td>MUL CL </td><td>;в AX - число байтов</td></tr> <tr><td></td><td>;---определяем положение пары бит в байте</td></tr> <tr><td>MOV CX,DX </td><td>;копируем номер столбца</td></tr> <tr><td>NOT CL </td><td>;обращаем биты</td></tr> <tr><td>AND CL,00000011B </td><td>;в CL - позиция битов (0-3)</td></tr> <tr><td>SHL CL,1 </td><td>;позиция первого бита пары</td></tr> <tr><td></td><td>;---подсчитываем смещение столбца в байтах</td></tr> <tr><td>SHR DX,1 </td><td>;делим номер столбца на 4</td></tr> <tr><td>SHR DX,1 </td><td>;(нужны два младших бита)</td></tr> <tr><td></td><td>;---вычисляем смещение для изменяемого байта</td></tr> <tr><td>ADD AX,DX </td><td>;складываем все три смещения</td></tr> <tr><td>ADD BX,AX </td><td>;</td></tr> <tr><td></td><td>;---изменяем биты нужного байта</td></tr> <tr><td>MOV AH,ES:[BX] </td><td>;читаем нужный байт</td></tr> <tr><td>ROR AH,CL </td><td>;сдвигаем нужные биты вниз</td></tr> <tr><td>AND AH,11111100B </td><td>;чистим младшие 2 бита</td></tr> <tr><td>MOV AL,PALETTE_COLOR </td><td>;изменяем их на цвет палетты</td></tr> <tr><td>OR AH,AL </td><td>;</td></tr> <tr><td>ROL AH,CL </td><td>;обратное вращение</td></tr> <tr><td>MOV ES:[BX],AH </td><td>;возвращаем байт</td></tr> <tr><td>RET </td><td>;</td></tr> <tr><td>SET_DOT ENDP</td><td></td></tr> </table> <hr><p align="center">
<~-<a href="441.htm">4.4.1 Установка цветов для точечной графики.</a><br><a href="index.htm#header">Содержание</a><br><a href="443.htm">4.4.3 Рисование точки на экране (EGA).</a>-~>
</p></body></html>
