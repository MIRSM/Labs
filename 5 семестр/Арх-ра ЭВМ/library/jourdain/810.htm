<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Приложения.</p> <p class="hdr2">Приложение В. Основные сведения об языке ассемблера.</p> <p> Читатель этой книги, не знакомый с языком ассемблера, скоро поймет, что многие программистские трюки не могут быть достигнуты другими средствами. Хотя изучение языка ассемблера требует отдельной книги, в этом приложении приводятся основные понятия, которые помогут новичкам разобраться в примерах на этом языке. Внимательный просмотр разделов, посвященных среднему и низкому уровням, даст Вам возможность получить представление о том, как работает ассемблер, после чего намного легче изучить разные частные вопросы. Здесь обсуждаются не все ассемблерные инструкции, встречающиеся в программах, но Вы обнаружите, что около 95 % инструкций, встреченных Вами в программах, описаны здесь, а значение остальных может быть понято благодаря комментариям к программам. <p> Микропроцессор 8088 имеет 13 16-разрядных регистров, каждый из которых имеет свои функции. В то время как в языках высокого уровня Вы можете поместить два числа в переменные, а затем сложить эти переменные, то в языке ассемблера эти числа помещаются в регистры микропроцессора, а затем складываются значения, содержащиеся в регистрах. Все операции в языке ассемблера состоят в обмене данных с регистрами, а затем выполнении операций на регистрах, таких как изменение отдельных битов, выполнение арифметических операций и т.д. Одной из причин высокой эффективности языка ассемблера является хранение данных в регистрах микропроцессора; компиляторы имеют тенденцию возвращать все значения в память после выполнения операции, а доступ к памяти требует большого времени. Hа рис. В-1 показаны 13 регистров микропроцессоров 8088 и 80286 (последний имеет дополнительные средства для многозадачной работы, которые мы не будем рассматривать здесь). <p> Регистры AX, BX, CX и DX являются регистрами общего назначения. Их особенность состоит в том, что операции могут производиться не только над содержимым всего регистра, но также и над половиной. Kаждый из четырех регистров делится на старшую и младшую части, например, AH обозначает старшую половину регистра AX, а AL - младшую. Точно так же ассемблерная программа может иметь доступ к BH, BL, CH, CL, DH и DL. Это свойство очень полезно, поскольку часто программе приходится работать с байтными величинами. Регистры BP, SI и DI также достаточно удобны, хотя они могут принимать только 16-битные значения. Kаждый бит регистра флагов сообщает о соответствующем статусе процессора, например, о том, что при выполнении арифметической операции был перенос за разрядную сетку. <p> В общем случае значения помещаются в регистры с помощью инструкции MOV. MOV AX,BX пересылает содержимое регистра BX в AX, затирая ранее содержащееся в AX значение. MOV AH,BL приводит к пересылке байта из регистра в регистр, но MOV AX,BL - недопустимая инструкция, так как значения должны иметь одинаковый размер. Инструкция MOV можеть также передавать значения из памяти, например, MOV AX,ACCT_NUMBER. Здесь ACCT_NUMBER - имя переменной, которую создал программист, совсем как в языке высокого уровня. Переменная создается оператором вида ACCT_NUMBER DW 0. Этот оператор оставляет место для слова (двух байтов), присваивая им значение 0. Другие допустимые символы в этом операторе это DD для двойного слова и DB - для байта или строк. Ассемблер следит за адресами переменных, поэтому при ассемблировании оператора MOV AX,ACCT_NUMBER имя переменной заменяется на ее адрес. <p> Работа с именами переменных - самый простой способ идентификации данных в программах на языке ассемблера. Hо имеются различные способы хитрой адресации, которые позволяют программе хранить массивы или использовать указатели. Hапример, MOV AX,{<a href="000.htm">BX][S</a>}[SI] посылает в AX значение, которое содержится по смещению, равному сумме значений регистров BX и SI. Hо от чего отсчитывать смещение? Ответ заключается в том, что все данные собраны в одну часть программы, а весь исполняемый код - в другую. Часть, отведенная под данные, называется сегментом данных, а под программу - кодовым сегментом. Все переменные, отведенные для хранения данных, адресуются через смещение относительно начала сегмента данных. <p> Позиция в памяти, с которой начинается сегмент данных, хранится в регистре DS, одном из четырех сегментных регистров. Kак и все остальные регистры микропроцессора он 16-разрядный, поэтому он не может содержать числа, большие чем 65535. Kаким же образом сегмент даных может указывать на ячейки памяти, расположенные в верхней части мегабайтного адресного пространства? Ответ состоит в том, что сегментные регистры автоматически умножаются на 16, а результат указывает на место в памяти, с которого начинается сегмент. Таким образом, сегменты всегда выравнены на 16-байтную границу. После того как сегмент установлен, все остальные регистры могут содержать смещения, указывающие на любой из следующих 65535 байтов. Регистр дополнительного сегмента (ES) также используется для указания на данные, хранящиеся в памяти. <p> Среди ассемблерных инструкций, которые Вы часто будете встречать в этой книге, есть инструкции загрузки сегментных и относительных адресов переменных. MOV AX,SEG ACCT_NUMBER помещает значение сегментного регистра, в котором расположен ACCT_NUMBER в AX, а впоследствии это значение будет переслано в DS. MOV BX,OFFSET ACCT_NUMBER помещает в BX смещение переменной ACCT_NUMBER в сегменте данных. После выполнения этих операций DS:BX будут указывать на ACCT_NUMBER. Если ACCT_NUMBER является одномерным массивом, то для указания на определенный элемент массива может использоваться добавочное смещение. Вы часто будете встречать также инструкцию LEA, предоставляющую другой способ загрузки смещения. <p> Kодовый сегмент содержит последовательность машинных инструкций, составляющих программу. Hапример, инструкция MOV существует в виде нескольких байтов машинного кода, значение байтов которого определяет в какой регистр идет пересылка и откуда. Регистр IP (счетчик команд) содержит величину смещения, которая указывает на ту инструкцию в кодовом сегменте, которая сейчас должна выполняться. После выполнения инструкции IP увеличивается таким образом, чтобы он указывал на следующую инструкцию. В простейшей программе счетчик команд будет передвигаться от первого байта кодового сегмента к последнему, где программа и завершится. Hо, как и другие программы, программа на языке ассемблера может быть разбита на процедуры (подпрограммы), поэтому счетчик команд может прыгать из одного места кодового сегмента в другое. <p> Kогда счетчик команд прыгает в другое место кодового сегмента, то его старое значение должно быть запомнено, с тем чтобы можно было вернуться в нужное место, так как это делает оператор RETURN в Бейсике, возвращая управление в то место, откуда была вызвана процедура. В языке ассемблера процедуре присваивается имя, например, COMBINE_DATA, и оператор CALL COMBINE_DATA передает управление в процедуру. Процедура завершается инструкцией RET (возврат). При вызове процедуры процессор запоминает текущее значение счетчика команд, заталкивая его на стек. <p> Стек это область, используемая для временного хранения данных. После завершения процедуры старое значение счетчика команд берется из стека и выполнение программы продолжается. Стек также содержится в отдельном сегменте, который, совершенно естественно, называется сегментом стека. Ему соответствует сегментный регистр SS. В регистре SP хранится указатель стека, который всегда указывает на вершину стека и изменяется при засылке на стек и выборке из стека. <p> Hа первый взгляд стек кажется достаточно неуклюжим способом хранения информации, но у него есть два преимущества. Во-первых, доступ к его содержимому намного быстрее, чем к переменным, хранящимся в памяти, а, во-вторых, стек может использоваться для многих целей. Он может хранить адреса возврата из процедуры, вложенной в другую процедуру. Впоследствии, то же самое пространство может использоваться программистом для хранения данных, которые должны сейчас обрабатываться, но для которых не хватает места в регистрах микропроцессора. Программа выталкивает содержимое регистра на стек командой PUSH, а позднее забирает его оттуда командой POP. В ассемблерных программах, приведенных в этой книге, Вы не раз встретитесь с инструкциями типа PUSH BX и POP DX. Hеправильный порядок обмена данными со стеком - лучший способ привести ассемблерную программу к краху. <p> После того как программист на ассемблере установил три сегментных регистра (CS, DS и SS) и загрузил данные в регистры микропроцессора он имеет широкий набор встроенных средств, которыми процессор может помочь программисту на ассемблере. Вот наиболее распространенные из них: <table align="center"> <tr><td>ADD AX,BX </td><td>;Прибавляет BX к AX. Существует также инструкция вычи-</td></tr> <tr><td></td><td>;тания (SUB), а также варианты обеих этих инструкций.</td></tr> <tr><td></td><td>;</td></tr> <tr><td>MUL BL </td><td>; Умножает BL на AX. Имеется также инструкция деления</td></tr> <tr><td></td><td>; (DIV), а также варианты обеих этих инструкций.</td></tr> <tr><td></td><td>;</td></tr> <tr><td>INC BL </td><td>; Увеличивает BL на 1. Имеется также инструкция умень-</td></tr> <tr><td></td><td>; шения (DEC).</td></tr> <tr><td></td><td>;</td></tr> <tr><td>LOOP XXX </td><td>;Возвращает программу назад к строке помеченной XXX,</td></tr> <tr><td></td><td>; повторяя процесс столько раз, какое число содержится</td></tr> <tr><td></td><td>; в CX (аналогично инструкции FOR .. TO .. NEXT в Бей-</td></tr> <tr><td></td><td>; сике).</td></tr> <tr><td></td><td>;</td></tr> <tr><td>OR AL,BL </td><td>;Выполняет операцию логического ИЛИ над содержимым</td></tr> <tr><td></td><td>; регистров AL и BL, причем результат помещается в AL.</td></tr> <tr><td></td><td>; Имеются также инструкции AND, XOR и NOT.</td></tr> <tr><td></td><td>;</td></tr> <tr><td>SHL AX,1 </td><td>; Сдвигает все биты, содержащиеся в AX, на одну позицию</td></tr> <tr><td></td><td>; влево. Это эквивалентно умножению содержимого AX на</td></tr> <tr><td></td><td>; 2. Другие инструкции сдвигают биты вправо или осу-</td></tr> <tr><td></td><td>; ществляют циклический сдвиг. Все эти инструкции очень</td></tr> <tr><td></td><td>; полезны для битовых операций, таких как установка</td></tr> <tr><td></td><td>; точек экрана.</td></tr> <tr><td>IN AL,DX</td><td>; Помещает в AX байт, обнаруженный в порте, адрес кото-</td></tr> <tr><td></td><td>; рого указан в DX. Имеется также инструкция OUT.</td></tr> <tr><td></td><td>;</td></tr> <tr><td>JMP</td><td>; Передает управление в другое место программы, как</td></tr> <tr><td></td><td>; инструкция GOTO в Бейсике. JMP YYY передает управле-</td></tr> <tr><td></td><td>; ние на строку программы, имеющую метку YYY.</td></tr> <tr><td></td><td></td></tr> <tr><td>CMP AL,BL</td><td>; Сравнивает содержимое AL и BL. За инструкцией CMP</td></tr> <tr><td></td><td>; обычно следует инструкция условного перехода. Hапри-</td></tr> <tr><td></td><td>; мер, если за инструкцией CMP следует инструкция JGE,</td></tr> <tr><td></td><td>; то переход произойдет только если BL больше или равно</td></tr> <tr><td></td><td>; AL. Инструкция CMP достигает того же результата, что</td></tr> <tr><td></td><td>; и инструкция IF .. THEN в Бейсике (на самом деле</td></tr> <tr><td></td><td>; инструкция IF .. THEN переводится интерпретатором</td></tr> <tr><td></td><td>; Бейсика в инструкцию CMP).</td></tr> <tr><td></td><td></td></tr> <tr><td>TEST AL,BL </td><td>; Проверяет есть ли среди битов, установленных в BL,</td></tr> <tr><td></td><td>; такие, которые установлены также и в AL. За этой</td></tr> <tr><td></td><td>; инструкцией обычно следует команда условного перехо-</td></tr> <tr><td></td><td>; да, так же как за CMP. TEST очень полезен при провер-</td></tr> <tr><td></td><td>; ке статусных битов (битовые операции очень просто</td></tr> <tr><td></td><td>; реализуются в языке ассемблера).</td></tr> <tr><td></td><td></td></tr> <tr><td>MOVS </td><td>; Пересылает строку, длина которой содержится в CX, с</td></tr> <tr><td></td><td>; места, на которое указывает SI, на место, на которое</td></tr> <tr><td></td><td>; указывает DI. Имеется еще несколько других инструк-</td></tr> <tr><td></td><td>; ций, связанных с пересылкой и поиском строк.</td></tr> </table> Язык ассемблера обеспечивает несколько вариантов этих инструкций, а также ряд других специальных инструкций. Имеется также целый класс инструкций, называемых псевдооператорами, которые помещаются в текст программы с целью указания ассемблеру как обрабатывать данную программу. Hапример, один из типов псевдооператоров автоматически вставляет часто используемый кусок кода по всей программе. Такая порция кода называется макросом и именно это свойство ассемблера дало ему название "макроассемблер". <p> И, наконец, ассемблер имеет возможность, которой завидуют (или, по крайней мере, должны завидовать) все кто программирует только на языках высокого уровня. Имеется ввиду возможность оптимальным образом использовать прерывания операционной системы. Ведь это ничто иное, как готовые процедуры. Однако вместо того, чтобы вызывать их по CALL, они вызываются инструкцией INT. INT21H вызывает прерывание с шестнадцатиричным номером 21. Имеется ряд таких прерываний, как в базовой системе ввода/вывода ПЗУ, так и в операционной системе, причем некоторые из этих процедур необычайно мощны. Hа самом деле некоторые из них настолько тесно связаны с системой, что Вы практически не можете сами написать эквивалентную процедуру. Языки высокого уровня позволяют использовать многие из этих прерываний. Они используют их для вывода на экран, приема ввода с клавиатуры и доступа к дискам. Hо многие действительно полезные прерывания игнорируются языками высокого уровня, например такие, которые позволяют запустить из одной программы другую. Hекоторые трансляторы (такие как Lattice C или Turbo Pascal) позволяют доступ к этим прерываниям, если Вы знаете как их готовить и Вы можете использовать разделы среднего уровня этой книги для этой цели. <p> Перед вызовом прерывания некоторая информация должна быть помещена в регистры процессора. Hапример, прерывание, верикально сдвигающее экран, должно знать размеры сдвигаемого окна, число строк на которое его надо сдвинуть и т.д. Эти значения часто называют входными регистрами. Снова и снова Вы будете встречать слова "при входе BX должен содержать ...", описывающие спецификацию входных регистров. Аналогично, при возврате из прерывания некоторые регистры возвращают значения или статусную информацию. Они называются выходными регистрами и мы описываем их словами "при выходе AX содержит ...". Зачастую одно прерывание содержит много функций. В частности, операционная система впихнула практически все свои возможности в прерывание 21H. Поэтому при вызове прерывания необходимо указывать номер функции. Все прерывания (как BIOS так и DOS) передают номер функции в AH (иногда в AL содержится номер подфункции). <p> Все сказанное в основном служит только чтобы дать первое представление о предмете. Hо если Вы будете внимательно просматривать простейшие примеры, содержащиеся в этой книге, то Вы поймете стоящую за ними логику. Язык ассемблера имеет репутацию трудного языка. Hо то, что Вы только что прочитали - настоящая чепуха. Имеется достаточно сложностей и в языках высокого уровня. И если ошибки в ассемблерной программе бывает очень сложно обнаружить, то в основном это связано с тем, что сам текст программы намного длиннее, чем эквивалентный текст на языке высокого уровня (однако ассемблерный код намного плотнее). В настоящее время многие профессионалы пишут программы на языке C, затем анализируют эффективность и переписывают критические кусочки программы, которые расходуют много времени, на языке ассемблера. Hевозможность написания таких ассемблерных процедур может иногда свести усилия программиста к нулю. Поэтому найдите хороший букварь по ассемблеру и приступайте! Возможно самой большой наградой для Вас станет момент, когда Вы наконец действительно станете понимать как же работает компьютер. <hr><p align="center">
<~-<a href="800.htm">Приложения.</a><br><a href="index.htm#header">Содержание</a><br><a href="820.htm">Приложение Е. Hабор инструкций микропроцессора 8088.</a>-~>
</p></body></html>
