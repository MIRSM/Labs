<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 2. Таймеры и звук.</p> <p class="hdr2">Раздел 1. Установка и чтение таймера.</p> <p class="hdr3">2.1.7 Управление работой в реальном времени.</p> <p> При операциях в реальном времени программа выполняет инструкции в указанный момент времени, а не при первой возможности. Такого рода операции обычно ассоциируются с роботехникой, но имеется множество других приложений. Имеется выбор подхода к операциям в реальном времени. Для программ, которые не должны ничего делать в промежутке между инструкциями, требующими временной привязки, можно просто периодически проверять счетчик времени суток, ожидая наступления нужного момента. Такой подход практически сводится к набору пустых циклов, описанных в {<a href="215.htm">2.1.5</a>}. <p> Второй подход более сложен. Он используется, когда программа постоянно занята какой-либо работой, но она должна в определенные моменты времени прерывать свои операции для выполнения определенной задачи. В этом случае расширяют прерывание таймера, которое выполняется 18.2 раза в секунду. Kогда это прерывание происходит, дополнительный код проверяет новое значение счетчика времени суток и если наступил определенный момент времени, запускает нужную процедуру. Этот процесс показан на рис. 2-3. Приведенные здесь простые примеры показывают, как создать в своей программе будильник, который устанавливается пользователем и подает звуковой сигнал, когда подошло время. (Более сложный пример низкого уровня в {<a href="226.htm">2.2.6</a>} исполняет музыку, в то время когда процессор занят другими делами.) <p> Hизкий уровень. <p> BIOS содержит специальное пустое прерывание (1CH), которое ничего не делает, пока Вы не напишите для него процедуру. При старте вектор этого прерывания указывает на инструкцию IRET (возврат из прерывания); при его вызове происходит моментальный возврат. Hо прерывание 1CH интересно тем, что оно вызывается прерыванием таймера BIOS после того, как это прерывание обновило значение счетчика времени суток. Можно сказать, что это аппаратное прерывание, происходящее автоматически 18.2 раза в секунду. Вы можете изменить вектор этого прерывания так, чтобы он указывал на процедуру в Вашей программе. После этого Ваша процедура будет вызываться 18.2 раза в секунду. О том как написать и установить свою процедуру обработки прерывания см. в {<a href="123.htm">1.2.3</a>}. <p> Hаписанная Вами процедура должна прочитать только что модифицированное значение счетчика времени суток, сравнить его с ожидаемым временем, и выполнить то что требуется, когда ожидаемое время наконец наступит. Естественно, что когда время еще не подошло, то процедура просто возвращает управление, ничего не делая. Таким образом, процессор не выполняет лишней работы. <p> В приведенном примере процедура (не показанная здесь) запрашивает у пользователя число минут (до 60), которое должно пройти до того, как раздастся звонок будильника. Это число, запасенное в MINUTES, умножается на 1092 для перевода в эквивалентное число импульсов счетчика времени суток. Для периода в пределах одного часа достаточно 16 бит - более длинные периоды требуют более сложных 32-битовых операций. Это число импульсов добавляется к младшему слову текущего значения счетчика времени суток и запоминается в ALARMCOUNT. <p> Затем вектор прерывания 1CH изменяется таким образом, чтобы он указывал на процедуру ALARM. Помните, что как только вектор будет изменен, ALARM будет автоматически вызываться 18.2 раза в секунду. При вызове эта процедура читает текущее значение счетчика времени суток через прерывание 1AH и сравнивает с ALARMCOUNT. При совпадении этих величин вызывается процедура BEEP (также не показанная здесь - см. {<a href="224.htm">2.2.4</a>}), которая выдает звуковой сигнал. В противном случае происходит возврат. Обычный код возврата из аппаратных прерываний (MOV AH,20H / OUT 20H,AL) включать в процедуру не нужно, так как он будет в прерывании таймера. Будьте внимательны и не забудьте сохранить изменяемые регистры. <table align="center"> <tr><td></td><td>;---в сегменте данных</td></tr> <tr><td>MINUTES DW 0 </td><td>;хранит число минут до звонка</td></tr> <tr><td>ALARMCOUNT DW 0 </td><td>;хранит счетчик времени для звонка</td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---установка ожидаемого значения счетчика времени суток</td></tr> <tr><td>CALL REQUEST_MINUTES </td><td>;запрос числа минут до звонка</td></tr> <tr><td>MOV AX,MINUTES </td><td>;пересылка в AX</td></tr> <tr><td>MOV BX,1092 </td><td>;число импульсов счетчика в минуте</td></tr> <tr><td>MUL BX </td><td>;умножаем - результат в AX</td></tr> <tr><td></td><td>;получаем текущее значение счетчика</td></tr> <tr><td>MOV AH,0 </td><td>;номер функции чтения счетчика</td></tr> <tr><td>INT 1AH </td><td>;читаем значение, младший байт в DX</td></tr> <tr><td></td><td>;складываем оба значения</td></tr> <tr><td>ADD AX,DX </td><td>;</td></tr> <tr><td>MOV ALARMCOUNT,AX </td><td>;получаем нужное значение счетчика</td></tr> <tr><td></td><td>;---заменяем вектор пустого прерывания</td></tr> <tr><td>PUSH DS </td><td>;сохраняем сегмент данных</td></tr> <tr><td>MOV AX,SEG ALARM </td><td>;берем сегмент процедуры ALARM</td></tr> <tr><td>MOV DS,AX </td><td>;помещаем его в DS</td></tr> <tr><td>MOV DX,OFFSET ALARM </td><td>;берем смещение процедуры</td></tr> <tr><td>MOV AL,1CH </td><td>;номер изменяемого вектора</td></tr> <tr><td>MOV AH,25H </td><td>;функция изменения вектора</td></tr> <tr><td>INT 21H </td><td>;меняем вектор</td></tr> <tr><td>POP DS </td><td>;восстанавливаем сегмент данных</td></tr> <tr><td></td><td>;</td></tr> <tr><td></td><td>;---дальше продолжается программа</td></tr> <tr><td></td><td>;</td></tr> <tr><td></td><td>;---в конце программы возвращаем вектор прерывания</td></tr> <tr><td>MOV DX,0FF53H </td><td>;оригинальные значения для</td></tr> <tr><td>MOV AX,0F000H </td><td>;прерывания 1CH</td></tr> <tr><td>MOV DS,AX </td><td>;помещаем сегмент в DS</td></tr> <tr><td>MOV AL,1CH </td><td>;номер изменяемого вектора</td></tr> <tr><td>MOV AH,25H </td><td>;номер функции</td></tr> <tr><td>INT 21H </td><td>;восстанавливаем вектор</td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---процедура выдачи звукового сигнала</td></tr> <tr><td>ALARM PROC FAR </td><td>;создаем длинную процедуру</td></tr> <tr><td>PUSH AX </td><td>;сохраняем изменяемые регистры</td></tr> <tr><td>PUSH CX </td><td>;</td></tr> <tr><td>PUSH DX </td><td>;</td></tr> <tr><td></td><td>;---читаем счетчик времени суток</td></tr> <tr><td>MOV AH,0 </td><td>;номер функции чтения счетчика</td></tr> <tr><td>INT 1AH </td><td>;читаем значение счетчика</td></tr> <tr><td></td><td>;---сравниваем с требуемым значением</td></tr> <tr><td>MOV CX,ALARMCOUNT </td><td>;берем требуемое значение</td></tr> <tr><td>CMP DX,CX </td><td>;сравниваем с текущим</td></tr> <tr><td>JNE NOT_YET </td><td>;если неравны, то на выход</td></tr> <tr><td></td><td>;---выдаем звуковой сигнал, если значения совпали</td></tr> <tr><td>CALL BEEP </td><td>;эта процедура не показана</td></tr> <tr><td></td><td>;---иначе возвращаемся из прерывания</td></tr> <tr><td>NOT_YET: POP DX </td><td>;восстанавливаем регистры</td></tr> <tr><td>POP CX </td><td>;</td></tr> <tr><td>POP AX </td><td>;</td></tr> <tr><td>IRET </td><td>;возврат из прерывания</td></tr> <tr><td>ALARM ENDP </td><td>;конец процедуры</td></tr> </table> <hr><p align="center">
<~-<a href="216.htm">2.1.6 Операции запрограммированные во времени.</a><br><a href="index.htm#header">Содержание</a><br><a href="220.htm">Раздел 2. Создание звука.</a>-~>
</p></body></html>
