<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 5. Дисковые накопители.</p> <p class="hdr2">Раздел 2. Работа с каталогами диска.</p> <p class="hdr3">5.2.7 Чтение/изменение метки тома.</p> <p> Метка тома для дискеты - это элемент каталога, имеющий специальный атрибут. Метка занимает первые 11 байтов элемента, относящиеся к имени и расширению файла. Байт атрибутов по смещению 11 содержит значение 8 (бит 3 = 1). Поля времени и даты заполняются обычным образом. Одним из свойств этого атрибута является то, что данный элемент не выводится по команде DIR. <p> Метка может занимать любую позицию в каталоге. Она ищется перебором всех байтов атрибутов, пока не будет найдено значение 8. Чтобы стереть метку надо просто поместить E5 в первый байт соответствующего элемента - сам байт атрибутов можно не менять. Чтобы изменить метку надо записать новые 11 символов (остаток надо заполнить пробелами). Чтобы присвоить метку тома диску, который не имел ее, надо найти пустое место в каталоге и записать туда метку и соответствующий атрибут, ничего больше не требуется. <p> Hизкий уровень. <p> В нижеприведенном примере предполагается, что Вы создали буфер данных размером 3584 байт, для хранения всех семи секторов каталога дискеты емкостью 360K. Буфер называется DIR_AREA. В первом примере метка тома ищется и выводится, или, если она не найдена, то выводится сообщение об ее отсутствии. Для удобства область буфера для секторов отводится в сегменте данных; лучше отвести память для задачи, а затем освободить ее {<a href="131.htm">1.3.1</a>}. <table align="center"> <tr><td></td><td>;---в сегменте данных</td></tr> <tr><td>VOL_STRING DB 'The volume label is $'</td><td></td></tr> <tr><td>NO_LABEL DB 'There is no volume label $'</td><td></td></tr> <tr><td>DIR_AREA DB 3584 DUP(?)</td><td></td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---читаем 7 секторов каталога</td></tr> <tr><td>MOV AX,SEG DIR_AREA </td><td>;сегмент буфера</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> <tr><td>MOV BX,OFFSET DIR_AREA </td><td>;смещение буфера</td></tr> <tr><td>MOV DL,0 </td><td>;номер накопителя</td></tr> <tr><td>MOV DH,0 </td><td>;номер головки</td></tr> <tr><td>MOV CH,0 </td><td>;номер дорожки</td></tr> <tr><td>MOV CL,6 </td><td>;стартовый сектор</td></tr> <tr><td>MOV AL,7 </td><td>;число секторов каталога</td></tr> <tr><td>MOV AH,2 </td><td>;номер функции чтения</td></tr> <tr><td>INT 13H </td><td>;читаем каталог в память</td></tr> <tr><td></td><td>;---ищем метку тома, сравнивая байт атрибутов с 8</td></tr> <tr><td>MOV CX,112 </td><td>;число элементов</td></tr> <tr><td>ADD BX,11 </td><td>;смещение для атрибутов</td></tr> <tr><td>TRY_AGAIN: MOV AL,[BX] </td><td>;берем 1-й элемент</td></tr> <tr><td>CMP AL,8 </td><td>;это метка тома?</td></tr> <tr><td>JE GOT_IT </td><td>;если да, то уход</td></tr> <tr><td>ADD BX,32 </td><td>;иначе на след. элемент</td></tr> <tr><td>LOOP TRY_AGAIN </td><td>;</td></tr> <tr><td></td><td>;---выводим сообщение об отсутствии метки тома</td></tr> <tr><td>MOV AH,9 </td><td>;функция вывода строки</td></tr> <tr><td>LEA DX,NO_LABEL </td><td>;указываем на строку</td></tr> <tr><td>INT 21H </td><td>;выводим ее</td></tr> <tr><td>JMP SHORT CONTINUE </td><td>;на конец</td></tr> <tr><td></td><td>;---выводим строку, дающую метку тома</td></tr> <tr><td>GOT_IT: MOV AH,9 </td><td>;функция вывода строки</td></tr> <tr><td>LEA DX,VOL_STRING </td><td>;указываем на строку</td></tr> <tr><td>INT 21H </td><td>;выводим ее</td></tr> <tr><td>SUB BX,11 </td><td>;указатель на метку</td></tr> <tr><td>MOV CX,11 </td><td>;пишем 11 символов</td></tr> <tr><td>MOV AH,2 </td><td>;функция вывода символов </td></tr> <tr><td>NEXT_CHAR: MOV DL,[BX] </td><td>;символ в DL</td></tr> <tr><td>INT 21H </td><td>;выводим символ</td></tr> <tr><td>INC BX </td><td>;переходим к следующему</td></tr> <tr><td>LOOP NEXT_CHAR </td><td>;</td></tr> <tr><td>CONTINUE:</td><td></td></tr> </table> Чтобы стереть метку поместите следующий код в GOT_IT: <table align="center"> <tr><td>GOT_IT: MOV AL,0E5H </td><td>;код отметки пустого элемента</td></tr> <tr><td>SUB BX,11 </td><td>;указатель на начало элемента</td></tr> <tr><td>MOV [BX],AL </td><td>;меняем первый байт</td></tr> </table> Чтобы изменить метку тома, надо вместо этого использовать в GOT_IT следующий код. Предполагается, что Вы подготовили где-то 11-байтную строку NEW_LABEL. <table align="center"> <tr><td>GOT_IT: LEA SI,NEW_LABEL </td><td>;SI должен указывать на строку</td></tr> <tr><td>SUB BX,11 </td><td>;BX указывает на начало метки</td></tr> <tr><td>MOV DI,BX </td><td>;помещаем указатель в DI</td></tr> <tr><td>MOV CX,11 </td><td>;пересылка 11 символов</td></tr> <tr><td>REP MOVSB </td><td>;пересылаем строку</td></tr> </table> <p> Чтобы создать метку можно использовать тот же самый код, но надо также установить байт атрибутов равный 8 (Вы можете просто добавить ASCII 8 к строке, содержащей новую метку, так как байт атрибутов непосредственно следует за самой меткой). <p> И, наконец, во всех случаях изменения каталога, необходимо записать каталог обратно на диск. Ошибки при этом непростительны. <table align="center"> <tr><td></td><td>;---запись измененных секторов назад на диск</td></tr> <tr><td>MOV AX,SEG DIR_AREA </td><td>;регистры как и при чтении</td></tr> <tr><td>MOV ES,AX </td><td>;</td></tr> <tr><td>MOV BX,OFFSET DIR_AREA </td><td>;</td></tr> <tr><td>MOV DL,0 </td><td>;</td></tr> <tr><td>MOV DH,0 </td><td>;</td></tr> <tr><td>MOV CH,0 </td><td>;</td></tr> <tr><td>MOV CL,6 </td><td>;</td></tr> <tr><td>MOV AL,7 </td><td>;</td></tr> <tr><td>MOV AH,3 </td><td>;номер функции записи секторов</td></tr> <tr><td>INT 13H </td><td>;</td></tr> </table> <hr><p align="center">
<~-<a href="526.htm">5.2.6 Спрятанные и защищенные от записи файлы.</a><br><a href="index.htm#header">Содержание</a><br><a href="530.htm">Раздел 3. Подготовка к работе с файлами.</a>-~>
</p></body></html>
