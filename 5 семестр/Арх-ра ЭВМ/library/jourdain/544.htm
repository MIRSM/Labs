<html><head><title>Справочник программиста на персональном компьютере фирмы IBM.Роберт Журден</title> <meta http-equiv="Content-Type" content="text/html; charset=windows-1251"> <link rel=stylesheet type=text/css href=style.css> </head><body> <p class="hdr1">Глава 5. Дисковые накопители.</p> <p class="hdr2">Раздел 4. Чтение и запись файла.</p> <p class="hdr3">5.4.4 Чтение из последовательных файлов.</p> <p> Чтение из последовательного файла мало чем отличается от записи в него, за исключением того, что процесс обратный. В Бейсике данные берутся из файла и присваиваются отдельным переменным или элементам массива данных. В языке ассемблера данные помещаются в буфер, расположенный в памяти. В последнем случае данные передаются по записям и программа должна сама выделять элементы данных, составляющие записи. В этом случае под записью понимается порция данных, которая считывается из файла. <p> Средний уровень. <p> Kак и для всех файловых операций MS DOS может читать последовательные файлы как методом управляющего блока файла, так и методом дескриптора файлов. Только первый из них имеет функцию специально предназначенную для чтения последовательных файлов. Метод дескриптора файлов использует более общую функцию, манипулируя ей особым образом, требуемым для последовательных файлов. Метод FCB: <p> Функция 14H прерывания 21H читает последовательные файлы. Hадо создать управляющий блок файла и область обмена с диском, как объяснено в {<a href="535.htm">5.3.5</a>}. Файл должен быть открыт функцией 0FH прерывания 21H {<a href="533.htm">5.3.3</a>}. DS:DX должны указывать на первый байт FCB, после чего функция 14H будет читать по одной записи из файла при каждом вызове. Вы можете установить размер записи по смещению 14 в FCB. Это надо делать после того, как файл открыт, так как при открытии файла DOS вставляет в это поле значение по умолчанию, равное 128. <p> Kаждый раз при вызове функции данные загружаются в память, начиная с первого байта DTA. Если DTA используется как небольшой временный буфер, то перед чтением следующей записи содержимое DTA должно быть перенесено в область данных файла, отведенную в памяти. Можно наоборот установить указатель DTA на стартовый адрес  памяти, начиная с которого будет размещаться файл, а после чтения каждой записи указатель увеличивать на размер записи, с тем чтобы он указывал на место, где должна быть следующая запись. <p> Установкой полей текущей записи (DB, смещение 1FH) и блока текущей записи (DW, смещение 0CH) отличными от нуля, последовательный может читаться, начиная с любого требуемого места (установка должна быть сделана после открытия FCB). После каждого чтения поле текущей записи автоматически увеличивается на 1, а после чтения 128 записей увеличивается поле текущего блока. При возврате AL равен 0, если вся запись успешно прочитана. При обнаружении конца файла AL будет содержать 1, если функция 14H вообще не возвратила данных и 3 - если запись прочитана частично. <p> В приведенном примере из файла считываются две записи и последовательно помещаются в нужную область памяти. Размер записи установлен равным 256 байтам. Записи считываются в цикле и после того, как первая запись считана, указатель на DTA изменяется таким образом, чтобы он указывал на следующий пустой байт в области данных. <table align="center"> <tr><td></td><td>;---помещаем FCB в сегмент данных</td></tr> <tr><td>FCB DB 0,'OLDDATA DAT', 25 DUP(0)</td><td></td></tr> <tr><td>DATA_AREA DB 512 DUP (?) </td><td>;используем как DTA</td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---устанавливаем DTA на начало области данных</td></tr> <tr><td>LEA DX,DATA_AREA </td><td>;DS:DX указывают на DTA</td></tr> <tr><td>MOV DI,DX </td><td>;сохраняем копию</td></tr> <tr><td>MOV AH,1AH </td><td>;функция установки DTA</td></tr> <tr><td>INT 21H </td><td>;устанавливаем DTA</td></tr> <tr><td></td><td>;---открываем файл</td></tr> <tr><td>LEA DX,FCB </td><td>;DS:DX указывают на FCB</td></tr> <tr><td>MOV AH,0FH </td><td>;функция открытия файла</td></tr> <tr><td>INT 21H </td><td>;открываем файл</td></tr> <tr><td>CMP AL,0 </td><td>;проверка на ошибку</td></tr> <tr><td>JNE OPEN_ERROR </td><td>;</td></tr> <tr><td></td><td>;---устанавливаем размер записи 256 байт</td></tr> <tr><td>LEA BX,FCB </td><td>;DS:DX указывают на FCB</td></tr> <tr><td>MOV AX,256 </td><td>;размер записи</td></tr> <tr><td>MOV DS:[BX]+14,AX </td><td>;посылаем в поле размера записи</td></tr> <tr><td></td><td>;---чтение данных</td></tr> <tr><td>MOV CX,2 </td><td>;число читаемых записей</td></tr> <tr><td>NEXT_REC: MOV AH,14H </td><td>;функция чтения файла</td></tr> <tr><td>LEA DX,FCB </td><td>;DS:DX указывают на FCB</td></tr> <tr><td>INT 21H </td><td>;читаем одну запись</td></tr> <tr><td>CMP AL,0 </td><td>;все в порядке?</td></tr> <tr><td>JE CONTINUE </td><td>;</td></tr> <tr><td>CMP AL,2 </td><td>;проверка на ошибку</td></tr> <tr><td>JE READ_ERROR </td><td>;</td></tr> <tr><td>.</td><td></td></tr> <tr><td>.</td><td></td></tr> <tr><td>CONTINUE: ADD DI,256 </td><td>;увеличиваем указатель</td></tr> <tr><td>MOV DX,DI </td><td>;DX указывает на новую DTA</td></tr> <tr><td>MOV AH,1AH </td><td>;функция установки DTA</td></tr> <tr><td>INT 21H </td><td>;устанавливаем DTA</td></tr> <tr><td>LOOP NEXT_REC </td><td>;идем на чтение следующей записи</td></tr> <tr><td></td><td>;---позднее, закрываем файл</td></tr> <tr><td>LEA DX,FCB </td><td>;DS:DX указывают на FCB</td></tr> <tr><td>MOV AH,10H </td><td>;функция закрытия файла</td></tr> <tr><td>INT 21H </td><td>;закрываем файл</td></tr> <tr><td>CMP AL,0FFH </td><td>;проверка на ошибку</td></tr> <tr><td>JE CLOSE_ERROR </td><td>;</td></tr> </table> Метод дескриптора файлов: <p> Функция 3FH прерывания 21H может читать данные из файла последовательно. Эта функция используется для любого чтения из файла с помощью метода дескриптора файлов, включая файлы прямого доступа. Файл должен быть открыт функцией 3DH прерывания 21H с кодом 0 в AL, если он открывается только для чтения, и с кодом 2 - если он открывается для чтения и записи. При открытии файловый указатель автоматически устанавливается на первый байт файла. Функция чтения из файла указывает сколько байтов должно быть считано и после того как это сделано файловый указатель указывает на байт, следующий за последним считанным байтом, подготавливая следующее обращение к функции. Отметим, что файловый указатель уникален для каждого файла - операции над другими файлами не меняют его позицию. <p> Программа может создать небольшой временный буфер, размером, скажем, 512 байт, и постоянно вызывать функцию чтения, не заботясь о позиции файлового указателя. Другой метод состоит в считывании всего файла прямо в то место памяти, где он должен быть расположен. В этом случае надо просто потребовать, чтобы функция прочитала больше байтов, чем реально содержится в файле, так как чтение прекращается при достижении последнего байта файла. Однако Вам необходимо знать точную длину файла, чтобы знать где кончаются данные в буфере, в который Вы считали файл. <p> Размер файла можно определить, сдвинув файловый указатель на конец файла. Это надо сделать сразу же после открытия файла. Поместите в AL код 2 и вызовите функцию 42H, для того, чтобы сдвинуть указатель на конец файла. CX и DX должны содержать 0, так как в противном случае указатель будет сдвинут с конца файла на величину, которая содержится в этих регистрах. При возврате DX:AX будут содержать новую позицию указателя, как смещение относительно начала файла, т.е., в данном случае, длину файла. Hе забудьте снова вернуть файловый указатель на начало файла, перед тем как читать его; это делается точно таким же образом, за исключением того, что в AL надо поместить 0. Если при выполнении функции 42H возникает ошибка, то устанавливается флаг переноса, а в AX возвращается 1, если неверен номер функции, и 6 - если указан неверный номер файла. <p> Теперь программа готова для чтения файла. Hадо поместить номер файла в BX, а требуемое число байтов в CX и выполнить прерывание. При возврате AX будет содержать число реально прочитанных байтов. Если AX равен нулю, то достигнут конец файла. При других ошибках устанавливается флаг переноса, а AX содержит 5 - при ошибке оборудования и 6 - если указан неверный номер файла. В следующем примере в буфер памяти считывается весь небольшой файл. Для удобства буфер располагается в сегменте данных, что существенно увеличивает размер программы на диске. В своих программах лучше создавать буфер, используя технику распределения памяти, описанную в {<a href="131.htm">1.3.1</a>}. <table align="center"> <tr><td></td><td>;---в сегменте данных</td></tr> <tr><td>PATH DB 'A:FILENAME.EXT'0 </td><td>;строка пути к файлу</td></tr> <tr><td>DATA_BUFFER DB 1000 DUP (?) </td><td>;буфер данных</td></tr> <tr><td>HANDLE DW ? </td><td>;номер файла</td></tr> <tr><td>FILESIZE DW ? </td><td>;размер файла</td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---открываем файл</td></tr> <tr><td>LEA DX,PATH </td><td>;DS:DX указывают на путь</td></tr> <tr><td>MOV AL,0 </td><td>;код открытия для чтения</td></tr> <tr><td>MOV AH,3DH </td><td>;функция открытия файла</td></tr> <tr><td>INT 21H </td><td>;открываем файл</td></tr> <tr><td>JC OPEN_ERROR </td><td>;проверка на ошибку</td></tr> <tr><td>MOV HANDLE,AX </td><td>;запоминаем номер файла</td></tr> <tr><td></td><td>;---устанавливаем файловый указатель на конец файла</td></tr> <tr><td>MOV AH,42H </td><td>;функция установки указателя</td></tr> <tr><td>MOV AL,2 </td><td>;код для конца файла</td></tr> <tr><td>MOV BX,HANDLE </td><td>;номер файла</td></tr> <tr><td>MOV CX,0 </td><td>;смещение равно нулю</td></tr> <tr><td>MOV DX,0 </td><td>;</td></tr> <tr><td>INT 21H </td><td>;устанавливаем указатель</td></tr> <tr><td>JC POINTER_ERROR1 </td><td>;обработка ошибки</td></tr> <tr><td>MOV FILESIZE,AX </td><td>;запоминаем размер (меньше 64K)</td></tr> <tr><td></td><td>;---возвращаем указатель на начало</td></tr> <tr><td>MOV AH,42H </td><td>;номер функции</td></tr> <tr><td>MOV AL,0 </td><td>;код для начала файла</td></tr> <tr><td>MOV CX,0 </td><td>;смещение равно нулю</td></tr> <tr><td>MOV DX,0 </td><td>;</td></tr> <tr><td>INT 21H </td><td>;устанавливаем указатель</td></tr> <tr><td>JC POINTER_ERROR2 </td><td>;обработка ошибки</td></tr> <tr><td></td><td>;---читаем весь файл</td></tr> <tr><td>MOV AH,3FH </td><td>;номер функции чтения файла</td></tr> <tr><td>MOV BX,HANDLE </td><td>;номер файла</td></tr> <tr><td>MOV CX,FILESIZE </td><td>;число считываемых байтов</td></tr> <tr><td>LEA DX,DATA_BUFFER </td><td>;DS:DX указывают на буфер</td></tr> <tr><td>INT 21H </td><td>;читаем файл</td></tr> <tr><td>JC READ_ERROR </td><td>;обработка ошибки</td></tr> <tr><td></td><td></td></tr> <tr><td></td><td>;---позднее, закрываем файл</td></tr> <tr><td>MOV BX,HANDLE </td><td>;номер файла</td></tr> <tr><td>MOV AH,3EH </td><td>;функция закрытия файла</td></tr> <tr><td>INT 21H </td><td>;закрываем файл</td></tr> <tr><td>JC CLOSE_ERROR </td><td>;обработка ошибки</td></tr> </table> <hr><p align="center">
<~-<a href="543.htm">5.4.3 Запись в последовательные файлы.</a><br><a href="index.htm#header">Содержание</a><br><a href="545.htm">5.4.5 Запись в файлы прямого доступа.</a>-~>
</p></body></html>
