<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Аппаратное обеспечение IBM PC</TITLE>
<link rel=stylesheet type=text/css href="../../images/styles.css">
<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.04z">
</HEAD>
<body>
<H1>6.&nbsp;ПОРТ ПОСЛЕДОВАТЕЛЬНОЙ ПЕРЕДАЧИ ДАННЫХ</H1>
<P>
6.1. <A HREF="#ch6_1">Основные понятия и термины</A>
<P>
6.2. <A HREF="#ch6_2">Аппаратная реализация</A>
<P>
6.3. <A HREF="#ch6_3">Порты асинхронного адаптера</A>
<P>
6.4. <A HREF="#ch6_4">Поддержка асинхронного адаптера в BIOS</A>
<P>
6.5. <A HREF="#ch6_5">Программирование асинхронного адаптера </A>
<BR>
<P>
Эта глава посвящена порту последовательной передачи данных. Его
называют еще портом RS-232-C, или асинхронным адаптером RS-232-C.
Компьютер IBM&nbsp;PC поддерживает интерфейс RS-232-C не в полной
мере, скорее разъем, обозначенный на корпусе компьютера как порт
последовательной передачи данных, содержит некоторые из сигналов,
входящих в интерфейс RS-232-C и имеющих соответствующие этому
стандарту уровни напряжения.
<P>
В настоящее время порт последовательной передачи данных используется
очень широко. Вот далеко не полный список применений:
<UL>
<LI>подключение мыши;
<LI>подключение графопостроителей (плоттеров), сканеров, принтеров,
диджитайзеров;
<LI>связь двух компьютеров через порты последовательной передачи
данных с использованием специального кабеля и таких программ,
как FastWire II или Norton Commander;
<LI>подключение модемов для передачи данных по телефонным линиям;
<LI>подключение к сети персональных компьютеров.
</UL>
<P>
Практически каждый компьютер оборудован хотя бы одним портом для
последовательной передачи данных.
<H2><A NAME="ch6_1">6.1. Основные понятия и термины</A></H2>
<P>
Последовательная передача данных означает, что данные передаются
с использованием единственной линии. При этом биты байта данных
передается по очереди с использованием одного провода. Для синхронизации
группе битов обычно предшествует специальный стартовый бит, после
группы битов следуют бит проверки на четность и один или два стоповых
бита. Иногда бит проверки на четность может отсуствовать.
<P>
Сказанное иллюстрируется следующим рисунком:
<PRE>
<FONT COLOR=#000080>     START 0   1   2   3   4   5   6   7   P    STOP

-----¬   ----T---T---T---T---T---T---T---T---¬       -----
     ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦ 
     ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦   ¦ 
     L----                                   L---+---- 

</FONT>
</PRE>
<P>
Из рисунка видно, что исходное состояние линии последовательной
передачи данных - уровень логической 1. Стартовый бит START сигнализирует
о начале передачи данных. Далее передаются биты данных, вначале
младшие, затем старшие. Если используется бит четности P, то передается
и он. Бит четности имеет такое значение, чтобы в пакете битов
общее количество единиц (или нулей) было четно или нечетно.
<P>
В самом конце передаются один или два стоповых бита STOP, завершающих
передачу байта. Затем уровень линии передачи снова устанавливается
в 1 до прихода следующего стартового бита.
<P>
Использование четности, стартовых и стоповых битов определяют
протокол передачи данных. Очевидно, что передатчик и приемник
данных должны использовать один и тот же протокол, иначе связь
будет невозможной.
<P>
Другая важная характеристика - скорость передачи данных. Она также
должна быть одинаковой для передатчика и приемника.
<P>
Скорость передачи данных обычно измеряется в бодах. Боды - это
количество передаваемых битов в секунду. При этом учитываются
и старт/стопные биты, а также бит четности.
<P>
Иногда используется другой термин - биты в секунду (bps). Здесь
имеется в виду эффективная скорость передачи данных, без учета
служебных битов.
<H2><A NAME="ch6_2">6.2. Аппаратная реализация</A></H2>
<P>
Компьютер может быть оснащен одним или двумя портами последовательной
передачи данных. Эти порты расположены либо на материнской плате,
либо на отдельной плате, вставляемой в слоты расширения материнской
платы.
<P>
Бывают также платы, содержащие 4 или 8 портов последовательной
передачи данных. Их часто используют для подключения нескольких
компьютеров или терминалов к одному, центральному, компьютеру.
<P>
В основе последовательного порта передачи данных лежит микросхема
Intel 8250. Это универсальный асинхронный приемо-передатчик (UART
- Universal Asynchronous Receiver Transmitter). Микросхема содержит
несколько внутренних регистров, доступных через команды ввода/вывода.
<P>
Микросхема 8250 содержит регистры передатчика и приемника данных.
При передаче байта он записывается в буферный регистр передатчика,
откуда затем переписывается в сдвиговый регистр передатчика. Байт
&quot;выдвигается&quot; из сдвигового регистра по битам.
<P>
Аналогично имеются сдвиговый и буферный регистры приемника.
<P>
Программа имеет доступ только к буферным регистрам, копирование
информации в сдвиговые регистры и процесс сдвига выполняется микросхемой
8250 автоматически.
<P>
Внешние устройства подключаются к порту ввода/вывода через разъем
DB25P (имеющий 25 выводов) или DB9P (имеющий 9 выводов). Приведем
разводку разъема последовательной передачи данных DB25P:
<PRE>
<FONT COLOR=#000080>Номер контакта  Назначение контакта     Вход или выход


1               Защитное заземление     -

2               Передаваемые данные     Выход
                (Transmitted Data)

3               Принимаемые данные      Вход
                (Received Data)

4               Запрос для передачи     Выход
                (Request to send, RTS)

5               Сброс для передачи      Вход
                (Clear to Send, CTS)

6               Готовность данных       Вход
                (Data Set Ready, DSR)

7               Сигнальное заземление   -

8               Детектор принимаемого   Вход
                с линии сигнала
                (Data Carrier Detect,
                DCD)

9-19            Не используются

20              Готовность выходных     Выход
                данных
                (Data Terminal Ready,
                DTR)

21              Не используется

22              Индикатор вызова        Вход
                (Ring Indicator, RI)

23-25           Не используется

</FONT>
</PRE>
<P>
Наряду с 25-контактным разъемом часто используется 9-контактный
разъем:
<PRE>
<FONT COLOR=#000080>Номер контакта  Назначение контакта     Вход или выход


1               Детектор принимаемого   Вход
                с линии сигнала
                (Data Carrier Detect,
                DCD)

2               Принимаемые данные      Вход
                (Received Data)

3               Передаваемые данные     Выход
                (Transmitted Data)

4               Готовность выходных     Выход
                данных
                (Data Terminal Ready,
                DTR)

5               Сигнальное заземление   -

6               Готовность данных       Вход
                (Data Set Ready, DSR)

7               Запрос для передачи     Выход
                (Request to send, RTS)

8               Сброс для передачи      Вход
                (Clear to Send, CTS)

9               Индикатор вызова        Вход
                (Ring Indicator, RI)

</FONT>
</PRE>
<P>
Уровни напряжения на линиях разъема составляют для логического
нуля -15 вольт, для логической единицы - +15&nbsp;вольт.
<P>
Доступ к отдельным линиям возможен через порты ввода/вывода асинхронного
адаптера, которые мы рассмотрим в следующем разделе. Там же будет
описано назначение отдельных линий разъема.
<H2><A NAME="ch6_3">6.3. Порты асинхронного адаптера</A></H2>
<P>
На этапе инициализации системы модуль POST BIOS тестирует имеющиеся
асинхронные адаптеры и инициализирует первые два. Их базовые адреса
располагаются в области данных BIOS начиная с адреса 0000:0400h.
<P>
Первый адаптер COM1 имеет базовый адрес 3F8h и занимает диапазон
адресов от 3F8h до 3FFh. Второй адаптер COM2 имеет базовый адрес
2F8h и занимает адреса 2F8h...2FFh.
<P>
Асинхронные адаптеры могут вырабатывать прерывания:
<UL>
<LI>COM1 - IRQ4 (соответствует INT&nbsp;0Ch)
<LI>COM2 - IRQ3 (соответствует INT&nbsp;0Bh)
</UL>
<P>
Рассмотрим назначение отдельных битов этих портов.
<H3>Порт 3F8h.</H3>
<P>
Этот порт соответствует регистру передаваемых данных. Для передачи
в порт 3F8h необходимо записать передаваемый байт данных. После
приема данных от внешнего устройства они могут быть прочитаны
из этого порта.
<P>
В зависимости от состояния старшего бита управляющего слова, выводимого
в управляющий регистр с адресом 3FBh, назначение порта 3F8h может
изменяться. Если этот бит равен 0, порт используется для записи
передаваемых данных. Если же бит равен 1, порт используется для
вывода значения младшего байта делителя частоты тактового генератора.
Изменяя содержимое делителя, можно изменять скорость передачи
данных. Старший байт делителя записывается в порт 3F9h.
<P>
Зависимость скорости передачи данных от значения делителя частоты
представлено в следующей таблице:
<PRE>
<FONT COLOR=#000080>Делитель        Скорость передачи в бодах

1040    110
768     150
384     300
192     600
96      1200
48      2400
24      4800
12      9600
6       19200
3       38400
2       57600
1       115200

</FONT>
</PRE>
<H3>Порт 3F9h.</H3>
<P>
Порт используется либо как регистр управления прерываниями от
асинхронного адаптера либо (после вывода в порт 3F9h байта с установленным
в 1 старшим битом) для вывода значения старшего байта делителя
частоты тактового генератора.
<P>
В режиме регистра управления прерываниями порт имеет следующий
формат:<BR>
<PRE>
<FONT COLOR=#000080> 7 6 5 4 3 2 1 0
T-T-T-T-T-T-T-¬
¦       ¦ ¦ ¦ ¦ ¦
LT+-+-+T+T+T+T+T-
L==T==- ¦ ¦ ¦ L= 1 - разрешение прерывания при готовности
    ¦    ¦ ¦ ¦        принимаемых данных;
    ¦    ¦ ¦ ¦
    ¦    ¦ ¦ L=== 1 - разрешение прерывания после передачи
    ¦    ¦ ¦          байта (когда выходной буфер передачи
    ¦    ¦ ¦          пуст);
    ¦    ¦ ¦
    ¦    ¦ L===== 1 - разрешение прерывания по обнаружению
    ¦    ¦            состояния &quot;BREAK&quot; или по ошибке;
    ¦    ¦
    ¦    L======= 1 - разрешение прерывания по изменению
    ¦                 состояния входных линий на разъеме
    ¦                 RS-232-C (CTS, DSR, RI, DCD);
    ¦
L============ Не используются, должны быть равны 0.

</FONT>
</PRE>
<H3>Порт 3FAh.</H3>
<P>
Регистр идентификации прерывания. Считывая его содержимое, программа
может определить причину прерывания.
<P>
Формат регистра:
<PRE>
<FONT COLOR=#000080>7 6 5 4 3 2 1 0
T-T-T-T-T-T-T-¬
¦         ¦   ¦ ¦
LT+-+-+-+T+T+T+T-
L===T===- L=¦ L= 1  - Нет прерываний, ожидающих
     ¦       ¦         обслуживания.
     ¦       ¦
     ¦       L=== 00 - Прерывание по линии состояния
     ¦                 приемника, возникает при
     ¦                 переполнении приемника, ошибках
     ¦                 четности или формата данных
     ¦                 или при состоянии &quot;BREAK&quot;.
     ¦                 Сбрасывается после чтения состояния
     ¦                 линии из порта 3FDh.
     ¦
     ¦            01 - Данные приняты и доступны для чтения.
     ¦                 Сбрасывается после чтения данных
     ¦                 из порта 3F8h.
     ¦
     ¦            10 - Буфер передатчика пуст. Сбрасывается
     ¦                 при записи новых данных в регистр
     ¦                 данных передатчика, порт 3F8h.
     ¦
     ¦            11 - Состояние модема. Устанавливается при
     ¦                 изменении состояния входных линий
     ¦                 CTS, RI, DCD, DSR. Сбрасывается 
     ¦                 после чтения состояния модема из
     ¦                 порта 3FEh.
     ¦
L========== Должно быть равно 0.

</FONT>
</PRE>
<H3>Порт 3FBh.</H3>
<P>
Управляющий регистр, доступен по записи и чтению.
<PRE>
<FONT COLOR=#000080>7 6 5 4 3 2 1 0
T-T-T-T-T-T-T-¬
¦ ¦ ¦ ¦   ¦ ¦   ¦
LT+T+T+T+T+T+T+T-
¦ ¦ ¦ L=¦ ¦ L=¦= Длина слова в битах:
 ¦ ¦ ¦   ¦ ¦        00 - 5 бит;
 ¦ ¦ ¦   ¦ ¦        01 - 6 бит;
 ¦ ¦ ¦   ¦ ¦        10 - 7 бит;
 ¦ ¦ ¦   ¦ ¦        11 - 8 бит.
 ¦ ¦ ¦   ¦ ¦
 ¦ ¦ ¦   ¦ L===== Количество стоповых бит:
 ¦ ¦ ¦   ¦          0 - 1 бит;
 ¦ ¦ ¦   ¦          1 - 2 бита.
 ¦ ¦ ¦   ¦
 ¦ ¦ ¦   L======= Четность:
 ¦ ¦ ¦              X0 - контроль на четность не
 ¦ ¦ ¦                   используется;
 ¦ ¦ ¦              01 - контроль на нечетность;
 ¦ ¦ ¦              11 - контроль на четность.
 ¦ ¦ ¦
 ¦ ¦ L=========== Фиксация  четности. При установке этого
 ¦ ¦              бита бит четности всегда принимает
 ¦ ¦              значение 0 (если биты 3-4 равны 11) или 1
 ¦ ¦              (если биты 3-4 равны 01).
 ¦ ¦
¦ L============= Установка перерыва. Вызывает вывод
 ¦                строки нулей в качестве сигнала
 ¦                &quot;BREAK&quot; для подключенного устройства.
 ¦
L=============== 1 - порты 3F8h и 3F9h используются
для для загрузки делителя частоты
тактового генератора;
0 - порты используются как обычно.

</FONT>
</PRE>
<H3>Порт 3FCh.</H3>
<P>
Регистр управления модемом. Управляет состоянием выходных линий
DTR, RTS , линий, специфических для модемов OUT1 и OUT2, для запуска
диагностики соединенных вместе замкнутых входе и выходе асинхронного
адаптера.
<P>
Формат порта:
<PRE>
<FONT COLOR=#000080>7 6 5 4 3 2 1 0
T-T-T-T-T-T-T-¬
¦     ¦ ¦ ¦ ¦ ¦ ¦
LT+-+T+T+T+T+T+T-
L=T=- ¦ ¦ ¦ ¦ L= линия DTR;
   ¦   ¦ ¦ ¦ ¦
   ¦   ¦ ¦ ¦ L=== линия RTS;
   ¦   ¦ ¦ ¦
   ¦   ¦ ¦ L===== линия OUT1 (запасная);
   ¦   ¦ ¦
   ¦   ¦ L======= линия OUT2 (запасная);
   ¦   ¦
   ¦   L========= запуск диагностики при входе
   ¦              асинхронного адаптера, замкнутом
   ¦              на его выход;
   ¦
L============= должно быть равно 0.

</FONT>
</PRE>
<H3>Порт 3FDh.</H3>
<P>
Регистр состояния линии.
<PRE>
<FONT COLOR=#000080>7 6 5 4 3 2 1 0
T-T-T-T-T-T-T-¬
¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
LT+T+T+T+T+T+T+T-
 ¦ ¦ ¦ ¦ ¦ ¦ ¦ L= Данные получены и готовы для чтения,
 ¦ ¦ ¦ ¦ ¦ ¦ ¦    сбрасывается при чтении данных.
 ¦ ¦ ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ ¦ ¦ L=== Ошибка переполнения. Был принят новый
 ¦ ¦ ¦ ¦ ¦ ¦      байт данных, а предыдущий еще не был 
 ¦ ¦ ¦ ¦ ¦ ¦      считан программой. Предыдущий байт
 ¦ ¦ ¦ ¦ ¦ ¦      потерян.
 ¦ ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ ¦ L===== Ошибка четности, сбрасывается после
 ¦ ¦ ¦ ¦ ¦        чтения состояния линии.
 ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ L======= Ошибка синхронизации.
 ¦ ¦ ¦ ¦
 ¦ ¦ ¦ L========= Обнаружен запрос на прерывание
 ¦ ¦ ¦            передачи &quot;BREAK&quot; - длинная строка нулей.
 ¦ ¦ ¦
 ¦ ¦ L=========== Регистр хранения передатчика пуст, в него
 ¦ ¦              можно записывать новый байт для передачи.
 ¦ ¦
 ¦ L============= Регистр сдвига передатчика пуст. Этот
 ¦                регистр получает данные из регистра
 ¦                хранения и преобразует их в
 ¦                последовательный вид для передачи.
 ¦
 L=============== Таймаут (устройство не связано с
                  компьютером).

</FONT>
</PRE>
<H3>Порт 3FEh.</H3>
<P>
Регистр состояния модема.
<PRE>
<FONT COLOR=#000080>7 6 5 4 3 2 1 0
T-T-T-T-T-T-T-¬
¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
LT+T+T+T+T+T+T+T-
 ¦ ¦ ¦ ¦ ¦ ¦ ¦ L= линия CTS изменила состояние
 ¦ ¦ ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ ¦ ¦ L=== линия DSR изменила состояние
 ¦ ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ ¦ L===== линия RI изменила состояние
 ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ L======= линия DCD изменила состояние
 ¦ ¦ ¦ ¦
 ¦ ¦ ¦ L========= состояние линии CTS
 ¦ ¦ ¦
 ¦ ¦ L=========== состояние линии DSR
 ¦ ¦
 ¦ L============= состояние линии RI
 ¦
 L=============== состояние линии DCD

</FONT>
</PRE>
<H2><A NAME="ch6_4">6.4. Поддержка асинхронного адаптера в BIOS</A>
</H2>
<P>
Мы опишем функции BIOS, облегчающие обслуживание двух асинхронных
адаптеров, COM1 и COM2. Эти функции доступны через прерывание
INT&nbsp;14h.
<P>
Первая функция предназначена для инициализации портов асинхронного
адаптера:
<PRE>
<FONT COLOR=#000080>На входе:       AH = 00h;

                DX = номер порта: 0 - COM1, 1 - COM2;

                AL = параметры инициализации (см. дальше).

На выходе:      AH = состояние порта асинхронного адаптера;

                AL = состояние модема.

</FONT>
</PRE>
<P>
При вызове этой функции регистр AL должен содержать параметры
инициализации:
<PRE>
<FONT COLOR=#000080>7 6 5 4 3 2 1 0
T-T-T-T-T-T-T-¬
¦     ¦   ¦ ¦   ¦
LT+-+T+T+T+T+T+T-
L=T=- L=¦ ¦ L=¦= Длина слова в битах:
   ¦     ¦ ¦        00 - 5 бит;
   ¦     ¦ ¦        01 - 6 бит;
   ¦     ¦ ¦        10 - 7 бит;
   ¦     ¦ ¦        11 - 8 бит.
   ¦     ¦ ¦
   ¦     ¦ L===== Количество стоповых бит:
   ¦     ¦          0 - 1 бит;
   ¦     ¦          1 - 2 бита.
   ¦     ¦
   ¦     L======= Четность:
   ¦                X0 - контроль на четность не
   ¦                     используется;
   ¦                01 - контроль на нечетность;
   ¦                11 - контроль на четность.
   ¦
   L============= Скорость передачи данных в бодах:
                    000 - 110
                    001 -   150
                    010 -   300
                    011 -   600
                    100 -   1200
                    101 -   2400
                    110 -   4800
                    111 -   9600

</FONT>
</PRE>
<P>
После вызова функции в регистр AH записывается состояние порта
асинхронного адаптера:
<PRE>
<FONT COLOR=#000080>7 6 5 4 3 2 1 0
T-T-T-T-T-T-T-¬
¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
LT+T+T+T+T+T+T+T-
 ¦ ¦ ¦ ¦ ¦ ¦ ¦ L= таймаут, если установлен этот бит,
 ¦ ¦ ¦ ¦ ¦ ¦ ¦    другие биты не имеют значения;
 ¦ ¦ ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ ¦ ¦ L=== регистр сдвига передатчика пуст;
 ¦ ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ ¦ L===== буферный регистр передатчика пуст;
 ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ L======= обнаружено состояние &quot;BREAK&quot;;
 ¦ ¦ ¦ ¦
 ¦ ¦ ¦ L========= ошибка синхронизации;
 ¦ ¦ ¦
 ¦ ¦ L=========== ошибка четности;
 ¦ ¦
 ¦ L============= ошибка переполнения входного регистра;
 ¦
 L=============== данные готовы.

</FONT>
</PRE>
<P>
Регистр AL содержит байт состояния модема:
<PRE>
<FONT COLOR=#000080>7 6 5 4 3 2 1 0
T-T-T-T-T-T-T-¬
¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
LT+T+T+T+T+T+T+T-
 ¦ ¦ ¦ ¦ ¦ ¦ ¦ L= линия CTS изменила состояние;
 ¦ ¦ ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ ¦ ¦ L=== линия DSR изменила состояние;
 ¦ ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ ¦ L===== линия RI изменила состояние;
 ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ L======= линия DCD изменила состояние;
 ¦ ¦ ¦ ¦
 ¦ ¦ ¦ L========= состояние линии CTS;
 ¦ ¦ ¦
 ¦ ¦ L=========== состояние линии DSR;
 ¦ ¦
 ¦ L============= состояние линии RI;
 ¦
 L=============== состояние линии DCD.

</FONT>
</PRE>
<P>
Для передачи байта используется следующая функция:
<PRE>
<FONT COLOR=#000080>На входе:       AH = 01h;

                DX = номер порта: 0 - COM1, 1 - COM2;

                AL = передаваемый байт.

На выходе:      AL сохраняется;

                AH = состояние порта асинхронного адаптера,
                  если бит 7 регистра AH установлен в 1,
                  произошла ошибка.

</FONT>
</PRE>
<P>
Функция 02h предназначена для приема байта:
<PRE>
<FONT COLOR=#000080>На входе:       AH = 02h;

                DX = номер порта: 0 - COM1, 1 - COM2.

На выходе:      AL = принятый байт;

                AH = состояние порта асинхронного адаптера,
                  если регистр AH не равен 0,
                  произошла ошибка.

</FONT>
</PRE>
<P>
Состояние порта асинхронного адаптера можно узнать с помощью функции
03h:
<PRE>
<FONT COLOR=#000080>На входе:       AH = 03h;

                DX = номер порта: 0 - COM1, 1 - COM2.

На выходе:      AH = состояние порта асинхронного адаптера;

                AL = состояние модема.

</FONT>
</PRE>
<H2><A NAME="ch6_5">6.5. Программирование асинхронного адаптера</A>
</H2>
<P>
К сожалению, MS-DOS не содержит сколько-нибудь серьезной поддержки
асинхронного адаптера. Две функции прерывания INT&nbsp;21h с номерами
3 и 4 предназначены для чтения и записи байтов через асинхронный
адаптер. Обе эти функции имеют дело с адаптером COM1 или AUX.
Функция 3 получает в регистре AL символ, принятый из адаптера,
функция 4 посылает в адаптер символ, записанный в регистр DL.
<P>
Основной недостаток функций MS-DOS, предназначенных для работы
с адаптером, заключается в отсуствии их функциональной полноты.
Используя только функции MS-DOS, вы не сможете проанализировать
ошибочные ситуации и изменить режим работы асинхронного адаптера
- нет соответствующих средств.
<P>
Функции BIOS, обслуживающие адаптер, более разнообразны. Однако
и им присущи недостатки. Например, вы не сможете установить скорость
передачи более 9600 бод или использовать режим фиксации четности.
Нет возможности узнать текущий режим асинхронного адаптера, отсутствует
поддержка модема.
<P>
Поэтому для программирования асинхронного адаптера мы рекомендуем
использовать порты ввода/вывода микросхемы 8250.
<P>
6.5.1. <A HREF="#ch6_5_1">Инициализация асинхронного адаптера</A>
<P>
6.5.2. <A HREF="#ch6_5_2">Передача данных</A>
<P>
6.5.3. <A HREF="#ch6_5_3">Прием данных</A>
<P>
6.5.4. <A HREF="#ch6_5_4">Пример программы передачи данных</A>
<P>
6.5.5. <A HREF="#ch6_5_5">Использование прерываний</A>
<H3><A NAME="ch6_5_1">6.5.1. Инициализация асинхронного адаптера</A>
</H3>
<P>
Первое, что должна сделать программа, работающая с асинхронным
адаптером - установить протокол обмена и скорость передачи данных.
После загрузки операционной системы для асинхронных адаптеров
устанавливается скорость 2400 бод, не выполняется проверка на
четность, используются один стоповый бит и восьмибитовая длина
передаваемого символа. Вы можете изменить этот режим командой
MS-DOS MODE.
<P>
Выполнив ввод из порта 3FBh, программа может получить текущий
режим адаптера. Для установки нового режима измените нужные вам
поля и запишите новый байт режима по адресу 3FBh.
<P>
Если вам надо задать новое значение скорости обмена данными, перед
записью байта режима установите старший бит этого байта в 1. Затем
последовательно двумя командами вывода загрузите делитель частоты
тактового генератора. Младший байт запишите в порт 3F8h, старший
- в порт 3F9h.
<P>
Перед началом работы необходимо также проинициализировать регистр
управления прерываниями (порт 3F9h), даже если в вашей программе
не используются прерывания от асинхронного адаптера. Если прерывания
вам не нужны, запишите в этот порт значение 0.
<P>
На этом инициализацию можно считать законченной.
<P>
Для того, чтобы узнать текущее состояние асинхронного адаптера,
вы можете использовать следующую функцию:
<PRE>
<FONT COLOR=#000080>/**
*.Name         aux_stat
*.Title        Определение режима асинхронного адаптера
*
*.Descr        Эта функция считывает текущий режим
*              асинхронного порта и записывает его
*              в структуру с типом AUX_MODE.
*
*.Proto        void aux_stat(AUX_MODE *mode, int port);
*
*.Params       AUX_MODE mode - структура, описывающая
*              протокол и режим работы порта:
*
*         typedef struct _AUX_MODE_ {
*
*          union {
*            struct {
*               unsigned char len : 2, // длина символа
*                    stop         : 1, // число стоп-битов
*                    parity       : 2, // контроль четности
*                    stuck_parity : 1, // фиксация четности
*                    en_break_ctl : 1, // установка перерыва
*                    dlab         : 1; // загрузка регистра 
*                                                           // делителя
*            } ctl_word;
*            char ctl;
*          } ctl_aux;
*
*          unsigned long baud; // скорость передачи данных
*
*         } AUX_MODE;
*
*              int port - номер асинхронного адаптера:
*                 0 - COM1, 1 - COM2
*
*.Return       Ничего
*
*.Sample       aux_test.c
**/

#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

void aux_stat(AUX_MODE *mode, int port) {

        unsigned long b;

// Запоминаем режим адаптера

        mode-&gt;ctl_aux.ctl = (char)inp(0x3fb - 0x100 * port);

// Устанавливаем старший бит режима
// для считывания текушей скорости передачи

        outp(0x3fb - 0x100 * port, mode-&gt;ctl_aux.ctl | 0x80);

// Считываем значение регистра делителя

        b = inp(0x3f9 - 0x100 * port); b = b &lt;&lt; 8;
        b += inp(0x3f8 - 0x100 * port);

// Преобразуем его в боды

        switch (b) {
                case 1040: b = 110; break;
                case 768: b = 150; break;
                case 384: b = 300; break;
                case 192: b = 600; break;
                case 96: b = 1200; break;
                case 48: b = 2400; break;
                case 24: b = 4800; break;
                case 12: b = 9600; break;
                case 6: b = 19200; break;
                case 3: b = 38400; break;
                case 2: b = 57600; break;
                case 1: b = 115200; break;
                default: b=0; break;
        }

        mode-&gt;baud = b;

// Восстанавливаем состояние адаптера

        outp(0x3fb - 0x100 * port, mode-&gt;ctl_aux.ctl &amp; 0x7f);

}

</FONT>
</PRE>
<P>
Прочитав состояние адаптера, вы можете изменить нужные вам поля
в структуре AUX_MODE и вызвать функцию aux_init() для изменения
параметров адаптера:
<PRE>
<FONT COLOR=#000080>/**
*.Name         aux_init
*.Title        Инициализация асинхронного адаптера
*
*.Descr        Эта функция инициализирует асинхронные
*              адаптеры, задавая протокол обмена данными
*              и скорость обмена данными.
*
*.Proto        int aux_init(AUX_MODE *mode, int port,
*                                        int imask);
*
*.Params       AUX_MODE *mode - указатель на структуру,
*                               описывающую протокол и режим работы 
*                               порта;
*
*              int port - номер асинхронного адаптера:
*                 0 - COM1, 1 - COM2
*
*              int imask - значение для регистра маски
*                          прерываний
*
*.Return       0 - инициализация выполнена успешно;
*              1 - ошибки в параметрах инициализации.
*
*.Sample       aux_test.c
**/

#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

int aux_init(AUX_MODE *mode, int port, int imask) {

        unsigned div;
        char ctl;

// Вычисляем значение для делителя

        switch (mode-&gt;baud) {
                case 110: div = 1040; break;
                case 150: div = 768; break;
                case 300: div = 384; break;
                case 600: div = 192; break;
                case 1200: div = 96; break;
                case 2400: div = 48; break;
                case 4800: div = 24; break;
                case 9600: div = 12; break;
                case 19200: div = 6; break;
                case 38400: div = 3; break;
                case 57600: div = 2; break;
                case 115200: div =1; break;
                default: return(-1); break;
        }

// Записываем значение делителя частоты

        ctl = inp(0x3fb - 0x100 * port);
        outp(0x3fb - 0x100 * port, ctl | 0x80);

        outp(0x3f9 - 0x100 * port, (div &gt;&gt; 8) &amp; 0x00ff);
        outp(0x3f8 - 0x100 * port, div &amp; 0x00ff);

// Записываем новое управляющее слово

        outp(0x3fb - 0x100 * port, mode-&gt;ctl_aux.ctl &amp; 0x7f);

// Устанавливаем регистр управления прерыванием

        outp(0x3f9 - 0x100 * port, imask);

        return(0);

}

</FONT>
</PRE>
<H3><A NAME="ch6_5_2">6.5.2. Передача данных</A></H3>
<P>
Перед записью байта данных в регистр передатчика необходимо убедиться
в том, что регистр хранения передатчика свободен, то есть убедиться
в том, что передача предыдущего символа завершена.
<P>
Признаком того, что регистр передатчика свободен, является установленный
в 1 бит 5 регистра состояния линии с адресом 3FDh. Следующая функция
ждет окончания передачи текущего символа, затем посылает в асинхронный
адаптер следующий символ:
<PRE>
<FONT COLOR=#000080>/**
*.Name         aux_outp
*.Title        Вывод символа в асинхронный адаптер
*
*.Descr        Эта функция дожидается готовности
*              передатчика и посылает символ.
*
*.Proto        void aux_outp(char chr, int port);
*
*.Params       char chr - посылаемый символ;
*
*              int port - номер асинхронного адаптера:
*                 0 - COM1, 1 - COM2
*
*.Return       Ничего
*
*.Sample       aux_test.c
**/

#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;


void aux_outp(char chr, int port) {

        unsigned status_reg, out_reg;

        status_reg = 0x3fd - 0x100 * port;
        out_reg = status_reg - 5;

        while( (inp(status_reg) &amp; 0x20) == 0 );

        outp(out_reg, chr);

}

</FONT>
</PRE>
<H3><A NAME="ch6_5_3">6.5.3. Прием данных</A></H3>
<P>
Аналогично передаче данных, перед вводом символа из порта приемника
3F8h необходимо убедиться в том, что бит 0 порта 3FDh установлен
в 1. Это означает, что символ принят из линии и находится в буферном
регистре приемника.
<P>
Для приема данных мы подготовили следующую функцию:
<PRE>
<FONT COLOR=#000080>/**
*.Name         aux_inp
*.Title        Ввод символа из асинхронного адаптера
*
*.Descr        Эта функция дожидается готовности
*              приемника и вводит символ из асинхронного
*              адаптера.
*
*.Proto        char aux_inp(int port);
*
*.Params       int port - номер асинхронного адаптера:
*                 0 - COM1, 1 - COM2
*
*.Return       Принятый символ
*
*.Sample       aux_test.c
**/

#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

char aux_inp(int port) {

        unsigned status_reg, inp_reg;

        status_reg = 0x3fd - 0x100 * port;
        inp_reg = status_reg - 5;

        while( (inp(status_reg) &amp; 1) == 0 );

        return(inp(inp_reg));

}

</FONT>
</PRE>
<H3><A NAME="ch6_5_4">6.5.4. Пример программы передачи данных</A>
</H3>
<P>
Приведем пример программы, использующей описанные выше функции
для изменения скорости передачи данных и для проверки асинхронного
адаптера. Для правильной работы программы выход асинхронного адаптера
должен быть соединен с его входом.
<PRE>
<FONT COLOR=#000080>// Программа работает с асинхронным адаптером COM1.
// Для правильной работы необходимо замкнуть
// вместе контакты 2 и 3 разъема COM1.

#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

void main(void);
void main(void) {

        AUX_MODE amd;

        aux_stat(&amp;amd, 0);
        printf(&quot;\nСостояние порта COM1:&quot;
                         &quot;\nКод длины символа:    %d&quot;
                         &quot;\nКод числа стоп-битов: %d&quot;
                         &quot;\nКонтроль четности:    %d&quot;
                         &quot;\nСкорость передачи:    %lu&quot;,
                         amd.ctl_aux.ctl_word.len,
                         amd.ctl_aux.ctl_word.stop,
                         amd.ctl_aux.ctl_word.parity,
                         (unsigned long)amd.baud);

        amd.baud = 115200;

        aux_init(&amp;amd, 0, 0);

        aux_stat(&amp;amd, 0);
        printf(&quot;\nСостояние порта COM1:&quot;
                         &quot;\nКод длины символа:    %d&quot;
                         &quot;\nКод числа стоп-битов: %d&quot;
                         &quot;\nКонтроль четности:    %d&quot;
                         &quot;\nСкорость передачи:    %lu&quot;,
                         amd.ctl_aux.ctl_word.len,
                         amd.ctl_aux.ctl_word.stop,
                         amd.ctl_aux.ctl_word.parity,
                         (unsigned long)amd.baud);

        printf(&quot;\n\nТестирование асинхронного адаптера.&quot;
                         &quot;\nНажимайте клавиши!&quot;
                         &quot;\nДля завершения работы нажмите CTRL-C&quot;
                         &quot;\n&quot;);

        for(;;) {

// Вводим символ с клавиатуры и передаем его
// в асинхронный адаптер

                aux_outp(getch(), 0);

// Вводим символ из асинхронного адаптера и
// отображаем его на экране

                putchar(aux_inp(0));
        }
}

</FONT>
</PRE>
<H3><A NAME="ch6_5_5">6.5.5. Использование прерываний</A></H3>
<P>
Так как процесс последовательной передачи данных протекает достаточно
медленно, имеет смысл выполнять его в фоновом режиме, используя
прерывания по окончанию передачи или приема символа. Напомним,
что порту COM1 соответствует аппаратное прерывание INT&nbsp;0Ch,
а COM2 - INT 0Bh.
<P>
Для разрешения прерываний необходимо установить в 1 биты порта
управления прерываниями 3F9h, соответствующие тем прерываниям,
которые мы желаем обрабатывать.
<P>
Когда произошло прерывание, программа-обработчик прерывания должна
проанализировать причину прерывания, прочитав содержимое порта
идентификации прерывания с адресом 3FAh.
<P>
Не забудьте, что в конце обработчика аппаратного прерывания должна
находится последовательность команд:
<PRE>
<FONT COLOR=#000080>mov     al, 20h
out 20h, al

iret</FONT>
</PRE>
<P>
Может случиться так, что одновременно произойдет несколько прерываний.
В этом случае бит 0 регистра идентификации прерывания будет установлен
в 1. Если такая ситуация имеет место, перед завершением обработки
прерывания вам надо снова прочитать регистр идентификации прерывания
и обработать следующее прерывание. Так следует поступать до тех
пор, пока бит 0 регистра идентификации прерывания не станет равным
нулю.
</BODY>
</HTML>
