<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Аппаратное обеспечение IBM PC</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.04z">
</HEAD>
<link rel=stylesheet type=text/css href="../../images/styles.css">
<body>
<H1>11.&nbsp;ДОПОЛНИТЕЛЬНАЯ ПАМЯТЬ</H1>
<P>
11.1. <A HREF="#ch11_1">Драйверы дополнительной памяти</A>
<P>
11.2. <A HREF="#ch11_2">Проверка подключения драйвера</A>
<P>
11.3. <A HREF="#ch11_3">Вызов функций драйвера</A>
<P>
11.4. <A HREF="#ch11_4">Стандартные функции EMM</A>
<P>
11.5. <A HREF="#ch11_5">Дополнительные функции EMM</A>
<P>
11.6. <A HREF="#ch11_6">Коды ошибок</A>
<P>
11.7. <A HREF="#ch11_7">Программа, использующая EMS </A>
<P>
В отличие от расширенной памяти дополнительная память с помощью
специальной аппаратуры и программного обеспечения отображается
в диапазон адресов, лежащий ниже границы 1 Мбайт. Такой способ
пригоден для компьютеров, использующих процессор Intel 8086, не
обладающий возможностью адресации расширенной памяти.
<P>
Чтобы понять, как происходит отображение, вспомним распределение
первого мегабайта оперативной памяти. Область с адресами от 00000
до 9FFFF - это стандартная память размером 640К. (Мы используем
здесь физический 20-разрядный адрес). Диапазон адресов от A0000
до BFFFF используется видеоадаптерами. Наконец, 256 Кбайтов с
адресами C0000 - FFFFF используется для BIOS.
<P>
Однако обычно BIOS не занимает все 256 Кбайтов адресного пространства,
оставляя &quot;окна&quot; размером в десятки килобайтов. С помощью
специальной аппаратуры можно отображать эти окна на участки дополнительной
памяти, как бы &quot;подставляя&quot; участки памяти под адреса
&quot;окон&quot;.
<P>
В практике построения вычислительных систем на основе микропроцессоров
такая техника используется уже давно. Для компьютеров IBM PC/XT/AT
корпорации Lotus Development, Intel и Microsoft разработали спецификацию
расширенной памяти (Expanded Memory Specification - EMS). В настоящий
момент распространены версии 3.2 и 4.0 этой спецификации.
<P>
Существует альтернативная спецификация Extended Expanded Memory
Specification - EEMS), отличающаяся от версии EMS 3.2 в основном
наличием поддержки мультизадачных операционных систем. Эта спецификация
была разработана другой группой крупных производителей компьютерного
оборудования: AST Research, Ashton-Tate, Quadram. Однако эта спецификация
не получила широкого распространения. Версия 4.0 EMS включила
в себя все расширения спецификации EEMS.
<P>
В спецификации EMS в качестве окна для доступа к дополнительной
памяти используются 64 килобайта, расположенные по адресам C0000h
- EFFFFh. Это окно в спецификации называется &quot;page frame&quot;.
Окно разбивается на четыре сегмента по 16 килобайтов. Вся дополнительная
память разбивается на логические страницы (logical page) размером
по 16 килобайтов. Любая логическая страница может быть отображена
на любой сегмент окна доступа. Таким образом, используя четыре
сегмента, программа может адресоваться одновременно к любым четырем
логическим страницам дополнительной памяти.
<P>
На рисунке схематически показано отображение логических страниц
дополнительной памяти на сегменты 64-килобайтного окна, расположенного
в области адресов ПЗУ:
<P>
<IMG SRC="278/pic4.gif">
<H2><A NAME="ch11_1">11.1. Драйверы дополнительной памяти</A>
</H2>
<P>
Для использования дополнительной памяти в компьютер должна быть
вставлена плата дополнительной памяти и в файле CONFIG.SYS подключен
специальный драйвер, который обычно поставляется вместе с платой
памяти. Драйвер выполняет управление дополнительной памятью и
называется EMM (Expanded Memory Manager).
<P>
Операционная система MS-DOS версии 4.01 содержит драйвер XMA2EMS.SYS,
реализующий функции управления дополнительной памятью. Этот драйвер
должен быть подключен в файле CONFIG.SYS следующим образом:
<PRE>
<FONT COLOR=#000080>DEVICE=XMA2EMS.SYS [FRAME=xxxx] [Pnnn=xxxx] [/X:pages]


</FONT>
</PRE>
<P>
Параметр FRAME задает базовый адрес для 64-килобайтового окна
доступа в виде шестнадцатеричного сегментного адреса, например
C000. Этот адрес должен находиться в диапазоне C000 - E000.
<P>
Параметр Pnnn позволяет задать базовый адрес для конкретной страницы
дополнительной памяти. Здесь nnn - это номер страницы (0-255),
xxxx - сегментный адрес в шестнадцатеричном формате. При использовании
параметра FRAME нельзя указывать параметры P0, P1, P2, P3.
<P>
Параметр /X:pages определяет, сколько страниц дополнительной памяти
будет использовано. По умолчанию используется вся дополнительная
память.
<P>
Если ваш компьютер имеет процессор 80386 и расширенную память,
вы можете использовать драйвер EMM386.SYS, поставляемый в составе
MS-DOS версии 4.01. Этот драйвер эмулирует дополнительную память
на расширенной памяти. При этом несколько снижается производительность
системы.
<P>
Драйвер может быть подключен следующим образом:
<PRE>
<FONT COLOR=#000080>     DEVICE=EMM386.SYS [size]  [X:mmmm-nnnn] [Mx]


</FONT>
</PRE>
<P>
Параметр size определяет количество используемой драйвером расширенной
памяти в килобайтах. Значение по умолчанию - 256 Кбайт.
<P>
Параметр X:mmmm-nnnn определяет диапазон памяти, которая не должна
быть использована для размещения окон доступа.
<P>
Параметр Mx задает расположение окна доступа, используемого для
отображения логических страниц дополнительной памяти. Соответствие
параметра x сегментному адресу окна приведено в таблице:
<PRE>
<FONT COLOR=#000080>   x         Адрес окна доступа

   0         C000
   1         C400
   2         C800
   3         CC00
   4         D000
   5         D400
   6         D800
   7         DC00
   8         E000


</FONT>
</PRE>
<H2><A NAME="ch11_2">11.2. Проверка подключения драйвера</A></H2>
<P>
Драйвер дополнительной памяти устанавливает вектор прерывания
INT&nbsp;67h таким образом, что этот вектор указывает на заголовок
драйвера. При изучении драйверов мы рассказывали вам о формате
заголовка. Сейчас для нас важно, что со смещением 10 в заголовке
располагается имя драйвера - &quot;EMMXXXX0&quot;. Следовательно,
для проверки подключения драйвера мы можем, получив адрес заголовка,
сравнить восемь байтов имени устройства со строкой &quot;EMMXXXX0&quot;.
При совпадении мы можем считать, что драйвер дополнительной памяти
установлен.
<P>
Для проверки установки драйвера вы можете использовать следующую
функцию, выполняющую все описанные действия:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ems_init
*.Title        Функция проверяет установку драйвера EMS
*
*.Descr        Эта функция проверяет наличие драйвера EMS
*
*.Proto        int ems_init(void);
*
*.Params       Не используются
*
*.Return       0 - драйвер EMS установлен;
*              1 - драйвер EMS не установлен.
*
*.Sample       ems_test.c
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

int ems_init(void) {

        void (_interrupt _far *EMS_driver_adr)(void);
        char _far *EMS_driver_name;
        char test_name[8];
        int i;

        EMS_driver_adr = _dos_getvect(0x67);

        FP_SEG(EMS_driver_name) = FP_SEG (EMS_driver_adr);
        FP_OFF(EMS_driver_name) = 10;

        for(i=0; i&lt;8; i++) test_name[i] = EMS_driver_name[i];

        if(strncmp(test_name, &quot;EMMXXXX0&quot;, 8) == 0) return(0);
        else return(1);

}


</FONT>
</PRE>
<H2><A NAME="ch11_3">11.3. Вызов функций драйвера</A></H2>
<P>
Для вызова функций драйвера дополнительной памяти программа должна
загрузить код функции в регистр AH, код подфункции (обычно 0)
в регистр AL, и затем вызвать прерывание INT&nbsp;67h.
<P>
После возврата из прерывания в регистр AH будет записано слово
состояния. При успешном выполнении функции оно равно 0.
<H2><A NAME="ch11_4">11.4. Стандартные функции EMM</A></H2>
<P>
Стандартные функции - это небольшое подмножество функций EMM,
необходимое для работы обычных прикладных программ (не резидентных
и не драйверов). Все эти функции поддерживаются EMM версии 3.2.
<H3>11.4.1. Получить состояние EMM</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 4000h.

На выходе:      AH = байт состояния EMM.


</FONT>
</PRE>
<P>
Эта функция используется для проверки состояния драйвера EMM.
Она должна использоваться только после того, как программа убедилась
в наличии драйвера EMM.
<P>
Для получения состояния EMM используйте следующую функцию:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ems_stat
*.Title        Определение состояния драйвера EMS
*
*.Descr        Эта функция возвращает байт состояния
*              драйвера EMS
*
*.Proto        char ems_stat(void);
*
*.Params       Не используются
*
*.Return       Байт состояния драйвера EMS
*
*.Sample       ems_test.c
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

char ems_stat(void) {

        union REGS reg;
        struct SREGS sreg;

        reg.x.ax = 0x4000;
        int86(0x67, &amp;reg, &amp;reg);
        return(reg.h.ah);
}


</FONT>
</PRE>
<H3>11.4.2. Получить сегмент окна</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 4100h.

На выходе:      AH = байт состояния EMM;

                BX = сегмент окна для доступа к логическим
                страницам дополнительной памяти.


</FONT>
</PRE>
<P>
Функция позволяет получить сегмент 64-килобайтного окна, используемого
драйвером EMS для доступа к логическим страницам расширенной памяти.
<PRE>
<FONT COLOR=#000080>/**
*.Name         ems_fram
*.Title        Определение сегмента окна доступа
*
*.Descr        Эта функция возвращает сегментный адрес
*              окна, которое используется для доступа к
*              дополнительной памяти.
*
*.Proto        char ems_fram(unsigned *frame);
*
*.Params       unsigned *frame - Указатель на переменную,
*                 в которую будет записан сегментный
*                 адрес окна доступа.
*
*.Return       Сосотояние EMM.
*
*.Sample       ems_test.c
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

char ems_fram(unsigned *frame) {

        union REGS reg;
        struct SREGS sreg;

        reg.x.ax = 0x4100;
        int86(0x67, &amp;reg, &amp;reg);
        *frame = reg.x.bx;

        return(reg.h.ah);
}


</FONT>
</PRE>
<H3>11.4.3. Получить размер доступной памяти EMS</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 4200h.

На выходе:      AH = байт состояния EMM;

                DX = общее количество 16-килобайтных
                страниц EMS в системе;

                BX = число доступных в настоящее время
                страниц EMS.


</FONT>
</PRE>
<P>
Эта функция позволяет вам получить информацию о наличии и доступности
страниц дополнительной памяти.
<PRE>
<FONT COLOR=#000080>/**
*.Name         ems_page
*.Title        Определение количества страниц EMS
*
*.Descr        Эта функция предназначена для определения
*              общего количества страниц EMS и количества
*              страниц, доступных в настоящее время.
*
*.Proto        char ems_page(unsigned *total, unsigned *free);
*
*.Params       unsigned *total - указатель на переменную,
*                 в которую будет записано общее количество
*                 страниц памяти EMS;
*              unsigned *free - указатель на переменную,
*                 в которую будет записано количество
*                 доступных страниц памяти EMS;
*
*.Return       Сосотояние EMM.
*
*.Sample       ems_test.c
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

char ems_page(unsigned *total, unsigned *free) {

        union REGS reg;

        reg.x.ax = 0x4200;
        int86(0x67, &amp;reg, &amp;reg);
        *total = reg.x.dx;
        *free  = reg.x.bx;

        return(reg.h.ah);
}


</FONT>
</PRE>
<H3>11.4.4. Открыть индекс EMM</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 4300h;

                BX = требуемое в данном пуле количество
                логических страниц.

На выходе:      AH = байт состояния EMM;

                DX = индекс пула EMS, он будет использоваться
                в операциях с пулом логических страниц.


</FONT>
</PRE>
<P>
Эта функция позволяет заказать пул логических страниц (т.е. некоторую
совокупность логических страниц дополнительной памяти). Полученному
пулу присваивается индекс (handle), который указывает на пул и
используется во всех операциях с пулом.
<PRE>
<FONT COLOR=#000080>/**
*.Name         ems_open
*.Title        Открытие индекса пула страниц EMS
*
*.Descr        Эта функция открывает индекс пула страниц
*              EMS, делая доступными логические страницы
*              дополнительной памяти.
*
*.Proto        int ems_open(int n_pages, int *handle);
*
*.Params       int n_pages - количество требуемых логических
*                 страниц;
*              int *handle - указатель на слово, в которое
*                 будет записан индекс полученного пула.
*
*.Return       Байт состояния драйвера EMS
*
*.Sample       ems_test.c
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

int ems_open(int n_pages, int *handle) {

        union REGS reg;

        reg.x.ax = 0x4300;
        reg.x.bx = n_pages;
        int86(0x67, &amp;reg, &amp;reg);

        *handle = reg.x.dx;
        return(reg.h.ah);
}


</FONT>
</PRE>
<H3>11.4.5. Отобразить память</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 44h;

                AL = номер физической страницы окна доступа
                (от 0 до 3);

                BX = номер логической страницы из числа
                находящихся в пуле страниц (от 0 до n-1,
                где n - количество логических страниц
                в пуле);
                для версии EMS 4.0 задание значения
                0FFFFh приводит к запрещению отображения
                физических страниц пула, для разрешения
                их отображения необходимо вызвать эту
                функцию еще раз, указав правильный
                номер страницы;

                DX = индекс EMM, полученный от функции 43h.

На выходе:      AH = байт состояния EMM.


</FONT>
</PRE>
<P>
Функция выполняет отображение (привязку) одной из логических страниц
пула к одному их четырех 16-килобайтных сегментов окна просмотра,
т.е. к физическим страницам.
<PRE>
<FONT COLOR=#000080>/**
*.Name         ems_map
*.Title        Отобразить память EMS
*
*.Descr        Эта функция отображает логические страницы
*              пула дополнительной памяти на физические.
*
*.Proto        int ems_map(int phys_page, int log_page,
*                          int handle);
*
*.Params       int phys_pages - номер физической страницы
*                 окна доступа (от 0 до 3), на которую необходимо
*                 отобразить логическую страницу пула;
*
*              int_log_page - номер логической страницы пула;
*
*              int *handle - индекс полученного пула;
*
*.Return       Байт состояния драйвера EMS
*
*.Sample       ems_test.c
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

int ems_map(int phys_page, int log_page, int handle) {

        union REGS reg;

        reg.h.ah = 0x44;
        reg.h.al = phys_page;
        reg.x.bx = log_page;
        reg.x.dx = handle;
        int86(0x67, &amp;reg, &amp;reg);

        return(reg.h.ah);
}


</FONT>
</PRE>
<H3>11.4.6. Закрыть индекс EMM</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 4500h;

                DX = индекс EMM.

На выходе:      AH = байт состояния EMM.



</FONT>
</PRE>
<P>
Функция освобождает все логические страницы пула. После освобождения
эти страницы могут быть повторно распределены.
<PRE>
<FONT COLOR=#000080>/**
*.Name         ems_clos
*.Title        Закрытие индекса пула страниц EMS
*
*.Descr        Эта функция закрывает индекс пула страниц,
*              полученный функцией ems_open().
*
*.Proto        int ems_clos(int *handle);
*
*.Params       int *handle - указатель на слово, в которое
*                 будет записан индекс полученного пула.
*
*.Return       Байт состояния драйвера EMS
*
*.Sample       ems_test.c
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

int ems_clos(int *handle) {

        union REGS reg;

        reg.x.ax = 0x4500;
        reg.x.dx = *handle;
        int86(0x67, &amp;reg, &amp;reg);

        return(reg.h.ah);
}


</FONT>
</PRE>
<H3>11.4.7. Получить номер версии EMM</H3>
<PRE>
<FONT COLOR=#000080>На входsе:      AX = 4600h.

На выходе:      AH = байт состояния EMM;

                AL = номер версии в двоично-десятичном (BCD)
                формате, 32h соответствует версии 3.2.


</FONT>
</PRE>
<P>
Версия 4.0 EMM поддерживает больше функций по управлению дополнительной
памятью, чем версия 3.2. Прежде чем использовать такие функции,
следует определить номер используемой версии EMM с помощью функции
46h.
<PRE>
<FONT COLOR=#000080>/**
*.Name         ems_ver
*.Title        Определение версии драйвера EMS
*
*.Descr        Эта функция возвращает номер версии
*              драйвера EMS в двоично-десятичном формате.
*
*.Proto        int ems_ver(char *ver);
*
*.Params       char *ver - указатель на байт, в который
*                 будет записан номер версии.
*
*.Return       Номер версии драйвера EMS в формате BCD
*
*.Sample       ems_test.c
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

int ems_ver(char *ver) {

        union REGS reg;

        reg.x.ax = 0x4600;
        int86(0x67, &amp;reg, &amp;reg);

        *ver = reg.h.al;
        return(reg.h.ah);
}


</FONT>
</PRE>
<H2><A NAME="ch11_5">11.5. Дополнительные функции EMM</A></H2>
<P>
Дополнительные функции используются резидентными программами,
драйверами и мультизадачными приложениями. Кроме того, с помощью
этих функций можно выполнять пересылку массивов в дополнительной
и стандартной памяти, а также организовать подкачку и выполнение
программных модулей в дополнительной памяти.
<P>
Обратите внимание, что использование расширенной памяти в спецификации
XMS позволяет выполнять программные модули (с ограничениями) только
в области HMA размером примерно 64 килобайта. Остальная расширенная
память может быть использована только для хранения данных.
<P>
Специальные функции с номерами 47h - 4Eh поддерживаются EMM версии
3.2, функции с номерами 4Fh - 58h - только EMM версии 4.0.
<H3>11.5.1. Сохранить контекст отображения</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 4700h;

                DX = индекс EMM.

На выходе:      AH = байт состояния EMM.


</FONT>
</PRE>
<P>
Эта функция предназначена для использования драйверами и резидентными
программами. Прежде чем работать с дополнительной памятью, такие
программы должны сохранить текущий контекст отображения логических
страниц. Перед возвратом управления прикладной программе контекст
должен быть восстановлен с помощью функции 48h.
<H3>11.5.2. Восстановить контекст отображения</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 4800h;

                DX = индекс EMM.

На выходе:      AH = байт состояния EMM.


</FONT>
</PRE>
<P>
Функция позволяет восстановить контекст отображения логических
страниц пула, сохраненный предыдущей функцией.
<H3>11.5.3. Определить количество страниц в пуле</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 4B00h;

                DX = индекс EMM.

На выходе:      AH = байт состояния EMM;

                BX = количество логических страниц в пуле.


</FONT>
</PRE>
<P>
Функция возвращает количество логических страниц дополнительной
памяти для выбранного пула.
<H3>11.5.4. Определить количество активных пулов</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 4C00h;

                DX = индекс EMM.

На выходе:      AH = байт состояния EMM;

                BX = количество активных пулов дополнительной
                памяти.


</FONT>
</PRE>
<P>
Функция предназначена для определения количества текущих активных
пулов и может вызываться перед использованием следующей функции
(с номером 4Dh).
<H3>11.5.5. Получить информацию о пулах</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 4D00h;

                ES:DI = адрес буфера для информации.

На выходе:      AH = байт состояния EMM;

                BX = количество активных пулов дополнительной
                памяти.


</FONT>
</PRE>
<P>
После вызова функции буфер заполняется как массив структур, содержащих
два 16-битовых слова. Первое слово содержит индекс пула, второе
- количество логических страниц в этом пуле.
<H3>11.5.6. Получить/установить отображение всех страниц</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 4Eh;

                AL = код подфункции:

                0 - получить содержимое всех регистров
                         отображения в буфер ES:DI;

                1 - восстановить содержимое всех регистров
                         отображения из буфера ES:DI;

                2 - получить и установить все регистры
                         отображения в буфер ES:DI
                         или восстановить из буфера ES:DI 
                         (т.е. комбинация подфункций 0 и 1);

                3 - Определить размер требуемого буфера;
 
                ES:DI = адрес буфера для информации;

На выходе:      AH = байт состояния EMM;

                AL = для подфункции 3 - размер буфера.


</FONT>
</PRE>
<P>
Эта функция предназначена для поддержки мультизадачности. Она
позволяет быстро изменять контекст дополнительной памяти при переключении
с одного процесса на другой.
<H3>11.5.7. Получить/установить отображение части страниц</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 4Fh;

                AL = код подфункции:

                0 - получить содержимое регистров
                         отображения в буфер ES:DI;

                1 - восстановить содержимое регистров
                         отображения из буфера ES:DI;

                2 - определить размер требуемого буфера;

                ES:DI = адрес буфера для информации;

                DS:SI = адрес массива 16-битовых слов,
                        содержащих сегментные адреса страниц,
                        для которых необходимо сохранить
                        контекст отображения; самое первое
                        слово массива - это размер массива
                        в словах.

На выходе:      AH = байт состояния EMM;

                AL = для подфункции 2 - размер буфера.


</FONT>
</PRE>
<P>
Функция работает аналогично предыдущей, но позволяет сохранять
контексты только для некоторых страниц. Это экономит время, необходимое
для сохранения/восстановления.
<H3>11.5.8. Отображение/запрещение группы страниц</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 50h;

                AL = код подфункции:

                0 - разрешить или запретить отображение
                         страниц, используя номера страниц;

                1 - аналогично подфункции 0, но
                         используются не номера страниц, а
                         адреса сегментов;

                DS:SI = адрес массива структур, состоящий из
                        двух слов, первое слово - номер
                        логической страницы, второе -
                        номер физической страницы;
                        указание логической страницы 0FFFFh
                        запрещает отображение страницы;

                CX = размер массива DS:SI в количестве
                структур.

На выходе:      AH = байт состояния EMM.


</FONT>
</PRE>
<P>
Функция позволяет за один вызов разрешить и запретить использование
нескольких страниц.
<H3>11.5.9. Изменение размера пула</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 5100h;

                BX = новый размер пула в логических страницах;

                DX = индекс EMM.

На выходе:      AH = байт состояния EMM.


</FONT>
</PRE>
<P>
С помощью этой функции программа может изменить размер уже заказанного
ранее пула страниц дополнительной памяти.
<H3>11.5.10. Получить/установить атрибуты пула</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 52h;

                AL = код подфункции:

                0 - получить атрибуты пула;

                1 - установить атрибуты пула;

                2 - определить возможность использования
                         атрибута неразрушаемой памяти;

                BL = новые атрибуты;
 
                DX = индекс EMM.

На выходе:      AH = байт состояния EMM;

                AL = для подфункции 0: атрибуты пула;

                для подфункции 2:

                        0 - атрибут неразрушаемой памяти
                                недоступен;

                        1 - атрибут неразрушаемой памяти
                                доступен.


</FONT>
</PRE>
<P>
Функция дает возможность установить для некоторых пулов атрибут
неразрушаемой памяти. Содержимое таких пулов не исчезает при теплой
перезагрузке операционной системы (после нажатии комбинации клавиш
Ctrl-Alt-Del).
<H3>11.5.11. Установить/прочитать имя пула</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 53h;

                AL = код подфункции:

                0 - получить имя пула;
                1 - установить имя пула;

                ES:DI = адрес буфера имени пула, длина
                        этого буфера должна быть 8 байтов;

                DX = индекс EMM.

На выходе:      AH = байт состояния EMM.


</FONT>
</PRE>
<P>
Функция предназначена для использования в мультизадачной среде.
Она позволяет нескольким процессам, работающим одновременно, использовать
одни и те же именованные пулы дополнительной памяти.
<H3>11.5.12. Найти имя пула</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 54h;

                AL = код подфункции:

                0 - получить каталог пулов;
                1 - найти пул по имени;
                2 - определить количество открытых пулов;

                DS:SI = адрес буфера имени пула для
                        подфункции 1, длина
                        этого буфера должна быть 8 байтов;

                ES:DI = адрес массива 10-байтовых элементов;
                        в первое слово элемента будет
                        записан индекс пула, в остальные 8 -
                        имя пула.

На выходе:      AH = байт состояния EMM;

                AL = количество элементов в  массиве
                  (подфункция 0);

                DX = индекс найденного пула (для 
                  подфункции 1);

                BX = количество открытых пулов (для
                  подфункции 2).


</FONT>
</PRE>
<P>
Эта функция позволяет определить индекс пула по его имени или
получить каталог всех именованных пулов.
<H3>11.5.13. Отобразить страницу и перейти по адресу</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 55h;

                AL = код подфункции:

                0 - использовать массив номеров
                         физических страниц;

                1 - использовать массив сегментных
                         адресов;

                DS:SI = адрес структуры MapAndJump длиной
                        9 байтов.

На выходе:      AH = байт состояния EMM.


</FONT>
</PRE>
<P>
Эта функция предназначена для перекачки страниц исполняемого кода
в память и последующего выполнения этого кода.
<P>
Первые четыре байта структуры MapAndJump содержат смещение и сегментный
адрес, по которым должен быть выполнен переход. Следующий байт
- количество элементов в таблице отображения. Последние 4 байта
содержат FAR-адрес таблицы отображения, состоящей из 4-байтовых
элементов. Первое слово элемента таблицы отображения - номер логической
страницы, второе - номер физической страницы.
<H3>11.5.14. Отобразить страницу и вызвать процедуру</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 56h;

                AL = код подфункции:

                0 - использовать массив номеров
                         физических страниц;

                1 - использовать массив сегментных
                         адресов;

                2 - получить размер стека, необходимого
                         для использования подфункций 0 и 1;

                DS:SI = адрес структуры MapAndCall длиной
                        22 байта.

На выходе:      AH = байт состояния EMM;

                BX = требуемый размер стека (заполняется при
                  выполнении подфункции 2).


</FONT>
</PRE>
<P>
Функция работает аналогично предыдущей, но не передает управление
исполняемому коду, а вызывает его как процедуру.
<P>
Первые 9 байтов структуры MapAndCall соответствуют структуре MapAndJump.
Далее идет еще один байт длины таблицы отображения и 4 байта адреса
другой таблицы отображения. Вторая таблица описывает отображение
страниц, которое будет установлено после вызова процедуры. Последние
8 байтов структуры зарезервированы для дальнейшего использования.
<H3>11.5.15. Переслать/обменять область памяти</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 57h;

                AL = код подфункции:

                0 - переслать область памяти;
                1 - обменять область памяти;

                DS:SI = адрес структуры MoveInfo длиной
                        18 байтов.

На выходе:      AH = байт состояния EMM.


</FONT>
</PRE>
<P>
Функция предназначена для выполнения перемещения или обмена содержимого
областей стандартной или дополнительной памяти. Возможно перекрытие
исходной и результирующей областей памяти. Максимальный размер
блоков, над которыми эта функция может выполнять операции - 1
мегабайт.
<P>
Структура MoveInfo содержит всю необходимую информацию о расположении
блоков памяти:
<PRE>
<FONT COLOR=#000080>Смещение  Размер   Описание


(+0)      4        Размер блока в байтах

(+4)      1        Тип исходной памяти:
                     0 - стандартная, 1 - EMS

(+5)      2        Индекс исходной памяти:
                     0 для стандартной памяти,
                     индекс пула для EMS

(+7)      2        Смещение для исходной памяти (внутри
                     сегмента или страницы)

(+9)      2        Адрес исходного сегмента или номер
                     для исходной страницы

(+11)     1        Тип результирующей памяти:
                     0 - стандартная, 1 - EMS

(+12)     2        Индекс результирующей памяти:
                     0 для стандартной памяти,
                     индекс пула для EMS

(+14)     2        Смещение для результирующей памяти
                   (внутри сегмента или страницы)

(+16)     2        Адрес результирующего сегмента или
                     номер для исходной страницы


</FONT>
</PRE>
<P>
Получить массив адресов отображения
<PRE>
<FONT COLOR=#000080>На входе:       AH = 58h;

                AL = код подфункции:

                0 - получить массив отображения;
                1 - получить размер массива отображения;

                ES:DI = адрес буфера для массива отображения.

На выходе:      AH = байт состояния EMM;

                CX = количество элементов в массиве
                отображения (для подфункции 1)


</FONT>
</PRE>
<P>
Массив отображения, получаемый при помощи этой функции, состоит
из 4-байтовых элементов. Первое слово элемента содержит адрес
сегмента, второе - номер физической страницы, соответствующей
этому адресу.
<H2><A NAME="ch11_6">11.6. Коды ошибок</A></H2>
<P>
Все функции EMM возвращают код ошибки в регистре AH:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=54>Код</TD><TD WIDTH=402>Ошибка</TD></TR>
<TR><TD WIDTH=54>00h</TD><TD WIDTH=402>Нет ошибки, нормальное завершение
</TD></TR>
<TR><TD WIDTH=54>80h</TD><TD WIDTH=402>Внутренняя ошибка драйвера EMM
</TD></TR>
<TR><TD WIDTH=54>81h</TD><TD WIDTH=402>Ошибка аппаратуры EMS-памяти
</TD></TR>
<TR><TD WIDTH=54>82h</TD><TD WIDTH=402>EMM занят</TD></TR>
<TR><TD WIDTH=54>83h</TD><TD WIDTH=402>Неправильный индекс пула
</TD></TR>
<TR><TD WIDTH=54>84h</TD><TD WIDTH=402>Неправильный номер запрошенной функции
</TD></TR>
<TR><TD WIDTH=54>85h</TD><TD WIDTH=402>Больше нет доступных индексов пулов
</TD></TR>
<TR><TD WIDTH=54>86h</TD><TD WIDTH=402>Ошибка при выполнении сохранения или восстановления контекста отображения
</TD></TR>
<TR><TD WIDTH=54>87h</TD><TD WIDTH=402>Запрошено больше памяти, чем общее количество доступной EMS-памяти
</TD></TR>
<TR><TD WIDTH=54>88h</TD><TD WIDTH=402>Запрошено больше страниц, чем доступно
</TD></TR>
<TR><TD WIDTH=54>89h</TD><TD WIDTH=402>Нельзя открыть индекс пустого пула
</TD></TR>
<TR><TD WIDTH=54>8Ah</TD><TD WIDTH=402>Пул не содержит так много страниц
</TD></TR>
<TR><TD WIDTH=54>8Bh</TD><TD WIDTH=402>Неправильное отображение, заданы номера
</TD></TR>
<TR><TD WIDTH=54></TD><TD WIDTH=402>физических страниц, отличные от 0 - 3
</TD></TR>
<TR><TD WIDTH=54>8Ch</TD><TD WIDTH=402>Переполнена область сохранения контекста отображения
</TD></TR>
<TR><TD WIDTH=54>8Dh</TD><TD WIDTH=402>Многократное сохранение контекста для одного пула
</TD></TR>
<TR><TD WIDTH=54>8Eh</TD><TD WIDTH=402>Попытка восстановления несохраненного контекста
</TD></TR>
<TR><TD WIDTH=54>8Fh</TD><TD WIDTH=402>Неправильный номер подфункции в регистре AL
</TD></TR>
<TR><TD WIDTH=54>90h</TD><TD WIDTH=402>Неправильный тип атрибута
</TD></TR>
<TR><TD WIDTH=54>91h</TD><TD WIDTH=402>Не поддерживается неразрушаемая память
</TD></TR>
<TR><TD WIDTH=54>92h</TD><TD WIDTH=402>Произошло перекрытие исходной и результирующей областей (это не ошибка, а предупреждение)
</TD></TR>
<TR><TD WIDTH=54>93h</TD><TD WIDTH=402>Область назначения, заданная индексом, слишком мала
</TD></TR>
<TR><TD WIDTH=54>94h</TD><TD WIDTH=402>Стандартная память перекрывается дополнительной памятью
</TD></TR>
<TR><TD WIDTH=54>95h</TD><TD WIDTH=402>Слишком большое смещение при пересылке блока
</TD></TR>
<TR><TD WIDTH=54>96h</TD><TD WIDTH=402>Слишком большой размер блока, больше 1 мегабайта
</TD></TR>
<TR><TD WIDTH=54>97h</TD><TD WIDTH=402>Заданы одинаковые исходный и результирующий индексы
</TD></TR>
<TR><TD WIDTH=54>98h</TD><TD WIDTH=402>Задан неправильный тип памяти (смещение 4)
</TD></TR>
<TR><TD WIDTH=54>A0h</TD><TD WIDTH=402>Заданному имени не соответствует ни один пул
</TD></TR>
<TR><TD WIDTH=54>A1h</TD><TD WIDTH=402>Заданное имя уже существует
</TD></TR>
<TR><TD WIDTH=54>A2h</TD><TD WIDTH=402>Длина исходной области больше 1 мегабайта
</TD></TR>
<TR><TD WIDTH=54>A3h</TD><TD WIDTH=402>Содержимое заданного блока данных неверно
</TD></TR>
<TR><TD WIDTH=54>A4h</TD><TD WIDTH=402>Доступ к этой функции запрещен
</TD></TR>
</TABLE>
<H2><A NAME="ch11_7">11.7. Программа, использующая EMS</A></H2>
<P>
Приведенная ниже программа демонстрирует использование основных
функций EMM:
<PRE>
<FONT COLOR=#000080>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

void main(void);
void main(void) {

        unsigned frame, err;
        unsigned total, free;
        unsigned handle;
        char ver;

// Это сообщение будет переписано сначала из
// области стандартной памяти в область дополнительной,
// затем обратно в область основной.

        static char test_msg[] = &quot;Тестовое сообщение для &quot;
                                                &quot;записи в область EMS.&quot;;

        char buf[80];
        char _far *ptr;
        int i;

// Проверяем, установлен ли драйвер EMS.

        if(ems_init() != 0) {
                printf(&quot;\nДрайвер EMS не установлен.&quot;);
                exit(-1);
        }

// Если драйвер установлен, определяем его состояние.

        printf(&quot;\nДрайвер EMS установлен, состояние: %02.2X.&quot;,
                ems_stat());

// Выводим номер версии драйвера

        if((err = ems_ver(&amp;ver)) != 0) {
                printf(&quot;\nОшибка: %02.2X&quot;, err);
                exit(-1);
        }
        printf(&quot;\nВерсия EMM: %02.2X&quot;, ver);

// Определяем сегмент окна доступа

        if((err = ems_fram(&amp;frame)) != 0) {
                printf(&quot;\nОшибка: %02.2X&quot;, err);
                exit(-1);
        }

        printf(&quot;\nСегмент окна доступа: %04.4X&quot;,
                frame);

// Определяем общее количество страниц и
// количество доступных страниц.

        if((err = ems_page(&amp;total, &amp;free)) != 0) {
                printf(&quot;\nОшибка: %02.2X&quot;, err);
                exit(-1);
        }

        printf(&quot;\nОбщее количество страниц EMS: %d&quot;
                         &quot;\nКоличество доступных страниц: %d&quot;,
                         total, free);

// Заказываем пул в дополнительной памяти.

        if((err = ems_open(free, &amp;handle)) != 0) {
                printf(&quot;\nОшибка: %02.2X&quot;, err);
                exit(-1);
        }

// Отображаем нулевую физическую страницу
// на нулевую логическуб страницу пула.

        if((err = ems_map(0, 0, handle)) != 0) {
                printf(&quot;\nОшибка: %02.2X&quot;, err);
                exit(-1);
        }

// Конструируем указатель на физическую страницу.

        ptr = FP_MAKE(frame,0);

// Копируем тестовое сообщение в
// дополнительную память.

        printf(&quot;\nКопируем в EMS: %s&quot;,test_msg);

        for(i=0; test_msg[i] != 0; i++)
                ptr[i] = test_msg[i];

// Теперь копируем это сообщение обратно
// в стандартную память.

        for(i=0; ptr[i] != 0; i++)
                buf[i] = ptr[i];
        buf[i] = 0;

// Выводим сообщение на экран для
// проверки.

        printf(&quot;\nСкопировано из EMS: %s&quot;,buf);

// Закрываем пул.

        if((err = ems_clos(&amp;handle)) != 0) {
                printf(&quot;\nОшибка: %02.2X&quot;, err);
                exit(-1);
        }

        exit(0);
}</FONT>
</PRE>
</BODY>
</HTML>
