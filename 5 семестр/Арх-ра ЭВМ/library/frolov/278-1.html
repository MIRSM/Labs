
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Аппаратное обеспечение IBM PC</TITLE>
<link rel=stylesheet type=text/css href="../../images/styles.css">
<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.04z">
</HEAD>
<body>
<table border=0 width=100% cellspacing=0 cellpadding=0>
  <tr> </tr>
</table>
<H1>1.&nbsp;<A NAME="ch1">Конфигурация персонального компьютера</A>
</H1>
<P>
<FONT FACE="Arial">1.1. <A HREF="#ch1_1">Определение типа компьютера и версии BIOS</A></FONT>
<P>
<FONT FACE="Arial">1.2. <A HREF="#ch1_2">Установка перемычек на материнской плате</A></FONT>
<P>
<FONT FACE="Arial">1.3. <A HREF="#ch1_3">КМОП-память и конфигурация компьютера</A></FONT>
<P>
<FONT FACE="Arial">1.4. <A HREF="#ch1_4">Использование BIOS для определения конфигурации</A></FONT>
<P>
<FONT FACE="Arial">1.5. <A HREF="#ch1_5">Определение типа процессора</A></FONT>
<P>
В настоящее время широко используются персональные компьютеры
самых разных типов (IBM PC, IBM&nbsp;XT, IBM AT, PS/2, Compaq-386
и т.д.). Если вы создаете коммерческое программное обеспечение,
следует позаботиться о том, чтобы оно работало на всех типах компьютеров,
использующих процессоры серии Intel 8086/80286/80386/80486. Для
обеспечения такой совместимости программа должна уметь определять
тип используемого центрального процессора и, разумеется, тип используемого
компьютера. Почему это так важно?
<P>
Корпорация Intel, разрабатывая свою серию процессоров 8086/80286/80386/80486,
уделила много внимания обеспечению совместимости снизу-вверх.
Такая совместимость гарантирует возможность непосредственного
выполнения старшими моделями процессоров любых программ, подготовленных
для младших моделей. При этом не требуется повторной компиляции
или редактирования этих программ.
<P>
Однако совместимость снизу-вверх не гарантирует (разумеется!)
обратного - возможности выполнения младшими моделями программ,
предназначенных для старших моделей. Поэтому, если вы желаете
добиться от вашей программы максимальной эффективности и быстродействия,
имеет смысл использовать архитектурные особенности старших моделей
процессоров. Однако это не означает, что ваша программа должна
всегда максимально использовать все возможности процессора 80486,
так как в этом случае она не сможет правильно работать на широко
распространенном компьютере IBM&nbsp;AT, использующим процессор
80286.
<P>
Лучше всего было бы сделать так, чтобы программа динамически (в
процессе своей работы) определяла тип используемого процессора
и вызывала соответствующие модули, рассчитанные на применение
конкретной модели процессора. Вы можете выделить эти модули в
самостоятельные программные единицы (драйверы или оверлеи) и подгружать
их в оперативную память при необходимости. Такой подход позволит
вам в будующем легко реализовать возможности процессоров 80586
или 80986 - вам будет достаточно изготовить новый драйвер (или
оверлей) и подключить его к уже готовой программе.
<P>
Другая проблема связана с большим разнообразием &quot;не вполне&quot;
совместимых с IBM&nbsp;PC/XT/AT компьютеров, выпускающихся разными
&quot;третьими&quot; фирмами. К этой категории можно также отнести
и отечественную ППЭВМ ЕС-1841 - это вроде бы IBM&nbsp;XT, но не
вполне, поэтому некоторые программы на этой машине работать не
будут.
<P>
К счастью, фирмы-производители оборудования записывают в определенные
ячейки ПЗУ BIOS некоторый код, по которому можно определить тип
компьютера. Можно очень легко отличить IBM&nbsp;XT от IBM&nbsp;AT.
<P>
По типу компьютера программа может сделать предварительные, а
в некоторых случаях и окончательные выводы о наличии того или
иного оборудования. Например, IBM&nbsp;PC или IBM&nbsp;XT не содержат
расширенной памяти или дисковода для работы с гибкими дисками
диаметром 3,5 дюйма. Разные модели, использующие процессоры 80286/80386/80486
могут использовать различные способы управления двадцатой адресной
линией (она используется при работе с расширенной памятью, подробности
- в 10 главе). Кроме того, от модели компьютера зависит способ,
которым программа может определить конфигурацию дисковой подсистемы.
Об этом мы говорили в третьей книге первого тома &quot;Библиотеки
системного программиста&quot;, посвященной дисковой подсистеме.
<P>
Прежде чем использовать какие-либо аппаратные ресурсы компьютера,
программа должна убедиться в том, что эти ресурсы имеются в составе
системы. Попытка обращения программы к несуществующему устройству
может привести, например, к зависанию операционной системы.
<P>
Как программа может определить конфигурацию подсистем компьютера?
<P>
Для машин класса IBM PC и IBM XT конфигурация задается установкой
перемычек на материнской плате и платах контроллеров периферийных
устройств. Программа может получить информацию об установленных
перемычках, прочитав состояние определенных портов компьютера.
<P>
Мы уже говорили о том, что в машинах класса IBM&nbsp;AT, IBM&nbsp;PS/2
и машинах более высокого класса установлена КМОП-память - память
с малым энергопотреблением. Эта память питается от аккумуляторов
и содержит информацию о конфигурации многих подсистем (в том числе
дисковой подсистемы).
<P>
Во время инициализации системы BIOS опрашивает порты, к которым
подключены перемычки и ячейки КМОП-памяти, содержащие информацию
о конфигурации компьютера. Результат записывается в область данных
BIOS - в слово конфигурации с адресом 0000:0410.
<P>
BIOS также предоставляет программам некоторые средства для определения
конфигурации компьютера. В частности, с помощью прерывания INT&nbsp;11h
программа может получить в регистре AX слово конфигурации из области
данных BIOS.
<H2><A NAME="ch1_1">1.1. Определение типа компьютера и версии
BIOS</A></H2>
<P>
У вас есть две возможности определить модель компьютера и получить
некоторую информацию о конфигурации - прочитать эту информацию
из ячеек ПЗУ BIOS, или вызвать одну из функций прерывания INT&nbsp;15h,
возвращающую адрес таблицы конфигурации.
<P>
ПЗУ BIOS содержит по адресу FFFF:FFFE байт, значение которого
можно использовать для идентификации типа компьютера:
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=64>FF </TD><TD WIDTH=393>оригинальный IBM PC;</TD>
</TR>
<TR><TD WIDTH=64>FE</TD><TD WIDTH=393>XT, Portable PC;</TD></TR>
<TR><TD WIDTH=64>FD</TD><TD WIDTH=393>PCjr;</TD></TR>
<TR><TD WIDTH=64>FC</TD><TD WIDTH=393>AT;</TD></TR>
<TR><TD WIDTH=64>FB</TD><TD WIDTH=393>XT с памятью 640 К на материнской плате;
</TD></TR>
<TR><TD WIDTH=64>FA</TD><TD WIDTH=393>PS/2 модель 25 или 30;</TD>
</TR>
<TR><TD WIDTH=64>F9</TD><TD WIDTH=393>Convertible PC;</TD></TR>
<TR><TD WIDTH=64>F8</TD><TD WIDTH=393>PS/2 модели 55SX, 70, 80;
</TD></TR>
<TR><TD WIDTH=64>9A</TD><TD WIDTH=393>Compaq XT, Compaq Plus;
</TD></TR>
<TR><TD WIDTH=64>30</TD><TD WIDTH=393>Sperry PC;</TD></TR>
<TR><TD WIDTH=64>2D</TD><TD WIDTH=393>Compaq PC, Compaq Deskpro
</TD></TR>
</TABLE>
<P>
Для определения модели компьютера таким способом мы предлагаем
следующую функцию:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">/**
*.Name      pc_model
*
*.Title     Определить модель компьютера
*
*.Descr     Функция возвращает байт, идентифицирующий
*           модель персонального компьютера
*
*.Params    Нет
*
*.Return    Код модели персонального компьютера:
*
*       FF      оригинальный IBM PC;
*       FE      XT, Portable PC;
*       FD      PCjr;
*       FC      AT;
*       FB      XT с памятью 640 К на материнской плате;
*       FA      PS/2 модель 25 или 30;
*       F9      Convertible PC;
*       F8      PS/2 модели 55SX, 70, 80;
*       9A      Compaq XT, Compaq Plus;
*       30      Sperry PC;
*       2D      Compaq PC, Compaq Deskpro.
*
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

char unsigned pc_model(void) {

        char unsigned _far *modptr;

        modptr = FP_MAKE(0xf000,0xfffe);

        return *modptr;
}
</FONT>
</PRE>
<P>
Функция pc_model() возвращает байт, идентифицирующий код компьютера.
В большинстве случаев вам достаточно проверить этот байт и сделать
вывод о типе компьютера и составе его аппаратных средств.
<P>
Более подробную информацию можно получить, вызвав функцию C0h
прерывания BIOS INT&nbsp;15h:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">На входе:       AH = C0h
        
На выходе:      ES:BX = адрес таблицы конфигурации,
                        таблица находится в ПЗУ BIOS;

        CF = 0 при успешном вызове прерывания;
        CF = 1 если данная версия BIOS не
                  поддерживает функцию C0h.
</FONT>
</PRE>
<P>
После выполнения прерывания регистры ES:BX будут указывать на
таблицу в области ПЗУ BIOS. В этой таблице имеется более точная
информация о типе компьютера, номер версии BIOS, сведения об аппаратных
особенностях конкретной модели.
<P>
Приведем формат указанной таблицы:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">Смещение        Описание
и размер


(+0) 2  размер таблицы в байтах

(+2) 1  код модели

(+3) 1  дополнительный код модели

(+4) 1  версия BIOS revision: 0 для первой
                        реализации; 2 для второй и т.д.

(+5) 1  байт конфигурации оборудования:

        бит 7 = канал 3 контроллера прямого доступа
                к памяти используется дисковой системой
                базового ввода-вывода (дисковой BIOS)

        бит 6 = установлен второй контроллер прерываний
                8259

        бит 5 = установлены часы реального времени

        бит 4 = каждый раз после вызова прерывания от
                клавиатуры INT&nbsp;9h вызывается функция
                4Fh прерывания INT 15h

        бит 3 = BIOS поддерживает ожидание внешнего
                события

        бит 2 = используется расширенная область данных BIOS

        бит 1 = если этот бит установлен в 1, то
                используется шина Micro Channel,
                в противном случае - ISA

        бит 0 зарезервирован

(+6) 2  зарезервировано и равно 0
(+8) 2  зарезервировано и равно 0
</FONT>
</PRE>
<P>
В следующей таблице приведены коды моделей, дополнительные коды
моделей и версии BIOS для некоторых широко распространенных типов
компьютеров:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">Код      Доп.код        Версия BIOS     Тип компьютера
модели модели


FFh    *     *    04/24/81  оригинальная версия
                                        IBM PC

FFh    *     *    10/19/81  IBM PC, в этой версии
                        BIOS исправлены некоторые ошибки

FFh    *     *    10/27/82  IBM PC, используется
                        накопитель на магнитном диске
                        (НМД), оперативная память 640 К,
                        поддерживается адаптер дисплея EGA

FEh    *     *    08/16/82   IBM&nbsp;PC XT

FEh    *     *    11/08/82   IBM PC XT, Portable

FDh    *     *    06/01/83   PCjr

FCh    *     *    01/10/84   IBM AT, модели 068,
                        099, частота тактового генератора
                        6 MHz, емкость НМД - 20MB

FCh    00h         01h  06/10/85   IBM AT, модель 239,
                        частота тактового генератора
                        6 MHz, емкость НМД - 30MB

FCh    01h 00h  11/15/85   IBM AT, модели 319,
                        339, частота тактового генератора
                        8 MHz, используются расширенная
                        клавиатура, BIOS может работать с
                        накопителями на гибких магнитных
                        дисках формата 3,5 дюйма

FCh    01h         -                         Compaq 286/386

FCh    02h         00h     04/21/86    IBM PC XT-286

FCh    04h         00h     02/13/87    PS/2 модель 50

FCh    04h         03h     04/18/88    PS/2 модель 50Z

FCh    05h         00h     02/13/87    PS/2 модель 60

FCh    06h         -                         7552 &quot;Gearbox&quot;

FCh    09h         02h     06/28/89    PS/2 модель 30-286

FCh    81h         00h     01/15/88    Phoenix 386 BIOS,
                        версия 1.10

FBh    00h         01h     01/10/86    IBM PC XT, расширенная
                        клавиатура, BIOS может работать с
                        накопителями на гибких магнитных
                        дисках формата 3,5 дюйма

FBh    00h         02h     05/09/86    IBM PC XT

FAh    00h         00h     09/02/86    PS/2 модель 30

FAh    00h         01h     12/12/86    PS/2 модель 30

FAh    01h         00h  -           PS/2 модель 25

F9h    00h         00h     09/13/85    PC Convertible

F8h    00h         00h     03/30/87    PS/2 модель 80 16MHz

F8h    01h         00h     10/07/87    PS/2 модель 80 20MHz

F8h    04h         02h     04/11/88    PS/2 модель 70

F8h    04h         03h     03/17/89    PS/2 модель 70

F8h    09h         -       -           PS/2 модель 70

F8h    09h         02h     04/11/88    PS/2 модель 70

F8h    09h         03h     03/17/89    PS/2 модель 70

F8h    0Ch         00h     11/02/88    PS/2 модель 55SX

F8h    1Bh         00h     10/02/89    PS/2 модель 70-486

9Ah    *     *    -           Compaq XT или 
                                          Compaq Plus

30h    -   -       -           Sperry PC

2Dh    *     *    -           Compaq PC или
                                          Compaq Deskpro
</FONT>
</PRE>
<P>
Следует заметить, что функция C0h прерывания INT&nbsp;15h поддерживается
не всеми версиями BIOS, а только теми, которые были изготовлены
после 10 января 1986 года. Если вы используете более старые версии
BIOS, дополнительный код модели, версия BIOS и байт конфигурации
вам недоступны.
<P>
Кроме того, BIOS изготовленный 10 января 1986 года и установленный
в IBM XT возвращает неправильное значение байта конфигурации.
<P>
Символ &quot;*&quot; в таблице означает, что функция C0h прерывания
INT 15h для данной версии BIOS не реализована. Все что вы можете
сделать в этом случае для идентификации BIOS - получить байт кода
модели по адресу F000h:FFFEh и дату изготовления BIOS, занимающую
восемь байтов начиная с адреса F000h:FFF5h. Дата хранится в формате
ASCII.
<P>
Приведем текст программы, которая поможет вам определить версию
BIOS и дату ее изготовления, а также получить всю остальную информацию
из таблицы конфигурации. Программа отображает также адрес этой
таблицы.
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

void main(void);

void main(void) {

        union REGS  rg;
        struct SREGS srg;
        int   i;
        BIOSINFO far *biosinf_ptr;

                printf(&quot;\n*BIOSTEST* Информация о BIOS, &quot;
                        &quot;© Фролов А., 1991&quot;);

// Конструируем указатель на дату изготовления
// BIOS. Эта дата записана в ПЗУ по адресу F000h:FFF5h.

                biosinf_ptr = FP_MAKE(0xf000, 0xfff5);

// Выводим дату на экран

                printf(&quot;\n\nДата изготовления BIOS:     &quot;);
                for(i=0; i&lt;8; i++)
                        putch(*((char far *)biosinf_ptr + i));

// Вызываем функцию C0h для получения адреса
// таблицы конфигурации компьютера.

                rg.h.ah = 0xc0;
                int86x(0x15, &amp;rg, &amp;rg, &amp;srg);

// Если данная функция не поддерживается BIOS,
// читаем код модели компьютера из ПЗУ
// по адресу F000h:FFFEh.

                if(rg.x.cflag == 1) {
                        printf(&quot;\nФункция C0h прерывания INT 15h &quot;
                                &quot;данной версией BIOS не поддерживается\n&quot;);

// Конструируем указатель на код модели

                        biosinf_ptr = FP_MAKE(0xf000, 0xfffe);

// Выводим код модели компьютера на экран

                        printf(&quot;\nКод модели:             %02.2X&quot;,
                                (unsigned char)(*(char far *)biosinf_ptr));

                        exit(-1);
                }

// Конструируем укзатель на таблицу конфигурации

                biosinf_ptr = FP_MAKE(srg.es, rg.x.bx);

// Выводим на экран содержимое таблицы

                printf(&quot;\nАдрес таблицы конфигурации: %Fp&quot;
                                 &quot;\nРазмер таблицы в байтах:    %d&quot;
                                 &quot;\nКод модели:                 %02.2X&quot;
                                 &quot;\nДополнительный код модели:  %d&quot;
                                 &quot;\nВерсия BIOS:                %d&quot;
                                 &quot;\nКонфигурация оборудования:  %02.2X&quot;,
                                 biosinf_ptr,
                                 biosinf_ptr-&gt;size,
                                 biosinf_ptr-&gt;model,
                                 biosinf_ptr-&gt;submodel,
                                 biosinf_ptr-&gt;version,
                                 biosinf_ptr-&gt;hardcfg);

// Определяем конфигурацию компьютера

                printf(&quot;\n\nКонфигурация оборудования компьютера&quot;
                                        &quot;\n------------------------------------&quot;);

// Запоминаем байт конфигурации

                i = biosinf_ptr-&gt;hardcfg;

// Расшифровываем байт конфигурации

                if(i &amp; 0x80)
                        printf(&quot;\nКанал 3 контроллера DMA используется&quot;
                                                 &quot; дисковой BIOS&quot;);

                if(i &amp; 0x40)
                        printf(&quot;\nУстановлен второй контроллер&quot;
                                                &quot; прерываний 8259&quot;);

                if(i &amp; 0x20)
                        printf(&quot;\nУстановлены часы реального времени&quot;);

                if(i &amp; 0x10)
                        printf(&quot;\nПосле INT 9h вызывается функция 4Fh&quot;
                                                &quot; прерывания INT 15h&quot;);

                if(i &amp; 0x8)
                        printf(&quot;\nBIOS поддерживает функцию ожидания&quot;
                                                &quot; внешнего события&quot;);

                if(i &amp; 0x4)
                        printf(&quot;\nИспользуется расширенная&quot;
                                                &quot; область данных BIOS&quot;);

                if(i &amp; 0x2)
                        printf(&quot;\nИспользуется шина Micro Channel&quot;);

                if(!(i &amp; 0x2))
                        printf(&quot;\nИспользуется шина ISA&quot;);

                exit(0);
}
</FONT>
</PRE>
<P>
Мы запустили эту программу на компьютере Datamini&nbsp;386&nbsp;Tower,
и вот что она показала на экране:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">02/25/89
*BIOSTEST* Информация о BIOS, © Фролов А., 1991

Дата изготовления BIOS:     
Адрес таблицы конфигурации: F000:E6F5
Размер таблицы в байтах:    8
Код модели:                 FC
Дополнительный код модели:  1
Версия BIOS:                0
Конфигурация оборудования:  70

Конфигурация оборудования компьютера
------------------------------------
Установлен второй контроллер прерываний 8259
Установлены часы реального времени
После INT 9h вызывается функция 4Fh прерывания INT 15h
Используется шина ISA
</FONT>
</PRE>
<P>
Для изменения конфигурации компьютера (добавления новых устройств
или удаления устаревших), может потребоваться изменение установки
перемычек на материнской плате компьютера и/или на плате контроллера
устанавливаемого устройства. Поэтому теперь мы расскажем об установке
перемычек на материнской плате.
<H2><A NAME="ch1_2">1.2. Установка перемычек на материнской плате</A>
</H2>
<P>
Для правильной установки перемычек, находящихся на материнской
плате и платах контроллеров периферийных устройств вам необходима
соответствующая документация. Это руководства пользователя, поставляющиеся
вместе с компьютером или контроллерами.
<P>
Обозначения перемычек и их назначение различны не только для разных
типов компьютеров (PC, XT, AT, PS/2), но и для машин разных фирм-производителей
оборудования. Поэтому в этой книге не приводятся конкретные сведения
об установке перемычек для оборудования, имеющегося в распоряжении
авторов - у вас может оказаться другая модель компьютера.
<P>
Вместо этого мы приведем общие сведения об установке перемычек.
Пользуясь фирменной документацией, вы найдете нужные перемычки
на материнской плате вашего компьютера и сможете их правильно
установить.
<P>
Оригинальный компьютер IBM PC в его первоначальном виде в настоящее
время используется крайне редко, поэтому мы не будем рассказывать
о перемычках для IBM PC.
<P>
Машина IBM XT имеет один банк перемычек, определяющих количество
установленных накопителей на гибких магнитных дисках (НГМД), тип
используемого дисплейного адаптера, объем оперативной памяти,
установленной на материнской плате, использование арифметического
сопроцессора 8087.
<P>
Как правило, если вы не меняете конфигурацию системы, у вас не
возникает необходимость в изменении установки перемычек. Если
же вы добавляете еще один НГМД, изменяете тип дисплейного адаптера
или устанавливаете (снимаете) арифметический сопроцессор, вам
необходимо переустановить соответствующие перемычки на материнской
плате.
<P>
Приведем таблицу перемычек банка SW1 для IBM XT (используя эту
таблицу, обязательно сверьте ее с приведенной в документации на
материнскую плату вашего компьютера):
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">Номер перемычки Назначение и установка


1       Зацикливание процедуры POST (тест
        после включения питания).
        Эта перемычка должна находиться в
        состоянии OFF.

2       Наличие арифметического сопроцессора
        8087:

         - 8087 установлен      - OFF;
         - 8087 не установлен   - ON.

3-4     Объем оперативной памяти, установленной
        на материнской плате компьютера:

        3   4
        
        OFF ON  - 128 K;

        ON  OFF - 192 K;

        OFF OFF - 256 K.

5-6     Тип дисплейного контроллера:

        5   6

        ON  ON  - не подключен или EGA;

        OFF ON  - CGA в режиме 40x25;

        ON  OFF - CGA в режиме 80x25;

        OFF OFF - MDA или два контроллера:
                  MDA и CGA.

7-8     Количество установленных НГМД:

        7   8

        ON  ON  - установлен 1 НГМД;

        OFF ON  - установлено 2 НГМД;

        ON  OFF - установлено 3 НГМД;

        OFF OFF - установлено 4 НГМД.
</FONT>
</PRE>
<P>
Если вы изменяете объем оперативной памяти, установленной на материнской
плате, вам не надо переустанавливать перемычки 3 и 4. Это связано
с тем, что BIOS во время инициализации системы после включения
питания сам определяет объем установленной памяти - он сканирует
всю имеющуюся память. Объем проверенной памяти обычно отображается
во время теста.
<P>
Конфигурация компьютера IBM AT определяется, в основном, не установкой
перемычек, а содержимым энергонезависимой КМОП-памяти. Мы уже
говорили об этом при обсуждении конфигурации дисковой подсистемы.
<P>
Для работы с КМОП-памятью BIOS содержит специальную программу,
называемую SETUP-программой. Аналогичная программа содержится
на диагностической дискете, поставляемой вместе с компьютером.
<P>
После перезагрузки или включении питания BIOS обычно предоставляет
возможность запустить программу SETUP. Для этого, как правило,
надо нажать клавишу DEL во время инициализации системы. Однако
некоторые старые версии BIOS для AT не предоставляют возможности
запуска программы SETUP при перезапуске системы. При использовании
этих версий SETUP запускается сам, если в процессе тестирования
обнаружились неисправности в оборудовании. Например, вы отключили
накопитель на жестком магнитном диске (НМД) и включили компьютер.
Процедуры тестирования, запускаемые в процессе инициализации,
обнаружат неисправность в НМД и предоставят вам возможность работать
с программой SETUP, находящейся в BIOS.
<P>
Другая возможность - загрузиться с диагностической дискеты и запустить
программу SETUP, находящуюся на этой дискете.
<P>
Перемычка, влияющая на конфигурацию компьютера IBM AT - SW1. Она
определяет тип дисплейного контроллера, используемого программой
SETUP. Состояние этой перемычки анализируется при разрушении содержимого
КМОП-памяти (например, при разряде аккумулятора, питающего КМОП-память
и часы реального времени).
<P>
Если перемычка SW1 установлена в положение OFF, используется контроллер
CGA, в противном случае - MDA, EGA, VGA. Обычно вам не требуется
переустанавливать эту перемычку.
<H2><A NAME="ch1_3">1.3. КМОП-память и конфигурация компьютера</A>
</H2>
<P>
Назначение некоторых ячеек КМОП-памяти мы уже рассматривали в
разделе, посвященному конфигурации дисковой подсистемы. В этом
разделе мы расскажем о назначении остальных ячеек.
<P>
В КМОП-памяти хранится текущее время и дата, сведения о конфигурации
системы, результат тестирования при включении питания и другая
информация, приведенная в следующей таблице:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">Адрес ячейки    Содержимое


00h - 0Dh       Используются часами реального времени

0Eh     Байт состояния диагностики при
        включении питания

0Fh     Байт состояния отключения

10h     Тип используемого НГМД

11h     Зарезервировано

12h     Тип НМД (если тип меньше 15)

13h     Зарезервировано

14h     Конфигурация оборудования

15h - 16h       Объем основной памяти

17h - 18h       Объем расширенной (extended) памяти

19h     Тип первого НМД (если тип &gt; 15)

1Ah     Тип второго НМД (если тип &gt; 15)

1Bh - 20h       Зарезервировано

21h - 2Dh       Зарезервировано

2Eh - 2Fh       Контрольная сумма ячеек 10h - 20h

30h - 31h       Объем расширенной (extended) памяти

32h     Текущее столетие в двоично-десятичном
        коде (19h для 19-го столетия)

33h     Различная информация

34h - 3Fh       Зарезервировано
</FONT>
</PRE>
<P>
Рассмотрим подробно назначение отдельных ячеек КМОП-памяти.
<H3>00h&nbsp;- 0Dh - область часов реального времени</H3>
<P>
Ячейки с адресами 00h&nbsp;-&nbsp;0Dh используются часами реального
времени. Часам реального времени будет посвящена отдельная глава,
поэтому сейчас мы не станем останавливаться на этих ячейках.
<H3>0Eh - байт состояния диагностики</H3>
<P>
Байт состояния диагностики (расположенный в КМОП-памяти по адресу
0Eh) содержит результаты выполнения диагностики при включении
питания компьютера. Выполнив анализ содержимого байта 0Eh, программа
может выявить неисправность НМД, часов реального времени, разрядку
аккумулятора и ошибки в конфигурации. Приведем формат этого байта:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">Бит     Значение

0-1     Не используется, равно 0;

2       0 - неправильная установка часов реального времени;
        1 - часы реального времени установлены правильно;

3       1 - неисправность НМД, невозможно загрузить
            операционную систему с жесткого диска;
        0 - НМД исправен;

4       1 - фактический размер оперативной памяти не
            соответствует указанному в КМОП-памяти;
        0 - размер оперативной памяти указан правильно;

5       1 - ошибка в конфигурации системы, фактическая
            конфигурация не соответствует указанной в
            байте конфигурации оборудования (адрес 14h);
        0 - конфигурация указана правильно;

6       1 - ошибка в контрольной сумме КМОП-памяти;
        0 - контрольная сумма КМОП-памяти правильная;

7       1 - разрядка аккумулятора, питающего КМОП-память и
            часы реального времени;
        0 - аккумулятор исправен и заряжен.
</FONT>
</PRE>
<H3>0Fh - байт состояния отключения</H3>
<P>
Байт состояния отключения 0Fh используется процессорами 80286,
80386 и 80486 для определения способа возврата из защищенного
режима в реальный после аппаратного сброса.
<P>
Вы, вероятно, знаете, что эти процессоры могут работать либо в
реальном режиме, который соответствует режиму работы процессора
8086, либо в защищенном. Защищенный режим работы используется
такими операционными системами, как OS/2, UNIX, XENIX, а также
операционными оболочками WINDOWS/386 и WINDOWS версии 3.0. В этом
режиме процессор может непосредственно адресовать всю память,
лежащую выше границы 1 мегабайт.
<P>
Подробное рассмотрение защищенного режима работы выходит за рамки
данной книги. Расскажем кратко о переходе из реального режима
в защищенный и обратно для иллюстрации использования ячейки КМОП-памяти
с адресом 0Fh.
<P>
Для перевода процессора 80286 из реального режима в защищенный
можно использовать специальную команду LMSW:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">mov     ax,1
lmsw    ax
</FONT>
</PRE>
<P>
Разумеется, двух строк, приведенных выше, недостаточно для правильной
работы процессора в защищенном режиме.
<P>
Для того, чтобы вернуть процессор 80286 из защищенного режима
в реальный, необходимо выполнить аппаратный сброс (отключение)
процессора. Это можно сделать следующим образом:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">mov     ax, 0FEh        ; команда отключения
out     64h, ax
</FONT>
</PRE>
<P>
Перед выдачей команды отключения программа должна записать в ячейку
0Fh КМОП-памяти причину отключения:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">Значение        Причина отключения

0       Программный сброс при нажатии
        комбинации клавиш CTRL-ALT-DEL или
        неожиданный сброс. Выполняется обычный
        перезапуск системы, но процедуры
        тестирования при включении питания не
        выполняются.

1       Сброс после определения объема памяти.

2       Сброс после тестирования памяти.

3       Сброс после обнаружения ошибки в памяти
        (контроль четности).

4       Сброс с запросом перезагрузки.

5       После сброса перезапускается контроллер
        прерываний, затем управление передается
        по адресу, который находится в области
        данных BIOS 0000:0467h.

6,7,8   Сброс после выполнения теста работы
        процессора в защищенном режиме.

9       Сброс после выполнения пересылки блока
        памяти из основной памяти в
        расширенную.

0Ah     После сброса управление немедленно
        передается по адресу, взятому из
        области данных BIOS 0000:0467h.
</FONT>
</PRE>
<P>
Для перевода процессоров 80386 и 80486 из реального режима в защищенный
и обратно можно использовать загрузку специального управляющего
регистра CR0 обычной командой MOV. Однако будет работать и метод,
основанный на применении команды LMSW и команды отключения.
<P>
Вы можете использовать сведения о команде отключения для организации
программного перезапуска системы.
<H3>10h - тип используемых флоппи-дисков;</H3>
<P>
Младшая и старшая тетрады этого байта описывают соответственно
второй и первый НГМД:
<UL>
<LI>0000 - дисковод не установлен;
<LI>0001 - дисковод на 360К;
<LI>0010 - дисковод на 1,2М;
<LI>0011 - дисковод на 720К;
<LI>0100 - дисковод на 1.44М.
</UL>
<H3>11h - зарезервировано для AT, тип НМД для PS/2</H3>
<P>
В компьютерах PS/2 ячейки КМОП-памяти с адресами 11h и 12h используются
для хранения типов, соответственно, первого и второго НМД.
<H3>12h - типы первого и второго НМД</H3>
<P>
Этот байт разделен на две тетрады аналогично байту, описывающему
НГМД. Однако в тетраде можно закодировать только 16 различных
значений, а типов НМД значительно больше. Поэтому тип 15 используется
специальным образом - если тип НМД в младшей тетраде (диск&nbsp;C:)
равен 15, то правильное значение типа находится в КМОП-памяти
по адресу 19h. Аналогично для диска D: этот тип можно взять из
байта по адресу 1Ah (если старшая тетрада байта с адресом 12h
равна 15).
<P>
Таблица используемых типов дисков была приведена в третьей книге
первого тома, в разделе, посвященном конфигурации дисковой подсистемы.
Кроме того, сведения о типах дисков, задаваемых программой SETUP,
обычно приводятся в документации, поставляемой вместе с компьютером.
<H3>13h - зарезервировано</H3>
<P>
Эта ячейка КМОП-памяти зарезервирована для дальнейшего развития
системы.
<H3>14h - конфигурация оборудования</H3>
<P>
В этом байте находится информация о количестве установленных НГМД,
о наличии арифметического сопроцессора 80287 или 80387 и о типе
используемого дисплейного контроллера. Приведем формат байта конфигурации:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">Бит     Значение

0       1 - в системе установлены НГМД;
        0 - НГМД не используются;

1       1 - установлен арифметический сопроцессор 80287 или
            80387;
        0 - арифметический сопроцессор не установлен;

2-3     не используются, равны 0;

4-5     тип дисплейного контроллера и его режим:

        Биты:   5    4

                        0       0       - не используется или EGA;
                        0       1       - CGA, EGA, VGA в режиме 40x25;
                        1       0       - CGA, EGA, VGA в режиме 80x25;
                        1       1       - монохромный контроллер;

6-7     количество используемых НГМД:

        Биты:   7       6

                        0       0       - установлен 1 НГМД
                        0       1       - установлен 2 НГМД
                        1       0       - установлен 3 НГМД
                        1       1       - установлен 4 НГМД
</FONT>
</PRE>
<H3>15h-16h - объем основной памяти</H3>
<P>
Ячейка 15h содержит младший байт, а ячейка 16h - старший байт
объема основной памяти. Например:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">0100h - 256K

0200h - 512K

0280h - 640K
</FONT>
</PRE>
<H3>17h-18h - объем дополнительной памяти</H3>
<P>
Ячейки 17h и 18h содержат, соответственно, младший и старший байты
размера дополнительной памяти (расположенной выше границы 1 М)
в килобайтах.
<H3>19h-1Ah типы первого и второго НМД</H3>
<P>
Эти ячейки содержат типы, соответственно, первого и второго НМД,
если соответствующий тип имеет значение, большее 15 (см. описание
ячейки 12h).
<H3>1Bh-2Dh - зарезервировано</H3>
<P>
Эти ячейки КМОП-памяти зарезервированы для дальнейшего развития
системы.
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">2Eh-2Fh -       контрольная сумма ячеек 10h - 20h
</FONT>
</PRE>
<P>
Для ячеек КМОП-памяти с адресами от 10h до 20h при инициализации
системы BIOS выполняет проверку контрольной суммы. Эта контрольная
сумма хранится также в КМОП-памяти в ячейках 2Eh и 2Fh (соответственно,
старший и младший байты).
<H3>30h-31h - объем дополнительной памяти</H3>
<P>
Ячейки 30h и 31h содержат, соответственно, младший и старший байты
размера дополнительной памяти (расположенной выше границы 1 М)
в килобайтах.
<P>
Эта информация дублирует аналогичную информацию, расположенную
в ячейках с адресами 17h-18h.
<H3>32h Текущее столетие</H3>
<P>
В машинах IBM AT этот байт содержит текущее столетие в двоично-десятичном
коде, т.е. 19 столетие записано как 19h.
<P>
PS/2 использует эту ячейку вместе с ячейкой 33h для хранения контрольной
суммы ячеек с адресами от 10h до 31h. При этом старший байт контрольной
суммы хранится в ячейке 32h, а младший - 33h.
<H3>33h - различная информация</H3>
<P>
Для IBM AT этот байт используется программой SETUP.
<H3>34h-3Fh - зарезервировано</H3>
<P>
Это поле вы можете использовать по своему усмотрению, например,
хранить здесь пароль.
<P>
PS/2 использует ячейку с адресом 37h для хранения номера текущего
столетия. Ячейки 38h-3Fh в модели 50 компьютера PS/2 используются
для хранения пароля. Обращение к этим ячейкам выполняется по адресам
78h-7Fh, которые аппаратно отображаются на адреса 38h-3Fh.
<P>
Приведем две маленькие программы, демонстрирующие приемы работы
с КМОП-памятью. Первая программа записывает в ячейки 34h-3Fh строку
символов, вторая отображает эту строку, а также некоторые другие
ячейки.
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

main() {

// Эта строка будет записана в КМОП-память

  static char password[12] = &quot;!Frolov A.V.&quot;;
  int i,j;

  printf(&quot;\n*Запись в CMOS* ©Фролов A. 1991\n\n&quot;);

  for(i=0x34,j=0; i&lt;0x40; i++,j++) {

// Задаем адрес ячейки КМОП-памяти

    outp(0x70,i);

// Выполняем запись в эту ячейку

    outp(0x71,password[j]);
  }
}
</FONT>
</PRE>
<P>
Программа для чтения содержимого КМОП-памяти:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

main() {
  unsigned char cmos[164];
  int i;

  printf(&quot;\n*Чтение из CMOS* ©Фролов A. 1991\n\n&quot;);

// Читаем все 64 ячейки КМОП-памяти в массив cmos

  for(i=0; i&lt;64; i++) {
    outp(0x70,i);
    cmos[i]=inp(0x71);
  }

// Отображаем ячейки часов реального времени

  printf(&quot;\nЯчейки часов реального времени: &quot;);

  for(i=0; i&lt;0xd; i++) {
        printf(&quot;%02.2x &quot;,(unsigned)cmos[i]);
  }

// Отображаем состояние байта диагностики
// после включения питания

  printf(&quot;\nБайт диагностики: %02.2x&quot;,cmos[0xe]);

// Отображаем содержимое байта отключения

  printf(&quot;\nБайт отключения: %02.2x\n&quot;,cmos[0xf]);

// Отображаем содержимое зарезервированных ячеек

  printf(&quot;\nPassword : &quot;);
  for(i=0x34; i&lt;0x40; i++) {
        printf(&quot;%02.2x &quot;,(unsigned)cmos[i]);
  }

// Выводим это же еще раз в виде текстовой строки

  cmos[0x40]=0;
  printf(&quot;&gt;%s&lt;\n&quot;,&amp;cmos[0x34]);
}
</FONT>
</PRE>
<P>
Некоторую помощь в определении конфигурации компьютера вам может
оказать прерывание BIOS INT&nbsp;11h, которое мы рассмотрим ниже.
<H2><A NAME="ch1_4">1.4. Использование BIOS для определения конфигурации</A>
</H2>
<P>
Как мы уже говорили, BIOS в процессе инициализации опрашивает
состояние перемычек и анализирует содержимое КМОП-памяти (на тех
машинах, где эта память установлена). После анализа BIOS записывает
в свою область данных по адресу 0000h:0410h слово конфигурации.
Отдельные биты этого слова содержат информацию о наличии в системе
различного оборудования. Это слово можно получить с помощью прерывания
INT&nbsp;11h, которое возвращает его в регистре AX.
<P>
Приведем назначение отдельных битов слова конфигурации:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">Биты    Значение


0               1 - система содержит НМД;
                0 - система не содержит НМД.

1               1 - установлен арифметический сопроцессор;
                0 - арифметический сопроцессор не установлен.

2-3             Объем основной памяти, установленной на
                материнской плате:

                        Биты:   3  2

                                        0  1     - 16К;
                                        1  0     - 32К;
                                        1  1     - 64К и более.

4-5             Тип дисплейного контроллера и его режим:

                        Биты: 5    4

                                 0       0      - не используется или EGA;
                                 0       1      - CGA, EGA, VGA в режиме
                                                  40x25;
                                 1       0      - CGA, EGA, VGA в режиме
                                                  80x25;
                                 1       1      - монохромный контроллер.

6-7             Количество установленных НГМД:

                        Биты:   7       6

                                        0       0       - установлен  1 НГМД;
                                        0       1       - установлено 2 НГМД;
                                        1       0       - установлено 3 НГМД;
                                        1       1       - установлено 4 НГМД.

8               1 - используется контроллер прямого доступа к
                    памяти;
                0 - контроллер прямого доступа к памяти не
                    используется.

9-11    Количество установленных портов последовательной
                передачи данных RS232S:

                        000 - нет портов;
                        001 - используется один порт;
                                .............
                        111 - используется 7 портов.

12              1 - используется игровой адаптер (джойстик);
                0 - игровой адаптер не используется.

13              1 - установлен последовательный принтер (только
                    для PC Jr).

14-15   Количество установленных принтеров:

                        00 - нет принтеров;
                        01 - используется 1 принтер;
                        10 - используется 2 принтера;
                        11 - используется 3 принтера.
</FONT>
</PRE>
<H2><A NAME="ch1_5">1.5. Определение типа процессора</A></H2>
<P>
Мы уже говорили о том, для чего может потребоваться программе
определять тип используемого процессора.
<P>
Для определения типа процессора можно использовать следующую программу:
<PRE>
<FONT COLOR=#000080 FACE="Courier New Cyr">                  .MODEL  tiny
                  .STACK  100h

                  .DATA

msg1      db &quot;Тип вашего процессора: &quot;, &quot;$&quot;
m_8086    db &quot;8086&quot;,&quot;$&quot;
m_80286   db &quot;80286&quot;,&quot;$&quot;
m_80386   db &quot;80386&quot;,&quot;$&quot;

                  .CODE
                  .STARTUP

                  mov     ah, 9h
                  mov     dx, OFFSET msg1
                  int     21h

; Записываем 0 в регистр флагов

                  xor     ax,ax
                  push    ax
                  popf

; Переписываем регистр флагов через
; стек в регистр AX

                  pushf
                  pop     ax

; Проверяем установку старших четырех битов

                  and     ax,0F000h
                  cmp     ax,0F000h

; Если эти биты установлены, программа
; работает на процессоре 8086

                  je      short CPU_8086

; Записываем 0F000h в регистр флагов

                  mov     ax,0F000h
                  push    ax
                  popf

; Переписываем регистр флагов через
; стек в регистр AX

                  pushf
                  pop     ax

; Проверяем установку старших четырех битов

                  and     ax,0F000h

; Если эти биты установлены, программа
; работает на процессоре 80286

                  jz      short CPU_80286

; Если биты не установлены, то программа
; работает на процессоре 80386

                  mov     dx, OFFSET m_80386
                  jmp end_program

CPU_80286:
                  mov     dx, OFFSET m_80286
                  jmp end_program

CPU_8086:
                  mov     dx, OFFSET m_8086
end_program:

                  mov     ah, 9h
                  int     21h

                  .EXIT   0

                  END
</FONT>
</PRE>
<P>
Работа программы основывается на записи в стек слова состояния
процессора и последующего извлечения его. При этом проверяется
содержимое старших извлеченных из стека битов.
</BODY>
</HTML>
