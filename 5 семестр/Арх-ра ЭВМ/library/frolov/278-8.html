<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Аппаратное обеспечение IBM PC</TITLE>
<link rel=stylesheet type=text/css href="../../images/styles.css">
<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.04z">
</HEAD>
<body>
<H1>3.&nbsp;МЫШЬ</H1>
<P>
3.1. <A HREF="#ch3_1">Как устроена мышь?</A>
<P>
3.2. <A HREF="#ch3_2">Драйверы мыши в MS-DOS</A>
<P>
3.3. <A HREF="#ch3_3">Прерывание для обслуживания мыши</A>
<P>
Вместе с появлением персональных компьютеров возникло и получило
огромную популярность графическое устройство ввода информации
- мышь. В настоящее время практически каждый персональный компьютер
оснащен этим устройством. Более того, многие программы специально
ориентированы на использование мыши. Например, графический редактор
Picture Maker из пакета Story Editor. В этом редакторе вы можете
сделать почти всю работу, не прикасаясь к клавиатуре (за исключением
операции набора текстовых строк).
<P>
Что это за устройство и почему оно используется так же часто,
как и клавиатура персонального компьютера?
<H2><A NAME="ch3_1">3.1. Как устроена мышь?</A></H2>
<P>
Мышь - это небольшая коробочка с двумя или тремя клавишами, которая
соединяется с компьютером тонким кабелем:<BR>
<P> <IMG SRC="278/pic2.gif" ALT="Рис. 2. Внешнийвид мыши" align="middle"> 
<P>
<CENTER>Рис. 2. Внешний вид мыши</CENTER>
<P>
Сверху на корпусе расположены кнопки. Обычно их две или три. Назначение
этих кнопок полностью определяется программным обеспечением. Снизу
виден шарик. Он обычно покрыт резиной для лучшего сцепления с
поверхностью стола.
<P>
Все, что вам нужно делать с мышью - это катать ее по любой гладкой
поверхности и нажимать на кнопки. Программное обеспечение свяжет
перемещения мыши по поверхности стола с перемещениями, например,
курсора по поверхности экрана. Перемещая мышь по столу (и, соответственно,
курсор по экрану), вы можете указывать (выбирать) различные объекты,
находящиеся на экране.
<P>
Для того, чтобы &quot;выбрать&quot; какой-нибудь объект, обычно
требуется указать на этот объект курсором и нажать на одну из
кнопок мыши.
<P>
Если вы откроете корпус мыши, вы увидите простой механизм, состоящий
из шарика, двух осей с резиновыми валиками, двух дисков с отверстиями
и четырех фотодатчиков:
<P>
<IMG SRC="278/pic3.gif" ALT="Рис. 3. Внутреннее устройство мыши">
<P>
<CENTER><A NAME="OLE_LINK1">Рис. 3. Внутреннее устройство мыши</A></CENTER>
<P>
Когда вы перемещаете мышь по поверхности стола, вращение шарика
передается через резиновые валики двум дискам с отверстиями. Около
каждого диска расположены фотодатчики (по два на диск). Они фиксируют
направление вращения и угол поворота дисков. Во время движения
мыши фотодатчики вырабатывают импульсы, которые передаются в компьютер.
Количество этих импульсов линейно зависит от величины перемещения
мыши.
<P>
В настоящее время изготовители компьютерного оборудования предлагают
большой выбор мышей разного типа. Мыши отличаются не только внешним
видом и количеством клавишей, но также и способом подключения
к компьютеру, мыши могут иметь различную точность и различный
программный интерфейс.
<P>
Можно выделить два наиболее часто используемых способа подключения
мыши к компьютеру:
<UL>
<LI>через последовательный порт (COM1, COM2);
<LI>через специальный адаптер, который вставляется в слот расширения
материнской платы компьютера.
</UL>
<P>
Выбирая мышь, используйте тот способ подключения, который вам
более удобен. При этом не следует забывать о существовании компьютеров,
не имеющих слотов расширения (обычно это компьютеры типа Lap-Top).
Для таких компьютеров больше подойдет мышь, подключающаяся через
последовательный порт.
<P>
Что касается программного интерфейса, то можно выделить два типа:
<UL>
<LI>трехкнопочная мышь системы Mouse Systems
<LI>двухкнопочная мышь Microsoft
</UL>
<P>
Некоторые мыши могут эмулировать оба типа. Эмулируемый тип зависит
от состояния переключателя, находящегося на нижней крышке корпуса
мыши или от того, была ли нажата клавиша мыши во время включения
питания компьютера.
<P>
Мы рекомендуем вам приобрести двухкнопочную мышь фирмы Microsoft.
Эта мышь удобна в работе, имеет переходник для подключения к последовательному
порту и адаптер для подключения к слотам расширения. Кроме того,
если вы используете мышь фирмы Microsoft, есть гарантия, что все
фирменное программное обеспечение будет правильно работать с вашей
мышью.
<H2><A NAME="ch3_2">3.2. Драйверы мыши в MS-DOS</A></H2>
<P>
Как это не странно, ни BIOS, ни MS-DOS версий вплоть до 4.01 не
содержат программной поддержки мыши. Для того, чтобы задействовать
это устройство, вам надо использовать драйвер мыши или специальную
резидентную программу, выполняющую функцию драйвера мыши. Как
правило, это программное обеспечение поставляется вместе с мышью.
<P>
Для подключения драйвера мыши файл CONFIG.SYS должен содержать
строку следующего вида:
<PRE>
<FONT COLOR=#000080>device=c:\mouse\mouse.sys</FONT>
</PRE>
<P>
Если используется резидентная программа, она обычно вызывается
в файле AUTOEXEC.BAT:
<PRE>
<FONT COLOR=#000080>c:\mouse\mouse.com</FONT>
</PRE>
<P>
Драйвер мыши выполняет следующие функции:
<UL>
<LI>отслеживает перемещения курсора и нажатия на клавиши мыши;
<LI>рисует на экране курсор, повторяющий движения мыши в графическом
или текстовом режимах;
<LI>предоставляет программам интерфейс для работы с мышью, основанный
на вызове прерывания INT&nbsp;33h.
</UL>
<H2><A NAME="ch3_3">3.3. Прерывание для обслуживания мыши</A>
</H2>
<P>
Драйвер мыши, независимо от того, реализован он через устанавливаемый
драйвер или резидентную программу, определяет обработчик прерывания
INT&nbsp;33h. Этот обработчик выполняет все операции, связанные
с обслуживанием мыши:
<UL>
<LI>сброс мыши и установка драйвера в исходное состояние;
<LI>включение/выключение курсора мыши;
<LI>установка курсора в определенное место экрана;
<LI>определение текущих координат курсора и текущего состояния
клавиш;
<LI>определение координат курсора и состояния клавиш в момент
нажатия на клавишу и в момент отпускания клавиши;
<LI>определение области на экране, в пределах которой может перемещаться
курсор;
<LI>определение области на экране, в пределах которой курсор не
будет виден;
<LI>определение формы графического и текстового курсоров;
<LI>определение величины перемещения мыши в сотых долях дюйма;
<LI>подключение к драйверу пользовательской процедуры, получающей
управление при нажатии на заданную клавишу или при перемещении
мыши;
<LI>запоминание и восстановление состояния драйвера;
<LI>управление эмуляцией светового пера;
<LI>управление скоростью движения курсора;
<LI>задание/определение используемой видеостраницы;
<LI>управление драйвером мыши.
</UL>
<P>
Приведем подробное описание всех функций прерывния INT&nbsp;33h,
используемых при работе с мышью.
<P>
3.3.1. <A HREF="#ch3_3_1">Инициализация мыши</A>
<P>
3.3.2. <A HREF="#ch3_3_2">Включить курсор мыши</A>
<P>
3.3.3. <A HREF="#ch3_3_3">Выключить курсор мыши</A>
<P>
3.3.4. <A HREF="#ch3_3_4">Определить положение курсора</A>
<P>
3.3.5. <A HREF="#ch3_3_5">Установить курсор</A>
<P>
3.3.6. <A HREF="#ch3_3_6">Определить положение курсора при нажатии клавиши</A>
<P>
3.3.7. <A HREF="#ch3_3_7">Определить положение курсора при отпускании клавиши</A>
<P>
3.3.8. <A HREF="#ch3_3_8">Задать диапазон движения курсора по горизонтали</A>
<P>
3.3.9. <A HREF="#ch3_3_9">Задать диапазон движения курсора по вертикали</A>
<P>
3.3.10. <A HREF="#ch3_3_10">Задать форму курсора в графическом режиме</A>
<P>
3.3.11. <A HREF="#ch3_3_11">Задать форму курсора в текстовом режиме</A>
<P>
3.3.12. <A HREF="#ch3_3_12">Определить содержимое счетчиков перемещения</A>
<P>
3.3.13. <A HREF="#ch3_3_13">Установить драйвер событий</A>
<P>
3.3.14. <A HREF="#ch3_3_14">Включить эмуляцию светового пера</A>
<P>
3.3.15. <A HREF="#ch3_3_15">Выключить эмуляцию светового пера</A>
<P>
3.3.16. <A HREF="#ch3_3_16">Задать скорость перемещения курсора мыши</A>
<P>
3.3.17. <A HREF="#ch3_3_17">Установить область исключения для курсора</A>
<P>
<A NAME="ch3_3_1">3.3.18. </A><A HREF="#ch3_3_18">Задать увеличенный графический курсор (PC MOUSE)</A>
<P>
3.3.19. <A HREF="#ch3_3_19">Определить порог удвоения скорости</A>
<P>
3.3.20. <A HREF="#ch3_3_20">Заменить драйвер событий</A>
<P>
3.3.21. <A HREF="#ch3_3_21">Определить размер буфера состояния драйвера</A>
<P>
3.3.22. <A HREF="#ch3_3_22">Сохранить состояние драйвера</A>
<P>
3.3.23. <A HREF="#ch3_3_23">Восстановить состояние драйвера</A>
<P>
3.3.24. <A HREF="#ch3_3_24">Установить альтернативный драйвер событий</A>
<P>
3.3.25. <A HREF="#ch3_3_25">Получить адрес альтернативного драйвера событий</A>
<P>
3.3.26. <A HREF="#ch3_3_26">Установить чувствительность мыши</A>
<P>
3.3.28. <A HREF="#ch3_3_28">Установить частоту прерываний для Inport Mouse</A>
<P>
3.3.29. <A HREF="#ch3_3_29">Установить номер видеостраницы</A>
<P>
3.3.30. <A HREF="#ch3_3_30">Определить номер видеостраницы</A>
<P>
3.3.31. <A HREF="#ch3_3_31">Отключить драйвер мыши</A>
<P>
3.3.32. <A HREF="#ch3_3_32">Восстановить драйвер мыши</A>
<P>
3.3.33. <A HREF="#ch3_3_33">Сбросить драйвер мыши</A>
<P>
3.3.34. <A HREF="#ch3_3_34">Определить тип мыши</A>
<H3>3.3.1. Инициализация мыши</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0000h.
        
На выходе:      AX = состояние мыши:

                0000h - драйвер мыши или мышь не
                                установлены;
                FFFFh - драйвер и мышь установлены;

                BX = количество клавиш у мыши:

                  2     - две клавиши;
                  0     - больше или меньше, чем две;
                  3     - мышь системы Mouse Systems
                                (имеет три клавиши).

</FONT>
</PRE>
<P>
Эта функция выполняет аппаратный сброс оборудования мыши и программную
установку драйвера мыши в начальное состояние. С помощью функции
21h можно выполнить установку драйвера в исходное состояние, не
выполняя аппаратного сброса мыши.
<P>
При установке в исходное состояние для программ, работающих в
текстовом режиме, выполняются следующие действия:
<UL>
<LI>курсор перемещается в центр экрана и гасится;
<LI>разрешается перемещение курсора по всей поверхности экрана,
причем на экране отсутствуют зоны, в которых курсор является невидимым;
<LI>устанавливается режим отображения курсора - инвертирование
атрибута символа, на который указывает курсор;
<LI>для изображения курсора выбирается нулевая страница видеопамяти;
<LI>разрешается эмуляция светового пера (хотя это вам едва ли
понадобится);
<LI>устанавливается начальная скорость перемещения курсора.
</UL>
<P>
Мы подготовили функцию для инициализации мыши из программы, составленной
на языке Си:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ms_init
*.Title        Инициализация мыши
*
*.Descr        Эта функция выполняет аппаратный сброс мыши,
*              устанавливает в начальные значения внутренние
*              переменные ее драйвера. Дополнительно определяется
*                       количество клавиш мыши.
*
*.Proto        int ms_init(int *nbottoms)
*
*.Params       int   *nbottoms - указатель на переменную 
*                  типа int, в которую будет записано количество
*                  клавиш, имеющихся в мыши.
*
*.Return       0   - плата или драйвер не установлены;
*              -1  - плата установлена, инициализация 
*                               выполнена успешно;
*
*              В переменную nbottoms записывается количество
*              клавиш мыши:
*
*               2  - две клавиши;
*               0  - больше или меньше, чем две;
*               3  - мышь системы Mouse Systems, три клавиши.
*
*.Sample       ms_sampl1.c
**/

#include &lt;dos.h&gt;
#include &lt;conio.h&gt;

union REGS reg;

int ms_init(int *nbottoms) {

        reg.x.ax = 0;
        int86(0x33,&amp;reg,&amp;reg);

        *nbottoms = reg.x.bx;
        return reg.x.ax;

}

</FONT>
</PRE>
<H3><A NAME="ch3_3_2">3.3.2. Включить курсор мыши</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0001h.
        
На выходе:      регистры не используются.</FONT>
</PRE>
<P>
Для управления видимостью курсора драйвер мыши использует внутренний
счетчик. Этот счетчик можно увеличивать, вызывая функцию 01h прерывания
INT&nbsp;33h, или уменьшать при помощи функции 02h этого же прерывания.
<P>
После инициализации драйвера функцией 00h счетчик устанавливается
равным -1. После первого вызова функции 01h счетчик становится
равным 0. При этом курсор мыши становится видимым, его можно перемещать
по экрану.
<P>
Если счетчик равен 0, то следующие вызовы функции 01h игнорируются
драйвером. Для того, чтобы погасить курсор, используйте функцию
02h, которая при вызове уменьшает каждый раз содержимое счетчика
на единицу.
<P>
Функция 01h сбрасывает область, в которой курсор не отображается
(если такая область была ранее установлена функцией 10h).
<P>
Вызов функции из Си:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ms_on
*.Title        Включение курсора мыши
*
*.Descr        Эта функция увеличивает на 1 индикатор
*              уровня видимости курсора. Если индикатор
*              равен нулю, курсор появляется на экране.
*              Значение индикатора не превышает
*                       нуля даже при многократных вызовах этой функции.
*
*.Proto        void ms_on(void)
*
*.Params       Не используются
*
*.Return       Ничего
*
*.Sample       ms_sampl1.c
**/

#include &lt;dos.h&gt;
#include &lt;conio.h&gt;

union REGS reg;

void ms_on(void) {

        reg.x.ax = 1;
        int86(0x33,&amp;reg,&amp;reg);
}

</FONT>
</PRE>
<H3><A NAME="ch3_3_3">3.3.3. Выключить курсор мыши</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0002h.
        
На выходе:      регистры не используются.

</FONT>
</PRE>
<P>
Эта функция уменьшает на единицу счетчик видимости курсора. Если
содержимое счетчика становится равным -1, изображение курсора
пропадает с экрана.
<P>
Если ваша программа использует для вывода на экран метод прямой
записи в экранную память, перед обновлением содержимого экрана
необходимо погасить курсор, а после завершения обновления высветить
его опять. Это связано с тем, что драйвер мыши &quot;помнит&quot;
старое значение атрибута символа, на который указывал курсор до
обновления содержимого видеопамяти. Вы изменили атрибут, записав
новое значение непосредственно в экранную память. Теперь, если
установить курсор мыши на другой символ, изображение старого символа
будет испорчено - появится прямоугольник (как бы еще одно изображение
курсора мыши).
<P>
Вызов функции:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ms_off
*.Title        Выключение курсора мыши
*
*.Descr        Эта функция уменьшает на 1 индикатор уровня
*              видимости курсора. После вызова этой функции 
*              курсор, если он был на экране, исчезает.
*              Многократные обращения будут последовательно 
*              уменьшать индикатор и затем потребуют 
*              многократных вызовов функции ms_on для 
*                       его включения.
*
*.Proto        void ms_off(void)
*
*.Params       Не используются
*
*.Return       Ничего
*
*.Sample       ms_sampl1.c
**/

#include &lt;dos.h&gt;
#include &lt;conio.h&gt;

union REGS reg;

void ms_off(void) {

        reg.x.ax = 2;
        int86(0x33,&amp;reg,&amp;reg);

}

</FONT>
</PRE>
<P>
Приведем программу, демонстрирующую применение описанных выше
функций. Программа инициализирует мышь, делает видимым курсор
мыши и &quot;прячет&quot; курсор после нажатия на любую клавишу:
<PRE>
<FONT COLOR=#000080>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

void main() {

        int botm;

// Инициализируем мышь, определяем количество клавиш

        if(!ms_init(&amp;botm)) {
                printf(&quot;\nМышь не установлена&quot;);
                exit(-1);
        }

        printf(&quot;\nУстановлена мышь: &quot;);
        switch (botm) {
          case 2:
                        printf(&quot;двухклавишная&quot;); break;
          case 3:
                        printf(&quot;трехклавишная, системы Mouse Systems&quot;);
                        break;
          case 0:
          default:
                        printf(&quot;неизвестной системы&quot;); break;
        }

// Включаем курсор и ожидаем нажатия на клавишу

        printf(&quot;\n\nКурсор мыши включен, &quot;
                &quot;для выключения нажмите любую клавишу&quot;);

        ms_on();

        getch();

// Выключаем курсор

        ms_off();
        printf(&quot;\nКурсор выключен, &quot;
                &quot;для завершения нажмите любую клавишу&quot;);

        getch();

}

</FONT>
</PRE>
<H3><A NAME="ch3_3_4">3.3.4. Определить положение курсора</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0003h.
        
На выходе:      BX = состояние клавиш мыши:

                бит 0 = 1  -     нажата левая клавиша;
                бит 1 = 1  -     нажата правая клавиша;
                бит 2 = 1  -     нажата средняя клавиша
                        (для мыши системы Mouse Systems);

                CX = координата X (по горизонтали);
                DX = координата Y (по вертикали).

</FONT>
</PRE>
<P>
Функция 03h возвращает текущие (на момент вызова функции) координаты
курсора мыши и состояние клавиш.
<P>
Для графических режимов координаты располагаются в различных диапазонах,
в зависимости от текущего видеорежима:
<PRE>
<FONT COLOR=#000080>Размер экрана   Номер режима    Диапазон координат
                                X       Y
320x200         4,5             0..638  0..199
640x200         6               0..639  0..199
320x200         0Dh             0..638  0..199
640x200         0Eh             0..639  0..199
640x350         0Fh             0..639  0..349

</FONT>
</PRE>
<P>
Программы, работающие в текстовом режиме, должны разделить полученные
координаты на 8 (как координату X, так и координату Y).
<P>
Приведем функцию, предназначенную для использования в программах,
составленных на языке Си:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ms_query
*.Title        Определение текущих координат курсора
*
*.Descr        Эта функция определяет текущие координаты 
*              курсора мыши и состояние клавиш на 
*              момент вызова. Определенное состояние 
*              записывается в структуру MOUSE_STATE, 
*                       описанную в файле sysp.h:
*
*                 typedef struct _MOUSE_STATE_ {
*                       unsigned bottoms;
*                       unsigned x;
*                       unsigned y;
*                 } MOUSE_STATE;
*
*              Адрес структуры передается функции в качестве
*                       параметра.
*
*.Proto        MOUSE_STATE *ms_query(MOUSE_STATE *state);
*
*.Params       MOUSE_STATE *state - указатель на структуру,
*                            описывающую состояние мыши.
*
*.Return       Функция возвращает значение своего параметра.
*
*.Sample       ms_samp1.c
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

union REGS reg;

MOUSE_STATE *ms_query(MOUSE_STATE *state) {

        reg.x.ax = 3;
        int86(0x33,&amp;reg,&amp;reg);

        state-&gt;bottoms = reg.x.bx;
        state-&gt;x       = reg.x.cx;
        state-&gt;y       = reg.x.dx;

        return(state);
}

</FONT>
</PRE>
<P>
Приведем пример программы, которая запрашивает номер видеорежима,
устанавливает его и динамически отображает координаты курсора
и состояние клавиш мыши. После завершения работы программа восстанавливает
первоначальный видеорежим:
<PRE>
<FONT COLOR=#000080>#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

union REGS reg;
void main() {

        int botm, i;
        MOUSE_STATE state;
        unsigned old_videomode, new_videomode;
        char buf[20], *bufptr;


// Определяем текущий видеорежим

        reg.x.ax = 0x0f00;
        int86(0x10, &amp;reg, &amp;reg);
        old_videomode = reg.h.al;

// Устанавливаем новый видеорежим:

// Устанавливаем максимально допустимую длину строки

        buf[0] = 10;
        printf(&quot;\nВведите десятичный номер видеорежима: &quot;);
        bufptr = cgets(buf);

// Преобразуем введенное число к формату int

        new_videomode = atoi(bufptr);

        reg.h.ah = 0;
        reg.h.al = new_videomode;
        int86(0x10, &amp;reg, &amp;reg);

// Инициализируем мышь, определяем количество клавиш

        if(!ms_init(&amp;botm)) {
                printf(&quot;\nМышь не установлена&quot;);
                exit(-1);
        }

        printf(&quot;\nУстановлена мышь: &quot;);
        switch (botm) {
          case 2:
                        printf(&quot;двухклавишная&quot;); break;
          case 3:
                        printf(&quot;трехклавишная, системы Mouse Systems&quot;);
                        break;
          case 0:
          default:
                        printf(&quot;неизвестной системы&quot;); break;
        }
        printf(&quot;\n\nСостояние мыши:\n\n&quot;);

// Включаем курсор

        ms_on();

        while(!kbhit()) {
                ms_query(&amp;state);
                printf(&quot;%2d x:%5d y:%5d&quot;,
                        state.bottoms,
                        state.x,
                        state.y);
                for(i=0;i&lt;18;i++) printf(&quot;\b&quot;);
        }
        getch();

        ms_off();

        reg.h.ah = 0;
        reg.h.al = old_videomode;
        int86(0x10, &amp;reg, &amp;reg);

}

</FONT>
</PRE>
<P>
Однако использование функции 03h - не самый лучший способ работы
с мышью. Программа должна постоянно следить за координатами курсора
или за состоянием клавиш. Это может привести к непроизводительным
затратам процессорного времени на опрос состояния.
<P>
Немного позже мы рассмотрим другие способы определения состояния
мыши.
<H3><A NAME="ch3_3_5">3.3.5. Установить курсор</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0004h;

                CX = устанавливаемая координата X 
                  (по горизонтали);

                DX = устанавливаемая координата Y
                  (по вертикали).

На выходе:      Регистры не используются.

</FONT>
</PRE>
<P>
Обычно курсор мыши устанавливает не программа, а оператор. Однако
с помощью функции 04h программа тоже может установить курсор в
заданную позицию. Для текстового режима устанавливаемые номера
строки и столбца должны быть умножены на 8.
<P>
Если программа пытается установить курсор в область, где курсор
невидим (эта область задается функцией 10h), то она сможет это
сделать. Курсор при этом исчезнет с экрана, что не всегда желательно.
<P>
Если при помощи функций 07h или 08h область для перемещения курсора
была ограничена, то при попытке установить курсор за границу этой
области, он будет установлен в точку, которая находится внутри
границы и находится на минимальном расстоянии от точки, заданной
при вызове функции.
<P>
Функция для установки курсора:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ms_setcr
*.Title        Установка курсора в заданную точку
*
*.Descr        Эта функция выполняет установку курсора мыши
*              в точку, заданную координатами X и Y.
*
*.Proto        void ms_setcr(int x, int y)
*
*.Params       int x   - горизонтальная координата курсора;
*              int y   - вертикальная координата курсора.
*
*.Return       Ничего
*
*.Sample       ms_samp2.c
**/

#include &lt;dos.h&gt;
#include &lt;conio.h&gt;

union REGS reg;

void ms_setcr(int x, int y) {


        reg.x.ax = 4;
        reg.x.cx = x;
        reg.x.dx = y;

        int86(0x33,&amp;reg,&amp;reg);
}

</FONT>
</PRE>
<P>
Приведем пример простой программы, которая устанавливает курсор
в левый верхний угол экрана:
<PRE>
<FONT COLOR=#000080>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

void main() {

        int botm;

// Инициализируем мышь

        if(!ms_init(&amp;botm)) {
                printf(&quot;\nМышь не установлена&quot;);
                exit(-1);
        }

// Включаем курсор и ожидаем нажатия на клавишу

        printf(&quot;\n\nКурсор мыши включен, &quot;
                        &quot;для выключения нажмите любую клавишу&quot;);

        ms_on();

// Устанавливаем курсор в левый верхний угол экрана

        ms_setcr(0,0);

        getch();

// Выключаем курсор

        ms_off();
}

</FONT>
</PRE>
<H3><A NAME="ch3_3_6">3.3.6. Определить положение курсора при
нажатии клавиши</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0005h;

                BX = клавиша, при нажатии которой
                     запоминается состояние мыши:
                        0 - левая;
                        1 - правая;
                        2 - средняя.
        
На выходе:      AX = состояние клавиш мыши:

                бит 0 = 1  -     нажата левая клавиша;
                бит 1 = 1  -     нажата правая клавиша;
                бит 2 = 1  -     нажата средняя клавиша
                        (для мыши системы Mouse Systems);

                BX = количество нажатий на заданную
                  клавишу, обнуляется после вызова функции;

                CX = координата X (по горизонтали);

                DX = координата Y (по вертикали).

</FONT>
</PRE>
<P>
В отличие от функции 03h эта функция возвращает программе не текущее
состояние мыши, а запомненное в момент последнего нажатия на клавишу,
заранее определенную при вызове функции. Она также возвращает
количество нажатий на заданную клавишу, которое вы можете использовать
для обнаружения двойных нажатий.
<P>
Функция для определения состояния мыши при нажатии на заданную
клавишу:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ms_querp
*.Title        Определение состояния мыши при нажатии на клавишу
*
*.Descr        Эта функция определяет координаты курсора мыши
*              и состояние клавиш в момент нажатия на заранее
*              заданную клавишу.
*              Определенное состояние записывается в структуру
*              MOUSE_STATE, описанную в файле sysp.h:
*
*                 typedef struct _MOUSE_STATE_ {
*                       unsigned bottoms;
*                       unsigned x;
*                       unsigned y;
*                 } MOUSE_STATE;
*
*              Адрес структуры передается функции в качестве 
*                       параметра.
*
*.Proto        int ms_querp(MOUSE_STATE *state, int bottom);
*
*.Params       MOUSE_STATE *state - указатель на структуру,
*                             описывающую состояние мыши.
*
*              int bottom - параметр определяет клавишу,
*                   при нажатии на которую необходимо 
*                               запомнить состояние:
*                             0 - левая клавиша,
*                             1 - правая клавиша,
*                             2 - средняя клавиша.
*
*.Return       Функция возвращает количество нажатий на 
*              заданную клавишу с момента последнего 
*                       вызова этой функции.
*
*.Sample       ms_samp3.c
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;


union REGS reg;

int ms_querp(MOUSE_STATE *state, int bottom) {

        reg.x.ax = 5;
        reg.x.bx = bottom;
        int86(0x33,&amp;reg,&amp;reg);

        state-&gt;bottoms = reg.x.ax;
        state-&gt;x       = reg.x.cx;
        state-&gt;y       = reg.x.dx;

        return(reg.x.bx);
}

</FONT>
</PRE>
<H3><A NAME="ch3_3_7">3.3.7. Определить положение курсора при
отпускании клавиши</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0006h;

                BX = клавиша, при отпускании которой
                  запоминается состояние мыши:
                        0 - левая;
                        1 - правая;
                        2 - средняя.
        
На выходе:      AX = состояние клавиш мыши:

                бит 0 = 1  -     нажата левая клавиша;
                бит 1 = 1  -     нажата правая клавиша;
                бит 2 = 1  -     нажата средняя клавиша
                        (для мыши системы Mouse Systems);

                BX = количество нажатий на заданную
                  клавишу, обнуляется после вызова функции;

                CX = координата X (по горизонтали);
                DX = координата Y (по вертикали).

</FONT>
</PRE>
<P>
Эта функция возвращает программе состояние мыши, запомненное в
момент отпускания клавиши, которая была заранее определена при
вызове функции. Она также возвращает количество отпусканий заданной
клавиши.
<P>
Функция для определения состояния мыши при отпускании заданной
клавиши:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ms_querr
*.Title        Определение состояния мыши при отпускании клавиши
*
*.Descr        Эта функция определяет координаты курсора мыши
*              и состояние клавиш в момент отпускания заранее
*              заданной клавиши.
*              Определенное состояние записывается в структуру
*              MOUSE_STATE, описанную в файле sysp.h:
*
*                 typedef struct _MOUSE_STATE_ {
*                       unsigned bottoms;
*                       unsigned x;
*                       unsigned y;
*                 } MOUSE_STATE;
*
*              Адрес структуры передается функции в качестве 
*                       параметра.
*
*.Proto        int ms_querr(MOUSE_STATE *state, int bottom);
*
*.Params       MOUSE_STATE *state - указатель на структуру,
*                              описывающую состояние мыши.
*
*              int bottom - параметр определяет клавишу, 
*                   при отпускании которой необходимо 
*                               запомнить состояние:
*                             0 - левая клавиша,
*                             1 - правая клавиша,
*                             2 - средняя клавиша.
*
*.Return       Функция возвращает количество отпусканий 
*              заданной клавиши с момента последнего 
*                       вызова этой функции.
*
*.Sample       ms_samp3.c
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;


union REGS reg;

int ms_querr(MOUSE_STATE *state, int bottom) {

        reg.x.ax = 6;
        reg.x.bx = bottom;
        int86(0x33,&amp;reg,&amp;reg);

        state-&gt;bottoms = reg.x.ax;
        state-&gt;x       = reg.x.cx;
        state-&gt;y       = reg.x.dx;

        return(reg.x.bx);
}

</FONT>
</PRE>
<P>
Приведем пример программы, которая определяет и выводит на экран
состояние мыши при нажатии и отпускании левой клавиши:
<PRE>
<FONT COLOR=#000080>#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

union REGS reg;
void main() {

        int botm, i;
        MOUSE_STATE state;
        unsigned old_videomode, new_videomode;
        char buf[20], *bufptr;


// Определяем текущий видеорежим

        reg.x.ax = 0x0f00;
        int86(0x10, &amp;reg, &amp;reg);
        old_videomode = reg.h.al;

// Устанавливаем новый видеорежим:

// Устанавливаем максимально допустимую длину строки

        buf[0] = 10;
        printf(&quot;\nВведите десятичный номер видеорежима: &quot;);
        bufptr = cgets(buf);

// Преобразуем введенное число к формату int

        new_videomode = atoi(bufptr);

        reg.h.ah = 0;
        reg.h.al = new_videomode;
        int86(0x10, &amp;reg, &amp;reg);

// Инициализируем мышь, определяем количество клавиш

        if(!ms_init(&amp;botm)) {
                printf(&quot;\nМышь не установлена&quot;);
                exit(-1);
        }

        printf(&quot;\nУстановлена мышь: &quot;);
        switch (botm) {
          case 2:
                        printf(&quot;двухклавишная&quot;); break;
          case 3:
                        printf(&quot;трехклавишная, системы Mouse Systems&quot;);
                        break;
          case 0:
          default:
                        printf(&quot;неизвестной системы&quot;); break;
        }
        printf(&quot;\n\nСостояние мыши:\n\n&quot;);

// Включаем курсор

        ms_on();

        while(!kbhit()) {

// Определяем состояние мыши при нажатии на левую клавишу

                i = ms_querp(&amp;state, 0);

// Если были нажатия на левую клавишу, выводим состояние мыши

                if(i != 0) {

// Перед выводом на экран отключаем курсор, затем включаем его
// снова.

                        ms_off();
                        printf(&quot;Нажатие:    %2d x:%5d y:%5d\n&quot;,
                                state.bottoms,
                                state.x,
                                state.y);
                        ms_on();

                }

// Выводим состояние при отпускании клавиши

                i = ms_querr(&amp;state, 0);
                if(i != 0) {

                        ms_off();
                        printf(&quot;Отпускание: %2d x:%5d y:%5d\n\n&quot;,
                                state.bottoms,
                                state.x,
                                state.y);
                        ms_on();
                }
        }
        getch();

        ms_off();

        reg.h.ah = 0;
        reg.h.al = old_videomode;
        int86(0x10, &amp;reg, &amp;reg);

}

</FONT>
</PRE>
<H3><A NAME="ch3_3_8">3.3.8. Задать диапазон движения курсора
по горизонтали</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0007h;

                CX = минимальная координата X 
                 (по горизонтали);

                DX = максимальная координата X.

На выходе:      Регистры не используются.

</FONT>
</PRE>
<P>
Данная функция позволяет ограничить диапазон перемещений курсора
мыши по горизонтали.
<P>
Вызов функции:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ms_rangx
*.Title        Задание диапазона перемещения курсора по горизонтали
*
*.Descr        Эта функция ограничивает область перемещения
*              курсора по горизонтали в пределах [xmin, xmax].
*
*.Proto        void ms_rangx(int xmin, int xmax)
*
*.Params       int xmin   - минимальная координата X курсора;
*              int xmax   - максимальная координата X курсора.
*
*.Return       Ничего
*
*.Sample       ms_samp4.c
**/

#include &lt;dos.h&gt;
#include &lt;conio.h&gt;

union REGS reg;

void ms_rangx(int xmin, int xmax) {


        reg.x.ax = 7;
        reg.x.cx = xmin;
        reg.x.dx = xmax;

        int86(0x33,&amp;reg,&amp;reg);
}

</FONT>
</PRE>
<H3><A NAME="ch3_3_9">3.3.9. Задать диапазон движения курсора
по вертикали</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0008h;

                CX = минимальная координата Y 
                  (по вертикали);

                DX = максимальная координата Y.

На выходе:      Регистры не используются.

</FONT>
</PRE>
<P>
Данная функция позволяет ограничить диапазон перемещений курсора
мыши по вертикали.
<P>
Вызов функции:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ms_rangy
*.Title        Задание диапазона перемещения курсора по вертикали
*
*.Descr        Эта функция ограничивает область перемещения
*              курсора по вертикали в пределах [ymin, ymax].
*
*.Proto        void ms_rangy(int ymin, int ymax)
*
*.Params       int ymin   - минимальная координата Y курсора;
*              int ymax   - максимальная координата Y курсора.
*
*.Return       Ничего
*
*.Sample       ms_samp4.c
**/

#include &lt;dos.h&gt;
#include &lt;conio.h&gt;

union REGS reg;

void ms_rangy(int ymin, int ymax) {


        reg.x.ax = 8;
        reg.x.cx = ymin;
        reg.x.dx = ymax;

        int86(0x33,&amp;reg,&amp;reg);

}

</FONT>
</PRE>
<P>
Приведем текст программы, которая ограничивает диапазон перемещений
курсора мыши по экрану:
<PRE>
<FONT COLOR=#000080>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

void main() {

        int botm;

// Инициализируем мышь

        if(!ms_init(&amp;botm)) {
                printf(&quot;\nМышь не установлена&quot;);
                exit(-1);
        }


// Включаем курсор и ожидаем нажатия на клавишу

        printf(&quot;\n\nКурсор мыши включен, для выключения&quot;
                        &quot; нажмите любую клавишу&quot;);

        ms_on();

// Задаем границы, в которых должен перемещаться курсор

        ms_rangx(20, 100);
        ms_rangy(50, 100);

        getch();

// Выключаем курсор

        ms_off();
}

</FONT>
</PRE>
<H3><A NAME="ch3_3_10">3.3.10. Задать форму курсора в графическом
режиме</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0009h;

                BX = номер позиции точки-указателя графического
                 курсора (от -16 до 16);

                CX = номер строки точки-указателя 
                 (от -16 до 16);

                ES:DX = указатель на битовое изображение
                        курсора.

На выходе:      Регистры не используются.

</FONT>
</PRE>
<P>
С помощью этой функции программа, работающая в графическом режиме,
может изменить форму курсора мыши и положение точки внутри изображения
курсора, координаты которой используются в качестве координат
курсора остальными функциями.
<P>
Регистры ES:DX указывают на область длинной 64 байта. Эта область
состоит из двух массивов длиной по 32 байта. Первый массив представляет
из себя логическую маску размером 16х16 битов, которая накладывается
на участок видеопамяти с использованием логической операции &quot;И&quot;.
Второй массив - тоже маска размером 16х16, но она накладывается
с использованием логической операции &quot;Исключающее ИЛИ&quot;,
инвертируя отдельные точки изображения.
<P>
Номера позиции и строки точки-указателя, устанавливаемые по умолчанию,
равны 0 (BX=CX=0). Это соответствует верхней левой точке в изображении
курсора. Значения BX=CX=15 соответствуют нижней правой точке.
<P>
Приведем исходный текст функции для изменения формы курсора из
программы, составленной на языке Си:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ms_gform
*.Title        Задание формы курсора в графическом режиме
*
*.Descr        Эта функция определяет форму курсора мыши 
*              для графического режима. Дополнительно можно 
*              задать положение точки-указателя, которая 
*              соответствует координатам курсора.
*
*.Proto        void ms_gform(int xt, int yt, char _far *form)
*
*.Params       int xt - позиция точки указателя;
*              int yt - номер строки точки-указателя;
*              char *form - указатель на массив, описывающий 
*                               курсор.
*
*.Return       Ничего
*
*.Sample       ms_samp5.c
**/

#include &lt;dos.h&gt;
#include &lt;conio.h&gt;

union REGS reg;
struct SREGS segregs;

void ms_gform(int xt, int yt, char _far *form) {


        reg.x.ax = 9;
        reg.x.bx = xt;
        reg.x.cx = yt;
        reg.x.dx = FP_OFF(form);
        segregs.es = FP_SEG(form);

        int86x(0x33,&amp;reg,&amp;reg,&amp;segregs);
}

</FONT>
</PRE>
<P>
Мы подготовили пример программы, изменяющий форму курсора в графическом
режиме:
<PRE>
<FONT COLOR=#000080>#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

union REGS reg;

char form[64] = {

// Массив маски по &quot;И&quot;

        255,255, 255,255, 255,255, 255,255, 255,255,
                255,255, 255,255, 255,255,
        255,255, 255,255, 255,255, 255,255, 255,255, 
                255,255, 255,255, 255,255,

// Массив маски по &quot;Исключающее ИЛИ&quot;

        127,254, 127,254, 127,254, 127,254, 127,254,
                 127,254, 127,254, 0,0,
        0,0, 127,254, 127,254, 127,254, 127,254, 127,254,
                 127,254, 127,254,
        };


void main() {

        int botm, i;
        MOUSE_STATE state;
        unsigned old_videomode, new_videomode;
        char buf[20], *bufptr;


// Определяем текущий видеорежим

        reg.x.ax = 0x0f00;
        int86(0x10, &amp;reg, &amp;reg);
        old_videomode = reg.h.al;

// Устанавливаем новый видеорежим:

// Устанавливаем максимально допустимую длину строки

        buf[0] = 10;
        printf(&quot;\nВведите десятичный номер видеорежима: &quot;);
        bufptr = cgets(buf);

// Преобразуем введенное число к формату int

        new_videomode = atoi(bufptr);

        reg.h.ah = 0;
        reg.h.al = new_videomode;
        int86(0x10, &amp;reg, &amp;reg);

// Инициализируем мышь

        if(!ms_init(&amp;botm)) {
                printf(&quot;\nМышь не установлена&quot;);
                exit(-1);
        }

// Задаем новую форму для курсора мыши

        ms_gform(0,0, &amp;form[0]);

// Включаем курсор

        ms_on();

        getch();

        ms_off();

        reg.h.ah = 0;
        reg.h.al = old_videomode;
        int86(0x10, &amp;reg, &amp;reg);
}

</FONT>
</PRE>
<H3><A NAME="ch3_3_11">3.3.11. Задать форму курсора в текстовом
режиме</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 000Ah;

                BX = тип курсора:
                  0 - определяемый программно;
                  1 - определяемый аппаратно;

                CX = маска экрана (для BX=0) или
                  начальная строка курсора (для BX=1);

                DX = маска курсора (для BX=0) или
                  конечная строка курсора (для BX=1).

На выходе:      Регистры не используются.

</FONT>
</PRE>
<P>
С помощью этой функции программа может изменять форму курсора
мыши в текстовом режиме.
<P>
В зависимости от содержимого регистра BX драйвер мыши использует
курсор, определяемый аппаратными средствами, либо курсор, определяемый
программно. По умолчанию используется &quot;программный курсор&quot;,
который отображается в виде символа с инвертированным значением
атрибута. Курсор, сформированный аппаратными средствами, выглядит
аналогично обычному текстовому курсору, его форма - прямоугольник.
Размер этого прямоугольника можно задавать при помощи регистров
CX и DX.
<P>
Для курсора, определяемого программно, вначале выполняется операция
логического &quot;И&quot; над содержимым видеопамяти в том месте,
куда указывает курсор, и маской экрана. Затем выполняется операция
&quot;Исключающее ИЛИ&quot; с маской курсора.
<P>
Младший байт масок соответствует ASCII-коду символа, старший -
это байт атрибута символа.
<P>
Значения, используемые по умолчанию - BX=7700h, CX=FFFFh.
<P>
Если вам надо изменить цвет курсора, не меняя его форму, задайте
CX=00FFh, BX=xx00h, где xx определяет цвет (смотри описание формата
байта атрибутов в третьем томе книги).
<P>
Приведем функцию для изменения формы курсора в текстовом примере
и программу, создающую курсор в виде вертикальной стрелки, направленной
вверх на синем фоне:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ms_tform
*.Title        Задание формы курсора в текстовом режиме
*
*.Descr        Эта функция определяет форму курсора мыши для
*              текстового режима.
*
*.Proto        void ms_tform(int type, int mask1, int mask2)
*
*.Params       int type - тип курсора:
*                     0 - программный, 1 - аппаратный;
*              int mask1 - AND-маска экрана
*                     или первая строка аппаратного курсора
*              int mask2 - XOR-маска курсора
*                     или последняя строка аппаратного курсора
*
*.Return       Ничего
*
*.Sample       ms_samp6.c
**/

#include &lt;dos.h&gt;
#include &lt;conio.h&gt;

union REGS reg;

void ms_tform(int type, int mask1, int mask2) {


        reg.x.ax = 0xA;
        reg.x.bx = type;
        reg.x.cx = mask1;
        reg.x.dx = mask2;

        int86(0x33,&amp;reg,&amp;reg);

}
#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

union REGS reg;

void main() {

        int botm, i;
        MOUSE_STATE state;


// Инициализируем мышь

        if(!ms_init(&amp;botm)) {
                printf(&quot;\nМышь не установлена&quot;);
                exit(-1);
        }

// Задаем новую форму для курсора мыши

        ms_tform(0, 0, 0x1418);

// Включаем курсор

        ms_on();

        getch();

        ms_off();
}

</FONT>
</PRE>
<H3><A NAME="ch3_3_12">3.3.12. Определить содержимое счетчиков
перемещения</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 000Bh.
        
На выходе:      CX = перемещение по горизонтали с момента
                  последнего вызова функции;

                DX = перемещение по вертикали с момента
                  последнего вызова функции.

</FONT>
</PRE>
<P>
Функция позволяет определить относительное перемещение мыши с
момента последнего вызова этой функции. Результат возвращается
в указанных выше регистрах. Для измерения перемещения используется
единица mickey - &quot;мики&quot;. Один мик соответствует 0.005
дюйма (т.е. 1/200 дюйма).
<P>
Отрицательные значения перемещения означают, соответственно, движение
влево и вверх, положительные - вправо и вниз.
<P>
Для преобразования миков в пиксели (точки экрана) можно использовать
функцию 1Bh, которая будет описана немного позже.
<P>
Функция для определения относительного перемещения:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ms_querm
*.Title        Определение показания счетчика перемещений
*
*.Descr        Эта функция определяет относительное перемещение
*              мыши с момента последнего вызова функции.
*
*              Определенное состояние записывается в структуру
*              MOUSE_STATE, описанную в файле sysp.h:
*
*                 typedef struct _MOUSE_STATE_ {
*                       unsigned bottoms;
*                       unsigned x;
*                       unsigned y;
*                 } MOUSE_STATE;
*
*              Адрес структуры передается функции в качестве 
*                       параметра. Перемещение определяется в миках 
*              - 1/200 долях дюйма.
*
*.Proto        MOUSE_STATE *ms_querm(MOUSE_STATE *state);
*
*.Params       MOUSE_STATE *state - указатель на структуру,
*                               описывающую состояние мыши.
*
*.Return       Функция возвращает значение своего параметра.
*
*.Sample       ms_samp7.c
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

union REGS reg;

MOUSE_STATE *ms_querm(MOUSE_STATE *state) {

        reg.x.ax = 0xB;
        int86(0x33,&amp;reg,&amp;reg);

        state-&gt;bottoms = 0;
        state-&gt;x       = reg.x.cx;
        state-&gt;y       = reg.x.dx;

        return(state);
}

</FONT>
</PRE>
<P>
Для иллюстрации приведем программу, постоянно вызывающую эту функцию
и отображающую на экране величину относительного перемещения мыши:
<PRE>
<FONT COLOR=#000080>#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

union REGS reg;
void main() {

        int botm, i;
        MOUSE_STATE state;
        unsigned old_videomode, new_videomode;
        char buf[20], *bufptr;


// Определяем текущий видеорежим

        reg.x.ax = 0x0f00;
        int86(0x10, &amp;reg, &amp;reg);
        old_videomode = reg.h.al;

// Устанавливаем новый видеорежим:

// Устанавливаем максимально допустимую длину строки

        buf[0] = 10;
        printf(&quot;\nВведите десятичный номер видеорежима: &quot;);
        bufptr = cgets(buf);

// Преобразуем введенное число к формату int

        new_videomode = atoi(bufptr);

        reg.h.ah = 0;
        reg.h.al = new_videomode;
        int86(0x10, &amp;reg, &amp;reg);

// Инициализируем мышь, определяем количество клавиш

        if(!ms_init(&amp;botm)) {
                printf(&quot;\nМышь не установлена&quot;);
                exit(-1);
        }
        printf(&quot;\n\nСостояние мыши:\n\n&quot;);

// Включаем курсор

        ms_on();

        while(!kbhit()) {
                ms_querm(&amp;state);
                printf(&quot;x:%5d y:%5d&quot;,
                        state.x,
                        state.y);
                for(i=0;i&lt;15;i++) printf(&quot;\b&quot;);
        }
        getch();

        ms_off();

        reg.h.ah = 0;
        reg.h.al = old_videomode;
        int86(0x10, &amp;reg, &amp;reg);
}

</FONT>
</PRE>
<H3><A NAME="ch3_3_13">3.3.13. Установить драйвер событий</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:     AX = 000Ch;

              CX = маска вызова:
                бит 0 - вызов при перемещении мыши;
                бит 1 - вызов при нажатии левой клавиши;
                бит 2 - вызов при отпускании левой
                                клавиши;
                бит 3 - вызов при нажатии правой клавиши;
                бит 4 - вызов при отпускании правой
                                клавиши;
                бит 5 - вызов при нажатии средней клавиши;
                бит 6 - вызов при отпускании
                                средней клавиши;
                7Fh   - вызов при любом событии;
                00h   - отключение драйвера событий;

               ES:DX = адрес (дальний) подключаемого
                        драйвера событий.

На выходе:     Регистры не используются.

</FONT>
</PRE>
<P>
Функция позволяет программе создать свой собственный драйвер (обработчик)
событий, связанных с перемещением мыши и нажатием/отпусканием
клавиш мыши.
<P>
Адрес подготовленной программы-драйвера передается при вызове
функции в регистровой паре ES:DX. Драйвер должен быть оформлен
в виде дальней процедуры, завершающейся командой дальнего возврата
RETF. Когда драйвер получает управление, в регистрах процессора
содержатся следующие значения:
<PRE>
<FONT COLOR=#000080>AX      Маска вызова, такая же, как и при вызове
        функции&nbsp;0Ch.

BX      Состояние клавиш мыши:

                бит 0 - левая клавиша;
                бит 1 - правая клавиша;
                бит 2 - средняя клавиша.

CX      Горизонтальная координата курсора мыши.

DX      Вертикальная координата курсора мыши.

SI      Относительное перемещение мыши по горизонтали
        в миках.

DI      Относительное перемещение мыши по вертикали
        в миках.

DS      Сегмент данных драйвера мыши.

</FONT>
</PRE>
<P>
Так как регистр DS при вызове драйвера событий содержит сегмент
данных драйвера мыши, ваш драйвер событий должен позаботиться
о правильной установке этого регистра. Ваш драйвер событий не
обязан сохранять и восстанавливать содержимое регистра DS и других
регистров процессора.
<P>
Отметим, что если вам необходимо отключить драйвер, выполните
повторный вызов функции 0Ch, записав в регистр CX нулевое значение.
Если ваша программа, устанавливающая собственный драйвер событий,
завершает свою работу и передает управление MS-DOS, предварительно
она обязательно должна отключить драйвер событий.
<P>
Приведем функцию, которую мы разработали для подключения драйвера
событий:
<PRE>
<FONT COLOR=#000080>/**
*.Name         ms_seth
*.Title        Установка драйвера событий
*
*.Descr        Эта функция выполняет установку драйвера событий.
*
*.Proto        void ms_seth(int mask, void (far *hand)())
*
*.Params       int mask - маска событий;
*              void (far *hand)() - адрес драйвера событий
*
*.Return       Ничего
*
*.Sample       ms_samp8.c
**/

#include &lt;dos.h&gt;
#include &lt;conio.h&gt;

union REGS reg;
struct SREGS segregs;

void ms_seth(int mask, void (far *hand)()) {

        reg.x.ax = 0x14;
        reg.x.cx = mask;
        reg.x.dx = FP_OFF(hand);
        segregs.es = FP_SEG(hand);

        int86x(0x33,&amp;reg,&amp;reg,&amp;segregs);

}

</FONT>
</PRE>
<P>
Составление программы драйвера событий имеет некоторые особенности.
Драйвер событий вызывается не из программы пользователя, а из
драйвера мыши. При этом сегментный регистр DS будет указывать
на сегмент данных драйвера мыши, а не на сегмент данных вашей
программы.
<P>
Мы подготовили образец драйвера событий, использовав язык ассемблера:
<PRE>
<FONT COLOR=#000080>;**
;.Name         ms_handl
;.Title        Драйвер событий
;
;.Descr        Драйвер событий вызывается драйвером мыши,
;              когда происходит какое-нибудь событие из числа
;              заданных при установке драйвера событий.
;              Функция не должна вызываться из программы
;              пользователя, ее вызывает только драйвер мыши.
;
;.Proto        void far ms_handl(void);
;
;.Params       Не используются
;
;.Return       Ничего
;
;.Sample       ms_samp8.c
;**

        DOSSEG
DGROUP  GROUP   _DATA

_DATA   SEGMENT WORD PUBLIC 'DATA'
_DATA   ENDS

_TEXT   SEGMENT WORD PUBLIC 'CODE'
        ASSUME  cs:_TEXT, ds:DGROUP, ss:DGROUP

; Флаг вызова драйвера событий

extrn   _ms_flag:word

; Внешние переменные для записи содержимого регистров

extrn   _ms_bx:word
extrn   _ms_cx:word
extrn   _ms_dx:word
extrn   _ms_si:word
extrn   _ms_di:word
extrn   _ms_ds:word

public  _ms_handl

_ms_handl   proc far

        mov     _ms_ds, ds

; Так как на входе в драйвер событий регистр DS указывает на
; сегмент данных драйвера мыши, устанавливаем его на сегмент
; данных программы;

        push    ax
        mov     ax, DGROUP
        mov     ds, ax
        pop     ax

        mov     _ms_bx, bx
        mov     _ms_cx, cx
        mov     _ms_dx, dx
        mov     _ms_si, si
        mov     _ms_di, di

; Устанавливаем флаг вызова драйвера в 1, сигнализируя
; программе о том, что произошло событие.

        mov     _ms_flag, 1

        ret

_ms_handl   endp

_TEXT   ENDS

        END

</FONT>
</PRE>
<P>
Этот драйвер при вызове устанавливает глобальную переменную _ms_flag
в единицу, затем переписывает содержимое всех нужных регистров
в соответствующие глобальные переменные. Программа, установив
драйвер событий и сбросив флаг _ms_flag, может выполнять какие-либо
действия (например, вывод на экран движущегося изображения), постоянно
проверяя флаг _ms_flag. Как только произойдет какое-либо событие
(нажатие или отпускание клавиши мыши, перемещение мыши) драйвер
событий установит флаг в единицу. Программа при этом может узнать
состояние мыши, прочитав содержимое глобальных переменных _ms_bx,
_ms_dx, и т.д.
<P>
Этот простейший вариант использования драйвера событий иллюстрируется
следующей программой:
<PRE>
<FONT COLOR=#000080>#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &quot;sysp.h&quot;

extern void far ms_handl(void);

// Флаг драйвера событий. При вызове драйвер событий
// запишет в эту переменную значение 1.

        unsigned ms_flag;

// Область для содержимого регистров на входе
// в драйвер событий.

        unsigned ms_bx;
        unsigned ms_cx;
        unsigned ms_dx;
        unsigned ms_si;
        unsigned ms_di;
        unsigned ms_ds;

        int botm;

main () {

        ms_flag=0;
// Инициализируем мышь, определяем количество клавиш

        if(!ms_init(&amp;botm)) {
                printf(&quot;\nМышь не установлена&quot;);
                exit(-1);
        }

// Подключаем драйвер событий, устанавливаем маску таким образом,
// чтобы драйвер вызывался при нажатии на левую или правую
// клавиши мыши.

        ms_seth(2 | 8, ms_handl);

// Включаем курсор

        ms_on();

// Ожидаем вызова драйвера событий.

        for(;;) {
                if(ms_flag) {
                        ms_off();

                        printf(&quot;\nСостояние регистров &quot;
                                        &quot;на входе драйвера:&quot;
                                 &quot;\nms_bx: %0X&quot;
                                 &quot;\nms_cx: %0X&quot;
                                 &quot;\nms_dx: %0X&quot;
                                 &quot;\nms_si: %0X&quot;
                                 &quot;\nms_di: %0X&quot;
                                 &quot;\nms_ds: %0X&quot;,
                                 ms_bx,
                                 ms_cx,
                                 ms_dx,
                                 ms_si,
                                 ms_di,
                                 ms_ds);

                        printf(&quot;\nНажмите любую клавишу...&quot;);
                        getch();
                        exit(0);
                }
        }
}

</FONT>
</PRE>
<P>
Драйвер событий может также организовать очередь событий, записывая
в эту очередь состояние мыши на момент появления события и время
появления события.
<P>
Прикладная программа будет затем извлекать события из очереди
и анализировать их.
<H3><A NAME="ch3_3_14">3.3.14. Включить эмуляцию светового пера</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 000Dh.

На выходе:      Регистры не используются.

</FONT>
</PRE>
<P>
Если ваша программа использует световое перо (например, она написана
на языке Бейсик и вызывает функцию PEN), вы можете заменить световое
перо на мышь. После включения режима эмуляции драйвер запоминает
координаты курсора при нажатии на клавиши мыши. Эти координаты
могут быть впоследствии считаны функцией PEN или функцией 04h
прерывания INT&nbsp;10h, предназначенной для работы со световым
пером.
<H3><A NAME="ch3_3_15">3.3.15. Выключить эмуляцию светового пера</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 000Eh.

На выходе:      Регистры не используются.

</FONT>
</PRE>
<P>
Эта функция выключает режим эмуляции светового пера.
<H3><A NAME="ch3_3_16">3.3.16. Задать скорость перемещения курсора
мыши</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 000Fh;

                CX = количество миков на 8 точек по
                  горизонтали;

                DX = количество миков на 8 точек по
                  вертикали.

На выходе:      Регистры не используются.

</FONT>
</PRE>
<P>
Функция определяет &quot;чувствительность&quot; мыши к перемещению
по поверхности стола, т.е. устанавливает соответствие между величиной
перемещения мыши по столу и величиной перемещения курсора мыши
по экрану.
<P>
При инициализации драйвера мыши используются следующие значения:
CX=8, DX=16.
<H3><A NAME="ch3_3_17">3.3.17. Установить область исключения для
курсора</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0010h;

                CX, DX = координаты (X, Y) верхнего левого
                        угла области исключения;

                SI, DI = координаты (X, Y) нижнего правого
                        угла области исключения.

На выходе:      Регистры не используются.

</FONT>
</PRE>
<P>
Функция позволяет задать на экране прямоугольную область, в которой
автоматически выключается изображение курсора мыши - область исключения.
Эта область отменяется функциями 01h (включить курсор мыши) и
00h (инициализация).
<P>
Оператор может поместить курсор мыши в область исключения, при
этом изображение курсора пропадет.
<P>
Основное назначение этой функции - предоставить программе возможность
изменять содержимое области экрана не выключая изображение курсора.
Недостаток функции - вы можете &quot;потерять&quot; курсор мыши,
если он случайно окажется в области исключения.
<H3><A NAME="ch3_3_18">3.3.18. Задать увеличенный графический
курсор (PC MOUSE)</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0012h;

                BH = ширина курсора в словах;

                CH = количество строк в изображении курсора;

                BL = номер позиции точки-указателя графического
                  курсора (от -16 до 16);

                CL = номер строки точки-указателя 
                  (от -16 до 16);

                ES:DX = указатель на битовое изображение
                   курсора.

На выходе:      Регистры не используются.

</FONT>
</PRE>
<P>
Эта функция позволяет задать увеличенный по размеру курсор мыши,
но она определена только для мыши системы PC&nbsp;MOUSE.
<H3><A NAME="ch3_3_19">3.3.19. Определить порог удвоения скорости</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0013h.
        
На выходе:      DX = значение порога удвоения, мики в секунду.

</FONT>
</PRE>
<P>
Если вы перемещаете мышь со скоростью, превышающей порог удвоения,
заданный функцией 13h, аппаратура мыши удваивает величину перемещения.
Таким образом, используя медленное перемещение мыши, вы можете
точно устанавливать курсор на требуемый элемент изображения. Если
вам необходимо переместить курсор на значительное расстояние по
экрану, вы можете увеличить скорость перемещения мыши.
<P>
При инициализации устанавливается значение порога, равное 64 микам
в секунду (1/3 дюйма в секунду). Если вам надо установить это
значение, вы можете при вызове функции 13h задать DX=0.
<H3><A NAME="ch3_3_20">3.3.20. Заменить драйвер событий</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:     AX = 0014h;

              CX = маска вызова:
                бит 0 - вызов при перемещении мыши;
                бит 1 - вызов при нажатии левой клавиши;
                бит 2 - вызов при отпускании левой
                                клавиши;
                бит 3 - вызов при нажатии правой клавиши;
                бит 4 - вызов при отпускании правой
                                клавиши;
                бит 5 - вызов при нажатии средней клавиши;
                бит 6 - вызов при отпускании
                                средней клавиши;
                7Fh   - вызов при любом событии;
                00h   - отключение драйвера событий;

              ES:DX = адрес (дальний) подключаемого
                        драйвера событий.

На выходе:    CX = маска предыдущего драйвера событий;

              ES:DX = адрес предыдущего драйвера событий
                        (т.е. адрес заменяемого драйвера
                        событий).

</FONT>
</PRE>
<P>
Функция аналогична функции 0Ch, однако ее основное назначение
- временная замена драйвера событий. Например, подпрограмма в
начале своей работы может установить свой драйвер событий, а перед
завершением - активизировать драйвер, использовавшийся ранее.
<H3><A NAME="ch3_3_21">3.3.21. Определить размер буфера состояния
драйвера</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0015h.

На выходе:      BX = размер буфера, требующийся для хранения
                состояния драйвера мыши.

</FONT>
</PRE>
<P>
Если вам требуется временно сохранить состояние драйвера мыши,
а затем восстановить его, вы можете воспользоваться специально
предназначенными для этого функциями 16h и 17h. Для этих функций
требуется буфер, в котором будет храниться состояние драйвера.
Размер буфера можно определить с помощью функции 15h.
<P>
Когда может потребоваться запоминание и восстановление состояния
драйвера? Например, при использовании мыши резидентными (TSR)
программами желательно сохранить состояние драйвера перед началом
работы TSR-программы и восстановить его перед завершением работы
TSR-программы.
<H3><A NAME="ch3_3_22">3.3.22. Сохранить состояние драйвера</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0016h;

                ES:DX = адрес буфера для записи состояния
                   драйвера.

На выходе:      Не используются.

</FONT>
</PRE>
<P>
Функция позволяет записать состояние драйвера в буфер, размер
которого должен быть определен с помощью функции 15h.
<H3><A NAME="ch3_3_23">3.3.23. Восстановить состояние драйвера</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0017h;

                ES:DX = адрес буфера, содержащего состояние
                        драйвера.

На выходе:      Не используются.

</FONT>
</PRE>
<P>
Функция позволяет восстановить состояние драйвера из буфера, в
который оно было записано при помощи функции 16h.
<H3><A NAME="ch3_3_24">3.3.24. Установить альтернативный драйвер
событий</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:     AX = 0018h;

              CX = маска вызова:
                бит 0 - вызов при перемещении мыши;
                бит 1 - вызов при нажатии левой клавиши;
                бит 2 - вызов при отпускании левой
                                клавиши;
                бит 3 - вызов при нажатии правой клавиши;
                бит 4 - вызов при отпускании правой
                                клавиши;
                бит 5 - вызов при одновременном нажатии
                                клавиши мыши и клавиши SHIFT
                                на клавиатуре;
                бит 6 - вызов при одновременном нажатии
                                клавиши мыши и клавиши CTRL
                                на клавиатуре;
                бит 7 - вызов при одновременном нажатии
                                клавиши мыши и клавиши ALT
                                на клавиатуре;
                7Fh   - вызов при любом событии;
                00h   - отключение драйвера событий;

              ES:DX = адрес (дальний) подключаемого
                        драйвера событий.

На выходе:    AX = результат установки:
                0018h - драйвер успешно установлен;
                FFFFh - ошибка при установке драйвера.

</FONT>
</PRE>
<P>
По сравнению с функцией 0Ch эта функция обеспечивает дополнительные
возможности:
<UL>
<LI>проверка состояния клавиш SHIFT, CTRL, ALT во время нажатия
на клавиши мыши.
<LI>возможность одновременной установки до трех драйверов событий,
каждый из которых использует свою маску событий, задаваемых в
регистре CX.
</UL>
<P>
При попытке установить два драйвера с одной и той же маской событий
функция возвращает в регистре AX код ошибки FFFFh. В этом случае
вы можете использовать функцию 19h для получения адреса предыдущего
установленного драйвера событий, отключить его и повторить попытку
подключения своего драйвера.
<P>
Вы можете использовать функцию 18h для отключения драйвера событий,
если укажете в регистрах ES:DX его адрес и зададите в регистре
CX значение маски, равное 0.
<H3><A NAME="ch3_3_25">3.3.25. Получить адрес альтернативного
драйвера событий</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0019h;

                CX = маска событий, для которой требуется
                  получить адрес драйвера (формат маски
                  соответствует функции 18h).

На выходе:      CX = маска событий или 0000h, если заданной
                  маске не соответствует ни один
                  установленный драйвер событий;

                ES:DX = адрес драйвера событий, использующий
                  заданную маску событий.

</FONT>
</PRE>
<P>
Эта функция предназначена для получения адреса драйвера событий
с заданной маской событий. Получив адрес, вы можете установить
новый драйвер, использующий эту же маску.
<H3><A NAME="ch3_3_26">3.3.26. Установить чувствительность мыши</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 001Ah;

                BX = горизонтальная чувствительность в
                  миках на точку (пиксель);

                CX = вертикальная чувствительность в
                  миках на точку (пиксель);

                DX = значение порога удвоения, мики в секунду.

На выходе:      Не используются.

</FONT>
</PRE>
<P>
Эта функция является комбинацией функций 0Fh и 13h. Она позволяет
одновременно устанавливать чувствительность мыши и порог удвоения
скорости.
<H3><A NAME="ch3_3_27">3.3.27. Определить чувствительность мыши</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 001Bh.

На выходе:      BX = горизонтальная чувствительность в
                  миках на точку (пиксель);

                CX = вертикальная чувствительность в
                  миках на точку (пиксель);

                DX = значение порога удвоения, мики в секунду.

</FONT>
</PRE>
<P>
Функция позволяет определить текущие значения для чувствительности
мыши и порога удвоения.
<H3><A NAME="ch3_3_28">3.3.28. Установить частоту прерываний для
Inport Mouse</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 001Ch

                BX = код скорости прерываний:

                  1 - нет прерываний;
                  2 - 30 прерываний в секунду;
                  4 - 50 прерываний в секунду;
                  8 - 100 прерываний в секунду;
                  16 - 200 прерываний в секунду.

На выходе:      Не используются

</FONT>
</PRE>
<P>
Мышь периодически вырабатывает сигнал прерывания, по которому
драйвер считывает текущее состояние мыши. С помощью функции 1Ch
вы можете изменять частоту появления прерываний, но только для
мыши системы Inport Mouse (Вы можете определить тип используемой
мыши с помощью функции 24h).
<P>
Если используется большая частота прерываний, возрастает точность
определения состояния мыши, но уменьшается общая производительность
системы.
<H3><A NAME="ch3_3_29">3.3.29. Установить номер видеостраницы</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 001Dh;

        BX = номер видеостраницы.

На выходе:      Не используются.

</FONT>
</PRE>
<P>
Данная функция задает номер видеостраницы, на которой будет отображаться
курсор мыши. По умолчанию для отображения используется страница
0. Подробнее о видеостраницах вы узнаете из следующего тома книги.
<H3><A NAME="ch3_3_30">3.3.30. Определить номер видеостраницы</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 001Eh.

На выходе:      BX = номер видеостраницы.

</FONT>
</PRE>
<P>
Функция возвращает номер видеостраницы, на которой в настоящее
время отображается курсор мыши.
<H3><A NAME="ch3_3_31">3.3.31. Отключить драйвер мыши</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 001Fh.

На выходе:      AX = результат выполнения:

                        001Fh - драйвер отключен;
                        FFFFh - отключение невозможно;

                ES:DX = вектор предыдущего драйвера мыши.

</FONT>
</PRE>
<P>
После вызова этой функции драйвер мыши полностью отключается.
Вектор прерывания INT&nbsp;33h остается определенным, однако теперь
выполняется только одна функция прерывания INT&nbsp;33h - функция
21h (программный сброс мыши).
<P>
Функцию 1Fh удобно использовать для временной замены драйвера
на собственную систему обслуживания мыши. Сначала вы отключаете
драйвер функцией 1Fh, запоминая вектор предыдущего драйвера, возвращаемого
в регистрах ES:DX. Затем устанавливаете собственную систему обслуживания
мыши. Впоследствии вы восстанавливаете значение этого вектора.
<H3><A NAME="ch3_3_32">3.3.32. Восстановить драйвер мыши</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0020h.

На выходе:      Не используются.

</FONT>
</PRE>
<P>
Функция восстанавливает связь между мышью и драйвером, отключенную
вызовом функции 1Fh.
<H3><A NAME="ch3_3_33">3.3.33. Сбросить драйвер мыши</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0021h.

На выходе:      AX = результат:
                        0021h - драйвер сброшен успешно;
                        FFFFh - невозможно сбросить драйвер
                                (например, нет драйвера);

                BX = количество клавиш на корпусе мыши.

</FONT>
</PRE>
<P>
Функция аналогична функции 00h, но она не выполняет аппаратного
сброса оборудования мыши.
<H3><A NAME="ch3_3_34">3.3.34. Определить тип мыши</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AX = 0024h.

На выходе:      BH = верхний (major) номер версии драйвера;

                BL = нижний (minor) номер версии драйвера;

                CH = тип мыши:

                  1 - Bus Mouse;
                  2 - Serial Mouse;
                  3 - Inport Mouse;
                  4 - PS/2 Mouse;
                  5 - HP Mouse;

                CL = номер используемого прерывания (IRQ):
                  0 - IBM PS/2;
                  2,3,4,5,7 - IBM PC.

</FONT>
</PRE>
<P>
Эта функция дает информацию о типе используемой мыши, версии драйвера
мыши и об используемом номере прерывания.
</BODY>
</HTML>
