<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Аппаратное обеспечение IBM PC</TITLE>
<link rel=stylesheet type=text/css href="../../images/styles.css">
<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.04z">
</HEAD>
<body>
<H1>12.&nbsp;АРИФМЕТИЧЕСКИЙ СОПРОЦЕССОР </H1>
<P>
12.1. <A HREF="#ch12_1">Вещественные числа</A>
<P>
12.2. <A HREF="#ch12_2">Целые числа</A>
<P>
12.3. <A HREF="#ch12_3">Регистры сопроцессора</A>
<P>
12.4. <A HREF="#ch12_4">Система команд сопроцессора</A>
<P>
12.5. <A HREF="#ch12_5">Программирование сопроцессора</A>
<P>
12.6. <A HREF="#ch12_6">Обработка особых случаев </A>
<P>
Последнее устройство, которое мы опишем в этом томе - арифметический
сопроцессор Intel 8087/80287/80387. Это устройство подключено
непосредственно к центральному процессору и предназначено для
выполнения операций над числами в формате с плавающей точкой (вещественные
числа) и длинными целыми числами.
<P>
Арифметический сопроцессор значительно (в десятки раз) ускоряет
вычисления, связанные с вещественными числами. Он может вычислять
такие функции, как синус, косинус, тангенс, логарифмы и т.д. Разумеется,
что с помощью сопроцессора можно выполнять и простейшие арифметические
операции сложения, вычитания, умножения и деления.
<P>
Основная область применения арифметического сопроцессора - научные
расчеты и машинная графика. Некоторые пакеты САПР, например, Autocad
версии 10, отказывается работать, если в машине отсутствует сопроцессор.
Более современный процессор Intel 80486 содержит встроенный арифметический
сопроцессор, совместимый с 80387 (и даже немного более мощный).
<P>
Сопроцессор запускается центральным процессором. После запуска
он выполняет все вычисления самостоятельно и параллельно с работой
центрального процессора. Если центральный процессор выдает очередную
команду сопроцессору в момент времени, когда тот еще не закончил
выполнение предыдущей команды, центральный процессор переводится
в состояние ожидания. Если же сопроцессор ничем не занят, центральный
процессор, выдав команду сопроцессору, продолжает свою работу,
не дожидаясь завершения вычисления. Впрочем, есть специальные
средства синхронизации (команда FWAIT).
<P>
Как программировать сопроцессор?
<P>
Команды, предназначенные для выполнения сопроцессором, записываются
в программе как обычные машинные команды центрального процессора.
Но все эти команды начинаются байта, соответствующего команде
центрального процессора ESC.
<P>
Встретив такую команду, процессор передает ее на выполнение сопроцессору,
а сам продолжает выполнение программы со следующей команды.
<P>
Ассемблерные мнемоники всех команд сопроцессора начинаются с буквы
F, например: FADD, FDIV, FSUB и т.д. Команды сопроцессора могут
адресоваться к операндам, аналогично обычным командам центрального
процессора. операндами могут быть либо данные, расположенные в
основной памяти компьютера, либо внутренние регистры сопроцессора.
<P>
Возможны все виды адресации данных, используемые центральным процессором.
<P>
Прежде чем начать обсуждение команд, выполняемых сопроцессором,
приведем форматы используемых данных. Как мы уже говорили, сопроцессор
может работать либо с данными в формате с плавающей точкой, либо
с целыми числами. В следующем разделе мы рассмотрим используемые
форматы чисел с плавающей точкой или форматы вещественных чисел.
<H2><A NAME="ch12_1">12.1. Вещественные числа</A></H2>
<P>
Прежде чем говорить о форматах вещественных числе, используемых
сопроцессором, вспомним о числах с плавающей точкой, встречающихся
в научных расчетах.
<P>
В общем виде эти числа можно записать следующим образом:
<PRE>
<FONT COLOR=#000080>(знак)(мантисса)*10(знак)(порядок)

</FONT>
</PRE>
<P>
Например: -1.35*105
<P>
Здесь знак - это минус, мантисса - 1.35, порядок - 5. Порядок
тоже может иметь знак. В этом представлении чисел для вас вряд
ли есть что либо новое. Вспомним также такое понятие, как норамализованное
представление чисел:
<UL>
<LI>если целая часть мантиссы числа состоит из одной, не равной
нулю, цифры, то число с плавающей точкой называется нормализованным.
</UL>
<P>
В чем преимущества использования нормализованных чисел? В том,
что для фиксированной разрядной сетки числа (т.е. для фиксированного
количества цифр в числе) нормализованные числа имеют наибольшую
точность. Кроме того, нормализованное представление исключает
неоднозначность - каждое число с плавающей точкой может быть представлено
различными (ненормализованными) способами:
<PRE>
<FONT COLOR=#000080>123.5678*105 = 12.35678*106 = 1.235678*107 = 0.1235678*108

</FONT>
</PRE>
<P>
Для тех, кто программировал на языках высокого уровня, знакомо
следующее представление чисел с плавающей точкой:
<PRE>
<FONT COLOR=#000080>(знак)(мантисса)E(знак)(порядок)

</FONT>
</PRE>
<P>
Например, -5.35E-2 означает число -5.35*10-2. Такое представление
называется научной нотацией.
<P>
Сопроцессор 8087/80287/80387 может работать с вещественными числами
в трех форматах:
<UL>
<LI>одинарной точности;
<LI>двойной точности;
<LI>расширенной точности.
</UL>
<P>
Эти числа занимают в памяти, соответственно, 4, 8 или 10 байтов:
<BR>
<PRE>
<FONT COLOR=#000080>Одинарная точность

1 бит 8 бит     23 бита
---T-------T--------------------¬
¦Зн¦Порядок¦      Мантисса      ¦
L--+-------+---------------------

Двойная точность
1 бит 11 бит          52 бита
---T---------T--------------------------------¬
¦Зн¦ Порядок ¦            Мантисса            ¦
L--+---------+---------------------------------

Расширенная точность
1 бит 15 бит                   64 бита
---T-------------T------------------------------------¬
¦Зн¦   Порядок   ¦               Мантисса             ¦
L--+-------------+-------------------------------------


</FONT>
</PRE>
<P>
В любом представлении старший бит &quot;Зн&quot; определяет знак
вещественного числа:
<UL>
<LI>0 - положительное число;
<LI>1 - отрицательное число.
</UL>
<P>
Все равные по абсолютному значению положительные и отрицательные
числа отличаются только этим битом. В остальном числа с разным
знаком полностью симметричны. Для представления отрицательных
чисел здесь не используется дополнительный код, как это сделано
в центральном процессоре.
<P>
Арифметический сопроцессор работает с нормализованными числами,
поэтому поле мантиссы содержит мантиссу нормализованного числа.
<P>
Так как здесь используется двоичное представление чисел, сформулируем
определение нормализованного числа для двоичного представления:
<UL>
<LI>если целая часть мантисса числа в двоичном представлении равна
1, то число с плавающей точкой называется нормализованным.
</UL>
<P>
Так как для нормализованного двоичного числа целая часть всегда
равна единице, то эту единицу можно не хранить. Именно так и поступили
разработчики арифметического сопроцессора - в форматах одинарной
и двойной точности целая часть мантиссы не хранится. Таким образом
экономится один бит памяти.
<P>
Для наглядности представим мантиссу числа в следующей форме:
<PRE>
<FONT COLOR=#000080>n.nnnnnnnnnn...n

</FONT>
</PRE>
<P>
Здесь символом n обозначается либо 0, либо 1. Нормализованные
числа в самой левой позиции содержат 1, поэтому их можно изобразить
еще и в таком виде:
<PRE>
<FONT COLOR=#000080>1.nnnnnnnnnn...n

</FONT>
</PRE>
<P>
Представление с расширенной точностью используется сопроцессором
для выполнения всех операций. И даже более - все операции с числами
сопроцессор выполняет над числами только в формате с расширенной
точностью. В этом формате хранится и &quot;лишний&quot; бит целой
части нормализованного числа.
<P>
Основная причина использования для вычислений расширенной точности
- предохранение программы от возможной потери точности вычислений,
связанной с большими различиями в порядках чисел, участвующих
в арифметических операциях.
<P>
Поле порядка - это степень числа 2, на которую умножается мантисса,
плюс смещение, равное 127 для одинарной точности, 1023 - для двойной
точности и 16383 - для расширенной точности.
<P>
Для того, чтобы определить абсолютное значение числа с плавающей
точкой, можно воспользоваться следующими формулами:
<UL>
<LI>одинарная точность: 1.(цифры мантиссы)*2(P-127)
<LI>двойная точность: 1.(цифры мантиссы)*2(P-1023)
<LI>расширенная точность: 1.(цифры мантиссы)*2(P-16383)
</UL>
<P>
Знак числа, как мы уже говорили, определяется старшим битом.
<P>
Приведем конкретный пример. Пусть мы имеем число с одинарной точностью,
которое в двоичном виде выглядит следующим образом:
<PRE>
<FONT COLOR=#000080>1 01111110 11000000000000000000000

</FONT>
</PRE>
<P>
Для этого числа знаковый бит равен 1 (отрицательное число), порядок
равен 126, мантисса - 11 (в двоичной системе счисления).
<P>
Значение этого числа равно:
<PRE>
<FONT COLOR=#000080>1.11 * 2(126-127) = -1.75 * 2-1 = -0,875

</FONT>
</PRE>
<P>
Рассмотрим теперь различные особые случаи представления вещественных
чисел.
<UL>
<LI>Нуль - это такое число, у которого порядок и мантисса равны
нулю. Нуль может иметь положительный или отрицательный знаки,
которые игнорируются в операциях сравнения. Таким образом, имеется
два нуля - положительный и отрицательный.
<LI>Наименьшее положительное число - это число, которое имеет
нулевой знаковый бит, значение порядка, равное 1, и значение мантиссы,
равное нулю. В зависимости от представления наименьшее положительное
число имеет следующие значения: 1,17*10-38 (одинарная точность),
2.23*10-308 (двойная точность), 3.37*10-4932 (расширенная точность).
<LI>Наибольшее отрицательное число - полностью совпадает с наименьшим
положительным числом, но имеет бит знака, установленный в 1.
<LI>Наибольшее положительное число -это число, которое имеет нулевой
знаковый бит, поле порядка, в котором все биты кроме самого младшего,
равны 1, и содержит единицы во всех разрядах мантиссы. В зависимости
от представления наибольшее положительное число имеет следующие
значения: 3.37*1038 (одинарная точность), 1.67*10308 (двойная
точность), 1.2*104932 (расширенная точность).
<LI>Наименьшее отрицательное число - полностью совпадает с наибольшим
положительным числом, но имеет бит знака, установленный в 1.
<LI>Положительная и отрицательная бесконечность - это число содержит
все единицы в поле порядка и все нули в поле мантиссы. В зависимости
от состояния знакового бита может быть положительная и отрицательная
бесконечности. Бесконечность может получиться, например, как результат
деления конечного числа на нуль.
<LI>Нечисло - содержит все единицы в поле порядка и любое значение
в поле мантиссы. Нечисло может возникнуть в результате выполнения
неправильной операции при замаскированных особых случаях (ошибкам
при работе с сопроцессоре будет посвящен отдельный раздел этой
главы).
<LI>Неопределенность - содержит в поле порядка все единицы, а
в поле мантиссы - число 1000..0 (для одинарной и двойной точности)
или 11000..0 (для расширенной точности, так как в этом формате
хранится старший бит мантиссы).
</UL>
<P>
Для большей наглядности сведем все возможные представления вещественных
чисел в таблицу:
<PRE>
<FONT COLOR=#000080>Положительный нуль      
--T---------T------------------¬
¦0¦  0...0  ¦      0...0       ¦
L-+---------+-------------------

Отрицательный нуль
--T---------T------------------¬
¦1¦  0...0  ¦      0...0       ¦
L-+---------+-------------------

Наименьшее положительное число
--T---------T------------------¬
¦0¦  0...01 ¦      0...0       ¦
L-+---------+-------------------

Наибольшее отрицательное число
--T---------T------------------¬
¦1¦  0...01 ¦      0...0       ¦
L-+---------+-------------------

Наибольшее положительное число
--T---------T------------------¬
¦0¦ 11...10 ¦      1...1       ¦
L-+---------+-------------------

Наименьшее отрицательное число
--T---------T------------------¬
¦1¦ 11...10 ¦      1...1       ¦
L-+---------+-------------------

Положительная бесконечность
--T---------T------------------¬
¦0¦  1...1  ¦      0...0       ¦
L-+---------+-------------------

Отрицательная бесконечность
--T---------T------------------¬
¦1¦  1...1  ¦      0...0       ¦
L-+---------+-------------------

Нечисло
--T---------T------------------¬
¦1¦  1...1  ¦      х...х       ¦
L-+---------+-------------------

Неопределенность
--T---------T------------------¬
¦1¦  1...1  ¦     10...0       ¦
L-+---------+-------------------

</FONT>
</PRE>
<H2><A NAME="ch12_2">12.2. Целые числа</A></H2>
<P>
Арифметический сопроцессор наряду с вещественными числами способен
обрабатывать и целые числа. Он имеет команды, выполняющие преобразования
целых чисел в вещественные и обратно.
<P>
Возможно четыре формата целых чисел:
<UL>
<LI>целое число;
<LI>короткое целое число;
<LI>длинное целое число;
<LI>упакованное десятичное число.
</UL>
<P>
Целое число занимает два байта. Его формат полностью соответствует
используемому центральным процессором. Для представления отрицательных
чисел используется дополнительный код. Короткое целое и длинное
целое имеют аналогичные форматы, но занимают, соответственно,
4 и 8 байтов.
<P>
Упакованное десятичное число занимает 10 байтов. Это число содержит
18 десятичных цифр, расположенных по две в каждом байте. Знак
упакованного десятичного числа находится в старшем бите самого
левого байта. Остальные биты старшего байта должны быть равны
0.
<P>
Существуют команды сопроцессора, которые преобразуют числа в формат
упакованных десятичных чисел из внутреннего представления в расширенном
вещественном формате. Если программа делает попытку преобразования
в упакованный формат денормализованных чисел, нечисел, бесконечности
и т.п., в результате получается неопределенность. Неопределенность
в упакованном формате представляет из себя число, в котором два
старших байта содержат единицы во всех разрядах. Содержимое остальных
восьми байтов произвольно. При попытке использовать такое упакованное
число в операциях фиксируется ошибка.
<P>
Мы подробно рассмотрели формат представления вещественных чисел
и отметили, что в этом формате для представления отрицательных
чисел используется специальный знаковый бит. Для целых чисел используется
дополнительный код.
<P>
В дополнительном коде положительные числа содержат нуль в самом
старшем бите числа:
<PRE>
<FONT COLOR=#000080>0XXX XXXX XXXX XXXX

</FONT>
</PRE>
<P>
Для получения отрицательного числа в дополнительном коде из положительного
надо инвертировать каждый бит числа и затем прибавить к числу
единицу.
<P>
Например, число +5 в дополнительном коде выглядит следующим образом:
<PRE>
<FONT COLOR=#000080>0000 0000 0000 0101 = +5

</FONT>
</PRE>
<P>
Для получения числа -5 вначале инвертируем значение каждого бита:
<PRE>
<FONT COLOR=#000080>1111 1111 1111 1010

</FONT>
</PRE>
<P>
Теперь прибавим к полученному числу +1:
<PRE>
<FONT COLOR=#000080>1111 1111 1111 1011 = -5

</FONT>
</PRE>
<P>
Приведем возможные варианты представления целых чисел:
<PRE>
<FONT COLOR=#000080>Нуль    
        -------------------¬
        ¦      0...0       ¦
        L-------------------

Наименьшее положительное число
        -------------------¬
        ¦      0...1       ¦
        L-------------------

Наибольшее отрицательное число
        -------------------¬
        ¦      1...1       ¦
        L-------------------

Наибольшее положительное число
        -------------------¬
        ¦      01...1      ¦
        L-------------------

Наименьшее отрицательное число
        -------------------¬
        ¦      10...01     ¦
        L-------------------
Неопределенность
        -------------------¬
        ¦      10...00     ¦
        L-------------------

</FONT>
</PRE>
<P>
Упакованное десятичное число имеет следующий вид:
<PRE>
<FONT COLOR=#000080>¦1-й байт ¦ Девять байтов     ¦
+--T------+---T---T---T---T---+
¦Зн¦000000¦n17¦n16¦...¦n1 ¦n0 ¦
L--+------+---+---+---+---+----

</FONT>
</PRE>
<P>
На этом рисунке n0...n17 означают разряды десятичного числа. Они
могут изменяться в пределах от 0000 до 1001, т.е. от 0 до 9 в
десятичной системе счисления.
<P>
Теперь, после того как мы рассмотрели форматы данных, с которыми
может работать арифметический сопроцессор, можно перейти к изучению
внутренних регистров сопроцессора.
<H2><A NAME="ch12_3">12.3. Регистры сопроцессора</A></H2>
<P>
Арифметический сопроцессор содержит восемь численных 80-битовых
регистров, предназначенных для хранения промежуточных результатов
вычислений, регистра управления, регистра состояния, регистра
тегов, регистра указателя команды и регистра указателя операнда.
<H3>12.3.1. Численные регистры</H3>
<P>
Мы будем обозначать численные регистры как ST0 - ST7. Они приведены
на следующем рисунке:
<PRE>
<FONT COLOR=#000080>80 бит
    ----------------------------------------------------¬
ST0 ¦                                                   ¦
    +---------------------------------------------------+
ST1 ¦                                                   ¦
    +---------------------------------------------------+
ST2 ¦                                                   ¦
    +---------------------------------------------------+
ST3 ¦                                                   ¦
    +---------------------------------------------------+
ST4 ¦                                                   ¦
    +---------------------------------------------------+
ST5 ¦                                                   ¦
    +---------------------------------------------------+
ST6 ¦                                                   ¦
    +---------------------------------------------------+
ST7 ¦                                                   ¦
    L----------------------------------------------------

</FONT>
</PRE>
<P>
Численные регистры используются как стек. Регистр состояния в
поле ST содержит номер численного регистра, являющего вершиной
стека. При выполнении команд в качестве операнда могут выступать
численные регистры. В этом случае номер указанного в команде регистра
прибавляется к содержимому поля ST регистра состояния и таким
образом определяется используемый регистр. Большинство команд
после выполнения увеличивают поле ST регистра состояния, как бы
записывая результаты своей работы в стек численных регистров.
<P>
Вы можете использовать регистры как массив, но в этом случае необходимо
заботится о постоянстве поля ST регистра состояния, так как в
противном случае номера численных регистров будут изменяться.
<H3>12.3.2. Регистр тегов</H3>
<P>
Этот регистр разделен на восемь двухбитовых полей, которые мы
обозначим как TAG0...TAG7. Каждое поле относится к своему численному
регистру:
<PRE>
<FONT COLOR=#000080>-----T----T----T----T----T----T----T----¬
¦TAG0¦TAG1¦TAG2¦TAG3¦TAG4¦TAG5¦TAG6¦TAG7¦
L----+----+----+----+----+----+----+-----

</FONT>
</PRE>
<P>
Поля регистра тегов классифицируют содержимое &quot;своего&quot;
численного регистра:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=64>00</TD><TD WIDTH=393>регистр содержит действительное ненулевое число;
</TD></TR>
<TR><TD WIDTH=64>01</TD><TD WIDTH=393>в регистре находится нуль;
</TD></TR>
<TR><TD WIDTH=64>10</TD><TD WIDTH=393>регистр содержит недействительное число (нечисло, бесконечность, неопределенность);
</TD></TR>
<TR><TD WIDTH=64>11</TD><TD WIDTH=393>пустой неинициализированный регистр.
</TD></TR>
</TABLE>
<P>
Например, если все регистры сопроцессора были пустые, а затем
в стек численных регистров было занесено одно действительное ненулевое
значение, содержимое регистра тегов будет 3FFFh.
<H3>12.3.3. Регистр управления</H3>
<P>
Регистр управления для сопроцессора 8087 показан на следующем
рисунке:
<PRE>
<FONT COLOR=#000080>  15-13   12 11-10  9-8   7   6   5   4   3   2   1  0
---------T-T-----T-----T---T---T---T---T---T---T---T---¬
¦XXXXXXXX¦IC¦ RC  ¦ PC  ¦IEM¦XXX¦PM ¦UM ¦OM ¦ZM ¦DM ¦IM ¦
L--------+--+-----+-----+---+---+---+---+---+---+---+----

</FONT>
</PRE>
<P>
Регистр управления сопроцессоров 80287/80387 и сопроцессора, входящего
в состав процессора 80486, имеет аналогичный формат, за исключением
того, что бит 7 в нем не используется:
<PRE>
<FONT COLOR=#000080>  15-13   12 11-10  9-8    7-6    5   4   3   2   1  0
---------T-T-----T-----T--------T---T---T---T---T---T---¬
¦XXXXXXXX¦IC¦ RC  ¦ PC  ¦XXXXXXXX¦PM ¦UM ¦OM ¦ZM ¦DM ¦IM ¦
L--------+--+-----+-----+--------+---+---+---+---+---+----

</FONT>
</PRE>
<P>
Биты 0...5 - маски особых случаев. Особые случаи иногда возникают
при выполнении команд сопроцессора, например, при делении на нуль,
переполнении и т.д. Если все биты масок особых случаев равны нулю,
особый случай вызывает прерывание центрального процессора INT
10h (обратите внимание, что это прерывание используется BIOS для
работы с дисплейным адаптером). Если же особые случаи замаскированы
установкой соответствующих битов в единичное состояние, прерывание
не вырабатывается, а в качестве результата возвращается особое
значение - бесконечность, нечисло и т.д.
<P>
Приведем таблицу масок особых случаев:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=64>IM</TD><TD WIDTH=393>маска недействительной операции;
</TD></TR>
<TR><TD WIDTH=64>DM</TD><TD WIDTH=393>маска денормализованного результата;
</TD></TR>
<TR><TD WIDTH=64>ZM</TD><TD WIDTH=393>маска деления на нуль;</TD>
</TR>
<TR><TD WIDTH=64>OM</TD><TD WIDTH=393>маска переполнения;</TD>
</TR>
<TR><TD WIDTH=64>UM</TD><TD WIDTH=393>маска антипереполнения;
</TD></TR>
<TR><TD WIDTH=64>PM</TD><TD WIDTH=393>маска особого случая при неточном результате;
</TD></TR>
<TR><TD WIDTH=64>IEM</TD><TD WIDTH=393>маскирование одновременно всех особых случаев вне зависимости от установки битов 0...5 регистра управления, этот бит действителен только для сопроцессора 8087
</TD></TR>
</TABLE>
<P>
Подробнее особые случаи и условия их возникновения будут описаны
позже, когда мы займемся ошибками при выполнении команд в сопроцессоре.
<P>
Поле PC управляет точностью вычислений в сопроцессоре:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=64>00</TD><TD WIDTH=393>использование расширенной точности, этот режим устанавливается при инициализации сопроцессора;
</TD></TR>
<TR><TD WIDTH=64>10</TD><TD WIDTH=393>округление результата до двойной точности;
</TD></TR>
<TR><TD WIDTH=64>00</TD><TD WIDTH=393>округление результата до одинарной точности.
</TD></TR>
</TABLE>
<P>
Искусственное ухудшение точности вычислений не приводит к ускорению
работы программы. Режимы с пониженной точностью предназначены
для эмуляции процессоров, использующих двойную и одинарную точность,
соответственно.
<P>
Двух битовое поле RC задает режим округления при выполнении операций
с вещественными числами:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=36>00</TD><TD WIDTH=421>округление к ближайшему числу, этот режим устанавливается при инициализации сопроцессора;
</TD></TR>
<TR><TD WIDTH=36>01</TD><TD WIDTH=421>округление в направлении к отрицательной бесконечности;
</TD></TR>
<TR><TD WIDTH=36>10</TD><TD WIDTH=421>округление в направлении к положительной бесконечности;
</TD></TR>
<TR><TD WIDTH=36>11</TD><TD WIDTH=421>округление в направлении к нулю.
</TD></TR>
</TABLE>
<P>
На следующих рисунках демонстрируются перечисленные выше режимы
округления. Символами &quot;o&quot; обозначены точные значения
вещественных чисел, символами &quot;x&quot; приближенные значения.
Стрелки &quot;&lt;&lt;&quot; и &quot;&gt;&gt;&quot; указывают
направление округления. В центре линии расположен нуль числовой
оси, на ее левом и правом конце - отрицательная и положительная
бесконечности.
<PRE>
<FONT COLOR=#000080>Округление в направлении к ближайшему числу.

-беск.&lt;-o-&lt;&lt;-x-------o---- 0 -----o-----x-&gt;&gt;-o----&gt;+беск.

Округление в направлении к отрицательной бесконечности.

-беск.&lt;-o-&lt;&lt;-x-------o---- 0 -----o--&lt;&lt;---x-o----&gt;+беск.

Округление в направлении к положительной бесконечности.

-беск.&lt;-o-x--&gt;&gt;-----o---- 0 -----o------x-&gt;&gt;-o----&gt;+беск.

Округление в направлении к нулю.

-беск.&lt;-o-x--&gt;&gt;-----o---- 0 -----o--&lt;&lt;----x-o----&gt;+беск.

</FONT>
</PRE>
<P>
Для наибольшего уменьшения ошибок вычислений наиболее целесообразно
использовать режим округления в направлении к ближайшему числу.
Режим округления в направлении к нулю используется при моделировании
целочисленной арифметики.
<P>
Остальные два режима округления используют в интервальной арифметике.
Для получения наиболее точного результата каждая команда (операция)
выполняется два раза - первый раз с округлением в направлении
к отрицательной бесконечности, второй раз - в направлении к положительной
бесконечности. Точный результат лежит между полученными значениями.
Заметьте, что здесь речь идет только об отелных операциях, но
не о том, чтобы выполнить всю программу вычислений вначале с одним
режимом округления, а затем с другим.
<P>
Поле IC регистра управления предназначен для управления бесконечностью:
<PRE>
<FONT COLOR=#000080>0       проективный режим;
1       афинный режим.

</FONT>
</PRE>
<P>
В проективном режиме существует только одна бесконечность, она
не имеет знака:
<PRE>
<FONT COLOR=#000080>Бесконечность
-----------------&gt; &lt;-----------------¬
¦                                    ¦
¦                                    ¦
¦                                    ¦
L---------------- 0 ------------------

</FONT>
</PRE>
<P>
В афинном режиме имеется две бесконечности - положительная и отрицательная:
<BR>
<PRE>
<FONT COLOR=#000080>-бесконечность                             + бесконечность 
&lt;-------------------------- 0 ----------------------------&gt;

</FONT>
</PRE>
<P>
Афинный режим допускает выполнение многих операций с бесконечностями
- сложение, умножение и т.д.
<H3>12.3.4. Регистр состояния</H3>
<P>
Поля регистра состояния сопроцессора 8087 показаны на следующем
рисунке:
<PRE>
<FONT COLOR=#000080> 15 14 13-11 10 9  8  7  6  5  4   3  2  1  0
---T-T-----T-T-T-T-T-T-T---T-T-T-T--¬
¦B ¦C3¦ ST  ¦C2¦C1¦C0¦IR¦XX¦PE¦UE ¦OE¦ZE¦DE¦IE¦
L--+--+-----+--+--+--+--+--+--+---+--+--+--+---


</FONT>
</PRE>
<P>
Регистр состояния сопроцессоров 80287/80387 и сопроцессора, входящего
в состав процессора 80486, имеет немного другой формат:
<PRE>
<FONT COLOR=#000080> 15 14 13-11 10 9  8  7  6  5  4   3  2  1  0
---T--T-----T--T-T-T-T-T--T--T---T---T--T-----¬
¦B ¦C3¦ ST  ¦C2¦C1¦C0¦ES¦XX¦PE¦UE ¦OE¦ZE¦DE¦IE¦
L--+--+-----+--+--+--+--+--+--+---+--+--+--+---

</FONT>
</PRE>
<P>
В обоих форматах биты 0...5 - флажки особых случаев. Они устанавливаются
всегда при возникновении особых случаев, даже замаскированных
установкой в 1 соответствующих битов регистра управления.
<P>
Приведем таблицу флажков особых случаев:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=54>IE</TD><TD WIDTH=402>недействительная операция;
</TD></TR>
<TR><TD WIDTH=54>DE</TD><TD WIDTH=402>денормализованный результат;
</TD></TR>
<TR><TD WIDTH=54>ZE</TD><TD WIDTH=402>деление на нуль;</TD></TR>
<TR><TD WIDTH=54>OE</TD><TD WIDTH=402>переполнение;</TD></TR>
<TR><TD WIDTH=54>UE</TD><TD WIDTH=402>антипереполнение;</TD></TR>
<TR><TD WIDTH=54>PE</TD><TD WIDTH=402>неточный результат.</TD>
</TR>
</TABLE>
<P>
Для того, чтобы сбросить установившийся флажок, программа должна
явным образом установить его в нуль, выполнив команду записи в
регистр состояния.
<P>
Назначение бита 7 регистра состояния различно для сопроцессора
8087 и сопроцессоров 80287/80387.
<P>
Для сопроцессора 8087 этот бит обозначается IR и содержит флаг
запроса прерывания при возникновении незамаскированного особого
случая. В этом случае флаг устанавливается в 1.
<P>
Сопроцессоры 80287/80387 используют бит 7 в качестве флага суммарной
ошибки, который устанавливается в 1 при возникновении незамаскированного
особого случая.
<P>
Биты C0, C1, C2, C3 - это коды условий. Они определяются по результату
выполнения команд сравнения и команды нахождения остатка. Мы расскажем
о них при описании соответствующих команд сопроцессора.
<P>
Поле ST занимает три бита 11...13 и содержит номер численного
регистра, являющегося вершиной стека численных регистров.
<P>
Бит B - бит занятости. Он устанавливается в 1, когда процессор
выполняет команду или когда происходит прерывание от сопроцессора.
Если сопроцессор свободен, бит занятости установлен в 0.
<H3>12.3.5. Регистры указателя команды и указателя операнда</H3>
<P>
Регистры указателя команды и указателя операнда предназначены
для обработки особых случаев, возникающих при выполнении команд
в сопроцессоре.
<P>
В сопроцессоре 8087 указатель команды содержит 20-разрядный адрес
команды, вызвавшей особый случай и код выполняемой в этот момент
операции. Адрес команды здесь указывается без учета предшествующих
команде префиксов:
<PRE>
<FONT COLOR=#000080>---------------------------------------------------¬
¦Адрес команды (0...15)                            ¦
+------------------------T-T-----------------------+
¦Адрес команды (16...19) ¦X¦ Код операции (0...10) ¦
L------------------------+-+------------------------

</FONT>
</PRE>
<P>
Сопроцессоры 80287/80387 в реальном режиме работы имеют такой
же формат регистра указателя команд, однако этот указатель показывает
на первый префикс команды, вызвавшей особый случай.
<P>
Защищенный режим работы центрального процессора и сопроцессора
выходит за рамки данной книги, однако для полноты изложения приведем
формат указателей и для этого режима. В защищенном режиме адрес
состоит из селектора (в какой-то степени соответствует сегментной
компоненте адреса реального режима) и смещения. Формат указателя
команды для защищенного режима представлен на следующем рисунке:
<PRE>
<FONT COLOR=#000080>---------------------------------------------------¬
¦                  Смещение команды                ¦
+--------------------------------------------------+
¦                  Селектор команды                ¦
L---------------------------------------------------

</FONT>
</PRE>
<P>
Код операции здесь отсутствует, но его легко получить, пользуясь
адресом команды.
<P>
Если при возникновении особого случая использовался операнд, находящийся
в оперативной памяти, его адрес записывается в регистр указателя
операнда. Приведем форматы этого регистра для реального и защищенного
режимов работы.
<P>
Формат указателя операнда для реального режима:
<PRE>
<FONT COLOR=#000080>---------------------------------------------------¬
¦     Адрес операнда (0...15)                      ¦
+-------------------------------T------------------+
¦     Адрес операнда (16...19)  ¦XXXXXXXXXXXXXXXXXX¦
L-------------------------------+-------------------

</FONT>
</PRE>
<P>
Формат указателя операнда для защищенного режима:<BR>
<PRE>
<FONT COLOR=#000080>---------------------------------------------------¬
¦                  Смещение операнда               ¦
+--------------------------------------------------+
¦                  Селектор операнда               ¦
L---------------------------------------------------

</FONT>
</PRE>
<H2><A NAME="ch12_4">12.4. Система команд сопроцессора</A></H2>
<P>
Возможны три формата команд сопроцессора, аналогичные форматам
команд центральных процессоров 8086/80286/80386. Это команды с
обращением к оперативной памяти, команды с обращением к одному
из численных регистров и команды без операндов, заданных явным
образом.
<P>
Команды с обращением к памяти могут занимать от двух до четырех
байтов, в зависимости от способа адресации операнда, находящегося
в памяти:
<PRE>
<FONT COLOR=#000080>¦1 байт    ¦1 байт      ¦1 байт     ¦1 байт     ¦
+-----T----+---T----T---+-----------+-----------+
¦11011¦КОП1¦MOD¦КОП2¦R/M¦ Смещение1 ¦ Смещение2 ¦
L-----+----+---+----+---+-----------+------------


</FONT>
</PRE>
<P>
Первые пять битов соответствуют команде центрального процессора
ESC. Поля КОП1 и КОП2 определяют выполняемую команду, т.е. содержат
код операции. Поля MOD и R/M вместе с полями &quot;Смещение1&quot;
и &quot;Смещение2&quot; задают адрес операнда в памяти аналогично
тому, как это происходит в процессорах 8086/80286/80386. Однако
есть и отличия, связанные с возможностью адресации численных регистров
сопроцессора.
<P>
Приведем таблицу, показывающую зависимость способа адресации от
содержимого полей MOD и R/M:
<PRE>
<FONT COLOR=#000080>-----T----------------------------------------------¬
¦Поле¦                       Поле MOD               ¦
¦R/M +---------T---------------T----------------T---+
¦    ¦    00   ¦       01      ¦    10          ¦11 ¦
+----+---------+---------------+----------------+---+
¦000 ¦(bx)+(si)¦(bx)+(si)+disp8¦(bx)+(si)+disp16¦ST0¦
¦001 ¦(bx)+(di)¦(bx)+(di)+disp8¦(bx)+(di)+disp16¦ST1¦
¦010 ¦(bp)+(si)¦(bp)+(si)+disp8¦(bp)+(si)+disp16¦ST2¦
¦011 ¦(bp)+(di)¦(bp)+(di)+disp8¦(bp)+(di)+disp16¦ST3¦
¦100 ¦   (si)  ¦   (si)+disp8  ¦   (si)+disp16  ¦ST4¦
¦101 ¦   (di)  ¦   (di)+disp8  ¦   (di)+disp16  ¦ST5¦
¦110 ¦  disp16 ¦   (bp)+disp8  ¦   (bp)+disp16  ¦ST6¦
¦111 ¦   (bx)  ¦   (bx)+disp8  ¦   (bx)+disp16  ¦ST7¦
L----+---------+---------------+----------------+----

</FONT>
</PRE>
<P>
Если в таблице указаны значения смещения disp8 или disp16, это
означает, что в команде присуствует один или два байта смещения,
соответственно.
<P>
Если поле MOD содержит значение 11, возможна адресация численных
регистров ST0...ST1. При этом команда не содержит байтов смещения.
<P>
Формат команды с обращением к численному регистру приведен на
следующем рисунке:
<PRE>
<FONT COLOR=#000080>¦1 байт    ¦1 байт      ¦
+-----T----+---T----T---+
¦11011¦КОП1¦11 ¦КОП2¦STi¦
L-----+----+---+----+----

</FONT>
</PRE>
<P>
Видно, что это есть частный случай предыдущей команды, в которой
поле MOD содержит значение 11 и отсутствуют байты смещения.
<P>
Самый простой формат имеют команды без явного обращения к операндам:
<PRE>
<FONT COLOR=#000080>¦1 байт    ¦1 байт      ¦
+-----T----+---T--------+
¦11011¦КОП1¦11 ¦   КОП2 ¦
L-----+----+---+---------

</FONT>
</PRE>
<P>
Разумеется, если вы пишете программу для сопроцессора на языке
ассемблера, вы можете использовать мнемоническое обозначение команд.
Все мнемоники команд сопроцесора начинаются с буквы F, поэтому
их легко отличить от команд процессоров 8086/80286/80386/80486.
<P>
Все команды сопроцессора можно разделить на несколько групп:
<UL>
<LI>команды пересылки данных;
<LI>арифметические команды;
<LI>команды сравнений чисел;
<LI>трансцендентные команды;
<LI>управляющие команды.
</UL>
<P>
Команды пересылки данных предназначены для загрузки чисел из оперативной
памяти в численные регитры, записи данных из численных регистров
в операивную память, копирования данных из одного численного регистра
в другой.
<P>
Арифметические команды выполняют такие операции, как сложение,
вычитание, умножение, деление, извлечение квадратного корня, нахождение
частичного остатка, округление и т.п.
<P>
Команды сравнения сравнивают вещественные и целые числа, выполняют
анализ чисел.
<P>
Трансцендентные команды предназначены для вычисления различных
тригонометрических, логорифмических, показательных и гиперболических
функций - sin(), cos(), tg() и т.п.
<P>
Последняя группа команд - управляющие команды - обеспечивают установку
режима работы арифметического сопроцессора, его сброс и инициализацию,
перевод сопроцессора в защищенный режим работы и т.д.
<P>
Следующие разделы будут посвящены детальному описанию различных
групп команд сопроцессора.
<H3>12.4.1. Команды пересылки данных</H3>
<H4>Запись в стек</H4>
<PRE>
<FONT COLOR=#000080>FLD     ST(0) &lt;- память, вещественный формат
FILD    ST(0) &lt;- память, целый формат
FBLD    ST(0) &lt;- память, десятичный формат

</FONT>
</PRE>
<P>
Команды FLD, FILD, FBLD загружают в вершину стека вещественное,
целое и десятичное числа, соответственно.
<P>
При выполнении этих команд операнд считывается из оперативной
памяти, преобразуется в формат с расширенной точностью. Затем
поле ST регистра состояния уменьшается на единицу и выполняется
запись операнда в численный регистр, определяемый новым значением
поля ST. Т.е. операнд записывается в стек численных регистров,
а указатель стека - поле ST - уменьшается на единицу. По своему
действию эти команды напоминают команду PUSH центрального процессора.
<P>
Непосредственно перед загрузкой численного регистра проверяется
содержимое поля TAG0. Если это содержимое не равно 11 (пустой
регистр), в регистре состояния устанавливается флаг IE (недействительная
операция) и вырабатывается прерывание (если в регистре управления
не установлена маска IM - маска недействительной операции).
<H4>Извлечение из стека</H4>
<PRE>
<FONT COLOR=#000080>FSTP    память -&gt; ST(0), вещественный формат
FISTP   память -&gt; ST(0), целый формат
FBSTP   память -&gt; ST(0), десятичный формат

</FONT>
</PRE>
<P>
Команды извлечения чисел из стека выполняют действие, обратное
только что описанному. Содержимое численного регистра, номер которого
определяется полем ST регистра состояния, преобразуется в необходимый
формат и записывается в ячейки оперативной памяти, заданные операндом
команды.
<P>
После записи содержимое поля ST увеличивается на единицу. Эти
действия аналогичны выполняемым командой POP центрального процессора.
<P>
В зависимости от команды (FSTP, FISTP или FBSTP) производится
преобразование формата (из расширенного в вещественный, целый
или десятичный, соответственно). В процессе преобразования для
команд FSTP и FISTP выполняется округление в соответствии с содержимым
поля RC регистра управления. Для команды FBSTP округление всегда
выполняется следующим образом - прибавляется число 0.5, затем
дробная часть результата отбрасывается.
<H4>Копирование данных</H4>
<PRE>
<FONT COLOR=#000080>FST     память -&gt; ST(0), вещественный формат
FIST    память -&gt; ST(0), целый формат
FBST    память -&gt; ST(0), десятичный формат
        (только 80387, 80486)

</FONT>
</PRE>
<P>
Эти команды пересылают данные из верхушки стека в область памяти,
указанную операндом команды. При этом содержимое указателя стека
(поля ST) не изменяется.
<P>
Команда FST в качестве операнда может использовать ссылку на численный
регистр ST(i), поэтому вы можете использовать эту команду для
копирования верхушки стека в любой другой численный регистр.
<P>
При записи данных в оперативную память выполняется преобразование
формата (в вещественный для FST, в целый для FIST и в десятичный
для FBST.
<P>
Для сопроцессора 80286 вместо отсутствующей команды FBST можно
выполнить следующие две команды, которые приведут к такому же
результату:
<PRE>
<FONT COLOR=#000080>FLD          ST(0)
FBSTP   dec_number

</FONT>
</PRE>
<H4>Обмен</H4>
<PRE>
<FONT COLOR=#000080>FXCH    ST(i) -&gt; ST(0), ST(0) -&gt; ST(i)

</FONT>
</PRE>
<P>
Команда выполняет обмен содержимым верхушки стека ST(0) и численного
регистра, указанного в качестве операнда команды.
<H4>Загрузка констант</H4>
<PRE>
<FONT COLOR=#000080>FLDZ    0 -&gt; ST(0) - Загрузить нуль
FLD1    1 -&gt; ST(0) - Загрузить единицу
FLDPI   &quot;Пи&quot; -&gt; ST(0) - Загрузить число &quot;пи&quot;.
FLDLG2  log102 -&gt; ST(0) - Загрузить log102 
FLDLN2  loge2 -&gt; ST(0) - Загрузить loge2 
FLDL2T  loge10 -&gt; ST(0) - Загрузить loge10 
FLDL2E  log2e -&gt; ST(0) - Загрузить log2e 

</FONT>
</PRE>
<P>
Гораздо быстрее загружать константы с помощью специальных команд,
чем использовать команды загрузки данных из оперативной памяти.
<H3>12.4.2. Арифметические команды</H3>
<P>
Сопроцессор использует шесть основных типов арифметических команд:
<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=130>Fxxx</TD><TD WIDTH=327>Первый операнд берется из верхушки стека (источник), второй - следующий элемент стека. Результат выполнения команды записывается в стек.
</TD></TR>
<TR><TD WIDTH=130>Fxxx память</TD><TD WIDTH=327>Источник берется из памяти, приемником является верхушка стека ST(0). Указатель стека ST не изменяется, команда действительна только для операндов с одинарной и двойной точностью.
</TD></TR>
<TR><TD WIDTH=130>Fixxx память</TD><TD WIDTH=327>Аналогично предыдущему типу команды, но операндами могут быть 16- или32-битовые целые числа.
</TD></TR>
<TR><TD WIDTH=130>Fxxx ST, ST(i)</TD><TD WIDTH=327>Для этого типа регистр ST(i) является источником, а ST(0) - верхушка стека - приемником. Указатель стека не изменяется.
</TD></TR>
<TR><TD WIDTH=130>Fxxx ST(i), ST</TD><TD WIDTH=327>Для этого типа регитр ST(0) является источником, а ST(i) - приемником. Указатель стека не изменяется.
</TD></TR>
<TR><TD WIDTH=130>FxxxP ST(i), ST</TD><TD WIDTH=327>Регистр ST(i) - приемник, регистр ST(0) - источник. После выполнения команды источник ST(0) извлекается из стека.
</TD></TR>
</TABLE>
<P>
Строка &quot;xxx&quot; может принимать следующие значения:
<PRE>
<FONT COLOR=#000080>ADD     Сложение

SUB     Вычитание

SUBR    Обратное вычитание, уменьшаемое и вычитаемое
        меняются местами

MUL     Умножение

DIV     Деление

DIVR    Обратное деление, делимое и делитель меняются
        местами

</FONT>
</PRE>
<P>
Кроме основных арифметических команд имеются дополнительные арифметические
команды:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=132>FSQRT</TD><TD WIDTH=324>Извлечение квадратного корня
</TD></TR>
<TR><TD WIDTH=132>FSCALE</TD><TD WIDTH=324>Масштабирование на степень числа 2
</TD></TR>
<TR><TD WIDTH=132>FPREM</TD><TD WIDTH=324>Вычисление частичного остатка
</TD></TR>
<TR><TD WIDTH=132>FRNDINT</TD><TD WIDTH=324>Округление до целого
</TD></TR>
<TR><TD WIDTH=132>FXTRACT</TD><TD WIDTH=324>Выделение порядка числа и мантиссы
</TD></TR>
<TR><TD WIDTH=132>FABS</TD><TD WIDTH=324>Вычисление абсолютной величины числа
</TD></TR>
<TR><TD WIDTH=132>FCHS</TD><TD WIDTH=324>Изменение знака числа
</TD></TR>
</TABLE>
<P>
По команде FSQRT вычисленное значение квадратного корня записывается
в верхушку стека ST(0).
<P>
Команда FSCALE изменяет порядок числа, находящегося в ST(0). По
этой команде значение порядка числа ST(0) складывается с масштабным
коэффициентом, который должен быть предварительно записан в ST(1).
Действие этой команды можно представить следующей формулой:
<PRE>
<FONT COLOR=#000080>ST(0) = ST(0) * 2n, где -215 &lt;= n &lt;= +215

</FONT>
</PRE>
<P>
В этой формуле n - это ST(1).
<P>
Команда FPREM вычисляет остаток от деления делимого ST(0) на делитель
ST(1). Знак результата равен знаку ST(0), а сам результат получается
в вершине стека ST(0).
<P>
Действие команды заключается в сдвигах и вычитания, аналогично
&quot;ручному&quot; делению &quot;в столбик&quot;. После выполнения
команды флаг C2 регистра состояния может принимать следующие значения:
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=54>0&nbsp;</TD><TD WIDTH=402>&nbsp;остаток от деления, полученный в ST(0), меньше делителя ST(1), команда завершилась полностью;
</TD></TR>
<TR><TD WIDTH=54>1&nbsp;</TD><TD WIDTH=402>ST(0) содержит частичный остаток, программа должна еще раз выполнить команду для получения точного значения остатка.
</TD></TR>
</TABLE>
<P>
Команда RNDINT округляет ST(0) в соответствии с содержимым поля
RC управляющего регистра.
<P>
Команда FABS вычисляет абсолютное значение ST(0). Аналогично,
команда FCHS изменяет знак ST(0) на противоположный.
<H3>12.4.3. Команды сравнений чисел</H3>
<P>
В процессорах 8086/80286/80386 команды условных переходов выполняются
в соответствии с установкой отдельных битов регистра флагов процессора.
В арифметическом сопроцессоре существуют специальные команды сравнений,
по результатам выполнения которых устанавливаются биты кодов условий
в регистре состояния:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=113>FCOM</TD><TD WIDTH=344>Сравнение</TD></TR>
<TR><TD WIDTH=113>FICOM</TD><TD WIDTH=344>Целочисленное сравнение
</TD></TR>
<TR><TD WIDTH=113>FCOMP</TD><TD WIDTH=344>Сравнение и извлечение из стека
</TD></TR>
<TR><TD WIDTH=113>FICOMP</TD><TD WIDTH=344>Целочисленное сравнение и извлечение из стека
</TD></TR>
<TR><TD WIDTH=113>FCOMPP</TD><TD WIDTH=344>Сравнение и двойное извлечение из стека
</TD></TR>
<TR><TD WIDTH=113>FTST</TD><TD WIDTH=344>Сравнение операнда с нулем
</TD></TR>
<TR><TD WIDTH=113>FXAM</TD><TD WIDTH=344>Анализ операнда</TD>
</TR>
</TABLE>
<P>
Команда FCOM вычитает содержимое операнда, размещенного в оперативной
памяти, из верхушки стека ST(0). Результат вычитания никуда не
записывается и указатель верхушки стека ST не изменяется.
<P>
Обозначим операнд команды сравнения как &quot;x&quot;. В следующей
таблице приведем значения битов кодов условия после выполнения
команды &quot;FCOM&nbsp;x&quot;:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=152>C3</TD><TD WIDTH=152>C0</TD><TD WIDTH=152>Условие
</TD></TR>
<TR><TD WIDTH=152>0</TD><TD WIDTH=152>0</TD><TD WIDTH=152>ST(0) &gt; x
</TD></TR>
<TR><TD WIDTH=152>0</TD><TD WIDTH=152>1</TD><TD WIDTH=152>ST(0) &lt; x
</TD></TR>
<TR><TD WIDTH=152>1</TD><TD WIDTH=152>0</TD><TD WIDTH=152>ST(0) = x
</TD></TR>
<TR><TD WIDTH=152>1</TD><TD WIDTH=152>1</TD><TD WIDTH=152>ST(0) и x не сравнимы.
</TD></TR>
</TABLE>
<P>
Последняя комбинация возникает при попытке сравнения нечисел,
неопределенностей или бесконечностей, а также в некоторых других
случаях.
<P>
Команда FICOM работает с 16- или 32-битовыми числами, в остальном
она аналогична команде FCOM.
<P>
Команды FCOMP и FICOMP аналогичны, соответственно, командам FCOM
и FICOM, за исключением того, что после выполнения операнд извлекается
из стека.
<P>
Команда FCOMPP выполняет те же действия, что и FCOM, но она после
выполнения извлекает из стека оба операнда, участвовавших в сравнении.
<P>
Для сравнения операнда с нулем предназначена команда FTST. После
ее выполнения коды условий устанавливаются в соответствии со следующей
таблицей:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=152>C3</TD><TD WIDTH=152>C0</TD><TD WIDTH=152>Условие
</TD></TR>
<TR><TD WIDTH=152>0</TD><TD WIDTH=152>0</TD><TD WIDTH=152>ST(0) &gt; 0
</TD></TR>
<TR><TD WIDTH=152>0</TD><TD WIDTH=152>1</TD><TD WIDTH=152>ST(0) &lt; 0
</TD></TR>
<TR><TD WIDTH=152>1</TD><TD WIDTH=152>0</TD><TD WIDTH=152>ST(0) = 0
</TD></TR>
<TR><TD WIDTH=152>1</TD><TD WIDTH=152>1</TD><TD WIDTH=152>ST(0) и 0 не сравнимы.
</TD></TR>
</TABLE>
<P>
Команда FXAM анализирует содержимое ST(0). После ее выполнения
устанавливаются коды условий, по которым можно судить о знаке
числа, о его конечности или бесконечности, нормализованности и
т.д.
<P>
Бит C1 содержит знак анализируемого числа:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=83>C1</TD><TD WIDTH=374>Знак числа</TD></TR>
<TR><TD WIDTH=83>0</TD><TD WIDTH=374>положительное число;</TD>
</TR>
<TR><TD WIDTH=83>1</TD><TD WIDTH=374>отрицательное число.</TD>
</TR>
</TABLE>
<P>
С помощью бита C0 можно определить, является число конечным или
бесконечным:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=83>C0</TD><TD WIDTH=374>Конечность/бесконечность числа
</TD></TR>
<TR><TD WIDTH=83>0</TD><TD WIDTH=374>конечное число;</TD></TR>
<TR><TD WIDTH=83>1</TD><TD WIDTH=374>бесконечное число.</TD></TR>
</TABLE>
<P>
Для конечных чисел дальнейшая классификация может проводиться
по содержимому кодов условий C2 и C3:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=83>C3</TD><TD WIDTH=76>C2</TD><TD WIDTH=298>Описание числа
</TD></TR>
<TR><TD WIDTH=83>0</TD><TD WIDTH=76>0</TD><TD WIDTH=298>Ненормализованное число
</TD></TR>
<TR><TD WIDTH=83>0</TD><TD WIDTH=76>1</TD><TD WIDTH=298>Нормализованное число
</TD></TR>
<TR><TD WIDTH=83>1</TD><TD WIDTH=76>0</TD><TD WIDTH=298>Нулевое число
</TD></TR>
<TR><TD WIDTH=83>1</TD><TD WIDTH=76>1</TD><TD WIDTH=298>Число денормализовано
</TD></TR>
</TABLE>
<P>
Аналогично, для бесконечных чисел коды условий C2 и C3 имеют следующее
значение:<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=83>C3</TD><TD WIDTH=76>C2</TD><TD WIDTH=298>Описание числа
</TD></TR>
<TR><TD WIDTH=83>0</TD><TD WIDTH=76>0</TD><TD WIDTH=298>Нечисло
</TD></TR>
<TR><TD WIDTH=83>0</TD><TD WIDTH=76>1</TD><TD WIDTH=298>Бесконечное число
</TD></TR>
<TR><TD WIDTH=83>1</TD><TD WIDTH=76>0</TD><TD WIDTH=298>Пустое число
</TD></TR>
<TR><TD WIDTH=83>1</TD><TD WIDTH=76>1</TD><TD WIDTH=298>Пустое число
</TD></TR>
</TABLE>
<P>
С помощью команды &quot;FSTSW AX&quot; программа может переписать
содержимое регистра состояния сопроцессора в регистр AX центрального
процессора. Далее содержимое регистра AH можно переписать в регистр
флагов центрального процессора при помощи команды SAHF. Биты кодов
условий сопроцессора отображаются на регистр флагов центрального
процессора таким образом, что для анализа кодов условий можно
использовать команды условных переходов:<BR>
<PRE>
<FONT COLOR=#000080>---T-T-T-T-T-T-T--¬
¦B ¦C3¦  ¦ST¦  ¦C2¦C1¦C0¦
L--+--+--+--+--+--+--+---

---T-T-T-T-T-T-T--¬
¦SF¦ZF¦  ¦AF¦  ¦PF¦  ¦CF¦
L--+--+--+--+--+--+--+---


</FONT>
</PRE>
<P>
Например, в следующем фрагменте программы выполняется переход
к метке error, если операнды несравнимы:
<PRE>
<FONT COLOR=#000080>fcom
fstsw   ax
sahf
je              error

</FONT>
</PRE>
<H3>12.4.4. Трансцендентные команды</H3>
<P>
Трансцендентные команды предназначены для вычисления таких функций,
как тригонометрические (sin, cos, tg,...), обратные тригонометрические
(arcsin, arccos,...), показательные (xy, 2x, 10x, ex), гиперболические
(sh, ch, th,...), обратные гиперболические (arsh, arch, arcth,...).
<P>
В следующей таблице приведены все трансцендентные команды сопроцессора:
<BR>
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=111>FPTAN</TD><TD WIDTH=340>Вычисление частичного тангенса
</TD></TR>
<TR><TD WIDTH=111>FPATAN</TD><TD WIDTH=340>Вычисление частичного арктангенса
</TD></TR>
<TR><TD WIDTH=111>FYL2X</TD><TD WIDTH=340>Вычисление y*log2(x)
</TD></TR>
<TR><TD WIDTH=111>FYL2XP1</TD><TD WIDTH=340>Вычисление y*log2(x+1)
</TD></TR>
<TR><TD WIDTH=111>F2XM1 </TD><TD WIDTH=340>Вычисление 2x-1</TD>
</TR>
<TR><TD WIDTH=111>FCOS</TD><TD WIDTH=340>Вычисление cos(x) (только 80387/80486)
</TD></TR>
<TR><TD WIDTH=111>FSIN</TD><TD WIDTH=340>Вычисление sin(x) (только 80387/80486)
</TD></TR>
<TR><TD WIDTH=111>FSINCOS</TD><TD WIDTH=340>Вычисление sin(x) и cos(x) одновременно (только 80387/80486)
</TD></TR>
</TABLE>
<P>
Команда FPTAN вычисляет частичный тангенс ST(0), размещая в стеке
такие два числа x и y, что y/x = tg(ST(0)).
<P>
После выполнения команды число y располагается в ST(0), а число
x включается в стек сверху (т.е. записывается в ST(1)). Аргумент
команды FPTAN должен находится в пределах:
<P>
0 &lt;= ST(0) &lt;= pi/4
<P>
Пользуясь полученным значением частичного тангенса, можно вычислить
другие тригонометрические функции по следующим формулам:
<PRE>
<FONT COLOR=#000080>sin(z) = 2*(y/x) / (1 + (y/x)2)
cos(z) = (1 - (y/x)2) / (1 + (y/x)2)
tg(z/2) = y/x;
ctg(z/2) = x/y;
cosec(z) =  (1 + (y/x)2) / 2*(y/x)
sec(z) = (1 + (y/x)2) / (1 - (y/x)2)

</FONT>
</PRE>
<P>
В этой таблице z - значение, находившееся в ST(0) до выполнения
команды FPTAN, x и y - значения в регистрах ST(0) и ST(1), соответственно.
<PRE>
<FONT COLOR=#000080>Команда FPATAN вычисляет частичный арктангенс z=arctg(ST(0)/ST(1))=arctg(x/y).

</FONT>
</PRE>
<P>
Перед выполнением команды числа x и y располагаются в ST(0) и
ST(1), сответственно. Аргументы команды FPATAN должен находится
в пределах:
<PRE>
<FONT COLOR=#000080>0 &lt; y &lt; x

</FONT>
</PRE>
<P>
Результат записывается в ST(0).
<P>
Команда FYL2X вычисляет выражение y*log2(x), операнды x и y размещаются,
соответственно, в ST(0) и ST(1). Операнды извлекаются из стека,
а результат записывается в стек. параметр x должен быть положительным
числом.
<P>
Пользуясь результатом выполнения этой команды, можно вычислить
следующим образом логарифмические функции:
<PRE>
<FONT COLOR=#000080>log2(x) = FYL2(x)
loge(x) = loge(2) * log2(x) = FYL2X(loge(2), x) =
                = FYL2X(FLDLN2, x)
log2(x) = log10(2) * log2(x) = FYL2X (log10(2), x) =
                = FYL2X(FLDLG2, x)

</FONT>
</PRE>
<P>
Функция FYL2XP1 вычисляет выражение y*log2(x+1), где x соответствует
ST(0), а y - ST(1). Результат записывается в ST(0), оба операнда
выталкиваются из стека и теряются.
<P>
На операнд x накладывается ограничение:
<PRE>
<FONT COLOR=#000080>0 &lt; x &lt; 1 - 1/sqrt(2)

</FONT>
</PRE>
<P>
Команда F2XM1 вычисляет выражение 2x-1, где x - ST(0). Результат
записывается в ST(0), параметр должен находится в следующих пределах:
<PRE>
<FONT COLOR=#000080>0 &lt;= x &lt;= 0,5

</FONT>
</PRE>
<P>
Команда FCOS вычисляет cos(x) (только для 80387/80486). Параметр
x должен находится в ST(0), туда же записывается результат выполнения
команды.
<P>
Команда FSIN аналогична команде FCOS, но вычисляет значение косинуса
ST(0).
<P>
Команда FSINCOS вычисляет одновременно значения синуса и косинуса
параметра ST(0). Значение синуса записывается в ST(1), косинуса
- в ST(0).
<P>
На этом мы закончим описание трансцендентных команд сопроцессора
и перейдем к управляющим командам.
<H3>12.4.5. Управляющие команды</H3>
<P>
Управляющие команды предназначены для работы с нечисловыми регистрами
сопроцессора. Некоторые команды имеют альтернативные варианты.
Мнемоники этих команд могут начинаться с FN или с F. Первый вариант
соответствует командам &quot;без ожидания&quot;. Для команд &quot;без
ожидания&quot; процессор не проверяет, занят ли сопроцессор выполнением
команды, т.е. бит занятости B не проверяется. Численные особые
случаи также игнорируются.
<P>
Варианты команд &quot;с ожиданием&quot; действуют также, как и
обычные команды сопроцессора.
<P>
Приведем таблицу управляющих команд сопроцессора:
<PRE>
<FONT COLOR=#000080>FNSTCW (FSTCW)          Записать управляющее слово
FLDCW                   Загрузить управляющее слово
FNSTSW (FSTSW)          Записать слово состояния
FNSTSW AX (FSTSW AX)    Записать слово состояния в AX,
                        не поддерживается сопроцессором 8087
FNCLEX (FCLEX)          Сбросить особые случаи
FNINIT (FINIT)          Инициализировать сопроцессор
FNSTENV (FSTENV)        Записать среду
FLDENV                  Загрузить среду
FNSAVE (FSAVE)          Записать полное состояние
FRSTOR                  Восстановить полное состояние
FINCSTP                 Увеличить указатель стека на 1
FDECSTP                 Уменьшить указатель стека на 1
FFREE                   Освободить регистр
FNOP                    Холостая команда, нет операции
FSETPM                  Установить защищенный режим работы

</FONT>
</PRE>
<P>
Команда FNSTCW записывает содержимое управляющего регистра в оперативную
память.
<P>
Команда FLDCW загружает управляющий регистр данными из оперативной
памяти и обычно используется для изменения режима работы сопроцессора.
<P>
Команда FNSTSW записывает содержимое регистра состояния в оперативную
память. Команда FNSTSW AX записывает содержимое этого регистра
в регистр AX центрального процессора для его последующего анализа
командами условных переходов.
<P>
Сопроцессор 8087 не имеет варианта команды FSTSW AX, поэтому приходится
вначале записывать регистр состояния в память, а затем в регистр
флагов процессора 8086.
<P>
Команда FNCLEX сбрасывает флаги особых случаев в регистре состояния
сопроцессора. Кроме того, сбрасываются биты ES и B.
<P>
Команда FNINIT инициализирует регистр состояния, управляющий регистр
и регистр тегов в соответствии со следующей таблицей:
<PRE>
<FONT COLOR=#000080>Регистр         Устанавливаемый режим работы


Управляющий     Проективная бесконечность,
                        округление к ближайшему,
                        расширенная точность,
                        все особые случаи замаскированы.

Состояния       B=0 (бит занятости сброшен),
                        код условия не определен,
                        ST=ES=0,
                        флаги особых случаев установлены в нуль.

Тегов           Все поля регистра тегов содержат значение
                        11 (пустой регистр).

</FONT>
</PRE>
<P>
Команда FNSTENV записывает в память содержимое всех регистров,
кроме численных, в следующем формате:<BR>
<PRE>
<FONT COLOR=#000080>------------------------¬
¦  Управляющий регистр  ¦
+-----------------------+
¦   Регистр состояния   ¦
+-----------------------+
¦      Регистр тегов    ¦
+-----------------------+
¦                       ¦
+-  Указатель команды  -+
¦                       ¦
+-----------------------+
¦                       ¦
+- Указатель операнда  -+
¦                       ¦
L------------------------

</FONT>
</PRE>
<P>
Команда FLDENV предназначена для загрузки регистров, сохраненных
ранее командой FNSTENV. Обе эти команды полезны в программах обработки
особых случаев.
<P>
Команды FNSAVE и FRSTOR действуют аналогично командам FNSTENV
и FLDENV, но они дополнительно сохраняют и восстанавливают содержимое
численных регистров. Формат области сохранения регистров, занимающей
94 байта, приведен на следующем рисунке:
<PRE>
<FONT COLOR=#000080>------------------------¬
¦  Управляющий регистр  ¦
+-----------------------+
¦   Регистр состояния   ¦
+-----------------------+
¦      Регистр тегов    ¦
+-----------------------+
¦                       ¦
+-  Указатель команды  -+
¦                       ¦
+-----------------------+
¦                       ¦
+- Указатель операнда  -+
¦                       ¦
+-----------------------+-------------------------------¬
¦                          ST(0)                        ¦
+-------------------------------------------------------+
¦                          ST(1)                        ¦
+-------------------------------------------------------+
¦                          ST(2)                        ¦
+-------------------------------------------------------+
¦                          ST(3)                        ¦
+-------------------------------------------------------+
¦                          ST(4)                        ¦
+-------------------------------------------------------+
¦                          ST(5)                        ¦
+-------------------------------------------------------+
¦                          ST(6)                        ¦
+-------------------------------------------------------+
¦                          ST(7)                        ¦
L--------------------------------------------------------


</FONT>
</PRE>
<P>
Команды FINCSTP и FDECSTP, соответственно, увеличивают и уменьшают
на 1 указатель стека SP.
<P>
Команда FFREE ST(i) помечает численный регистр ST(i) как пустой,
записывая в соответствующее поле регистра тегов значение 11.
<P>
Команда FNOP не производит никаких действий.
<P>
Команда FSETPM переводит сопроцессор в защищенный режим работы.
Подробное рассмотрение защищенного режима работы выходит за рамки
данной книги.
<H2><A NAME="ch12_5">12.5. Программирование сопроцессора</A></H2>
<P>
Используя языки высокого уровня, такие как Си или Паскаль, вы
можете даже и не знать, что созданная вами программа использует
для вычислений арифметический сопроцессор. При установке системы
программирования QuickC или C 6.0 вам предоставляется возможность
выброа одного из трех вариантов стандартной библиотеки:
<UL>
<LI>библиотека эмулятора;
<LI>библиотека, рассчитанная на наличие сопроцессора;
<LI>библиотека альтернативной математики.
</UL>
<P>
Первый вариант (библиотека эмулятора) используется по умолчанию.
Программы, которые создаются с использованием эмулятора, будут
работать как при наличии в системе сопроцессора, так и при его
отсуствии. В последнем случае вычисления с плавающей точкой выполняются
специальными подпрограмами, которые присоединяются к вашей программе
на этапе редактирования. Ваша программа сама определит факт наличия
(или отсуствия) сопроцессора и выберет соответствующий способ
выполнения вычислений - либо с использованием сопроцесора, либо
с использованием подпрограмм эмуляции сопроцессора.
<P>
Все что вам нужно для работы с библиотекой эмуляции - это просто
выбрать ее при установке системы программирования. Это самый простой
способ программирования сопроцессора, когда вам, вообще говоря,
совсем не надо его программировать - всю работу по использоанию
сопроцессора выполнят модули библиотеки эмуляции.
<P>
Второй вариант библиотеки рассчитан на наличие сопроцессора. Если
сопроцессора нет, программа работать не будет. Но если известно,
что сопроцессор есть (например, процессор 80486 всегда содержит
блок арифметики), то вам имеет смысл использовать именно этот
вариант как самый быстродействующий.
<P>
Третий вариант не использует сопроцессор совсем. Все вычисления
выполняются специальными подпрограммами, входящими в состав библиотеки
альтернативной математики и подключающимися к вашей программе
автоматически на этапе редактирования.
<P>
К сожалению, есть программы, в которых использование библиотеки
эмуляции невозможно или крайне затруднительно:
<UL>
<LI>резидентные программы;
<LI>драйверы;
<LI>программы, предъявляющие жесткие требования к точности и скорости
вычислений.
</UL>
<P>
В случае с резидентными программами невозможность использования
библиотеки эмулятора вызвана тем, что после оставления программы
резидентной в памяти, например, функцией _dos_keep(), она теряет
доступ к модулям эмуляции. Механизм вызова программ эмуляции основан
на использовании прерываний с номерами 34h...3Eh. Перед тем как
оставить программу резидентной, функция _dos_keep() восстанавливает
содержимое этих векторов, делая невозможным доступ резидентной
программе к модулям эмулятора. Да и самих этих модулей уже нет
в памяти - на их место может быть загружена новая программа.
<P>
Поэтому руководство по Си рекомендует для резидентных программ
использовать библиотеку альтернативной математики. Но эта библиотека,
увы, не использует сопроцессор.
<P>
Ситуация с драйверами аналогична - драйверы, как правило, составляются
на языке ассемблера, поэтому средства эмуляции библиотек Си недоступны.
<P>
Выходом может быть непосредственное программирование сопроцессора
на языке ассемблера. При этом вы можете полностью использовать
все возможности сопроцессора и добиться от программы наибольшей
эффективности вычислений.
<P>
Какие средства можно использовать для составления программ для
сопроцессора?
<P>
Обычно это или ассемблер MASM (возможно использование TASM), либо
интегрированная среда разработки QuickC версии 2.01, содержащая
встроенный Quick Assembler.
<P>
Приведем пример самой простой программы, подготовленный для трансляции
программой Quick Assemler. Эта программа выполняет вычисления
по следующей несложной формуле:
<PRE>
<FONT COLOR=#000080>z = x + y;

</FONT>
</PRE>
<P>
Значения x и y задаются в виде констант:
<PRE>
<FONT COLOR=#000080>                  .MODEL  TINY

                  .STACK  100h

                  .DATA

; Здесь находятся константы с одинарной
; точностью x и y

x  dd 1.0
y  dd 2.0

; Резервируем четыре байта для результата

z  dd ?

                  .CODE
                  .STARTUP

; Записываем в стек численных регистров
; значение x

                  fld    x

; Складываем содержимое верхушки стека
; с константой y

                  fadd   y

; Записываем результат в ячейку z

                  fstp   z

; Завершаем работу программы и
; возвращаем управление операционной системе

                  .EXIT   0

                  END

</FONT>
</PRE>
<P>
Как убедиться в том, что программа работает правильно?
<P>
Для этого мы используем отладчик CodeView, содержащий очень удобные
средства отладки программ, работающих с арифметическим сопроцессором.
<P>
Запустим отладчик CodeView, передав ему в качестве параметра имя
приведенной выше программы:
<PRE>
<FONT COLOR=#000080>cv test87.com

</FONT>
</PRE>
<P>
После того, как отладчик запустится, откройте окно регистров сопроцессора,
нажав комбинацию клавиш Alt-V-7:
<P>
<IMG SRC="278/pic8.gif">
<P>
После этого на в нижней части экрана появится окно регистров сопроцессора:
<P>
<IMG SRC="278/pic9.gif">
<P>
Пусть вас не смущает то, что в этом окне пока не показывается
состояние регистров сопроцессора. Нажмите клавишу F8, выполнив
один шаг программы. Окно сопроцессора будет содержать следующую
информацию:
<P>
<IMG SRC="278/pic10.gif">
<P>
Теперь вы видите содержимое регистров управления и состояния (cControl,
cStatus), регистра тегов (cTag), регистров указателей команд и
данных (Instr Ptr, Data Ptr), код выполняемой команды (Opcode).
Отображается также содержимое стека численных регистров (Stack),
но пока это поле пустое, так как все численные регистры отмечены
в регистре тегов как пустые (код 11).
<P>
Нажмите еще раз клавишу F8, выполнив следующую команду программы.
Эта команда запишет в стек численных регистров значение переменной
x:
<P>
<IMG SRC="278/pic11.gif">
<P>
Теперь в области регистров стека показано содержимое регистра
cST(0), причем как в двоичном виде, так и с использованием экспоненциальной
(научной) нотации.
<P>
Как и следовало ожидать, регистр ST(0) содержит величину 1.0.
<P>
Выполним еще одну команду, прибавляющую к содержимому ST(0) значение
2.0 из переменной y. Теперь регистр ST(0) содержит величину 3.0:
<P>
<IMG SRC="278/pic12.gif">
<P>
Последняя команда выталкивает из стека хранящееся там значение
(3.0) и записывает его в переменную z. Теперь стек численных регистров
снова пуст:
<P>
<IMG SRC="278/pic13.gif">
<P>
Отладчик CodeView обладает мощными средствами динамического просмотра
состояния сопроцессора. Однако этот отладчик невозможно использовать
для отладки драйверов. Мы уже говорили вам о проблемах, возникающих
при отладке драйверов, в первом томе &quot;Библиотеки системного
программиста&quot;.
<P>
Там же нами была предложена методика отладки драйверов, основанная
на включении в исходный текст драйвера подпрограмм, выводящих
на экран содержимое регистров центрального процессора или областей
памяти. Мы привели исходный текст подпрограммы ntrace, которая
выводит на экран содержимое всех регистров центрального процессора.
<P>
Если ваш драйвер использует сопроцессор, вам, вероятно, потребуется
также содержимое регистров сопроцессора. Приведем текст подпрограммы
ntrace87, которая наряду с содержимым регистров центрального процессора,
выводит содержимое регистров арифметического сопроцессора:
<PRE>
<FONT COLOR=#000080>         include sysp.inc

        .MODEL tiny
        .CODE

        PUBLIC ntrace87


;==========================================
; Процедура выводит на экран содержимое
; всех регистров центрального процессора
; и сопроцессора. Затем она ожидает нажатия на
; любую клавишу.
; После возвращения из процедуры
; все регистры восстанавливаются, в том
; числе регистры сопроцессора.

ntrace87 proc near

; Сохраняем в стеке регистры,
; содержимое которых будет изменяться

     pushf
     push ax
     push bx
     push cx
     push dx
     push ds
     push bp

     mov bp,sp

          push cs
          pop ds

; Сохраняем полное состояние сопроцессора

          fsave  cs:regs_87

; Выводим сообщение об останове

          mov dx,offset cs:trace_msg
          @@out_str

; Выводим содержимое всех регистров

         mov ax,cs        ; cs
     call Print_word
        @@out_ch ':'
     mov ax,[bp]+14   ; ip
     call Print_word

        @@out_ch 13,10,13,10,'A','X','='
     mov ax,[bp]+10
     call Print_word

        @@out_ch ' ','B','X','='
     mov ax,[bp]+8
     call Print_word

        @@out_ch ' ','C','X','='
     mov ax,[bp]+6
     call Print_word

        @@out_ch ' ','D','X','='
     mov ax,[bp]+4
     call Print_word

        @@out_ch ' ','S','P','='
     mov ax,bp
        add ax,16
     call Print_word

        @@out_ch ' ','B','P','='
     mov ax,[bp]
     call Print_word

        @@out_ch ' ','S','I','='
     mov ax,si
     call Print_word

        @@out_ch ' ','D','I','='
     mov ax,di
     call Print_word

        @@out_ch 13,10,'D','S','='
     mov ax,[bp]+2
     call Print_word

        @@out_ch ' ','E','S','='
     mov ax,es
     call Print_word

        @@out_ch ' ','S','S','='
     mov ax,ss
     call Print_word

        @@out_ch ' ','F','='
     mov ax,[bp]+12
     call Print_word

; Выводим содержимое регистров сопроцессора

        lea dx,cs:r87_msg
        @@out_str

; Выводим содержимое управляющего регистра

        @@out_ch 'C','N','T','R','='

        mov ax, cs:regs_87.cr
        call Print_word

; Выводим содержимое регистра состояния

        @@out_ch ' ','S','T','A','T','E','='

        mov ax, cs:regs_87.sr
        call Print_word

; Выводим содержимое регситра тегов

        @@out_ch ' ','T','A','G','='

        mov ax, cs:regs_87.tg
        call Print_word

; Выводим содержимое указателя адреса

        @@out_ch ' ','C','M','D','A','D','R','='

        mov ax, cs:regs_87.cmdhi
        and  ah, 0f0h
        mov al, ah
        mov cl, 4
        ror al, cl
        call Print_byte
        mov ax, cs:regs_87.cmdlo
        call Print_word
        @@out_ch ' '

; Выводим содержимое указателя операнда

        @@out_ch ' ','O','P','R','A','D','R','='

        mov ax, cs:regs_87.oprhi
        and  ah, 0f0h
        mov al, ah
        mov cl, 4
        ror al, cl
        call Print_byte
        mov ax, cs:regs_87.oprlo
        call Print_word

; Выводим содержимое непустых численных регистров

        lea dx,cs:nr_msg
        @@out_str

        mov cx, 8              ; количество регистров - 8
        mov dx, 0              ; индекс текущего регистра
        mov bx, cs:regs_87.tg  ; содержимое регистра тегов

; Цикл по стеку численных регистров

nreg_loop:

; Проверяем поле регистра тегов, соответствующее
; текущему обрабатываемому численному регистру

          mov ax, bx
          and ax, 0c000h
          cmp ax, 0c000h

; Если это поле равно 11B, считаем, что данный
; численный регистр пуст, переходим к следующему

          je continue

; Выводим на экран содержимое численного регистра

          call Print_numreg

continue:

; Сдвигаем содержимое регистра тегов для
; обработки поля, соответствующего следующему
; регистру.

          rol bx, 1
          rol bx, 1
          inc dx       ; увеличиваем индекс текущего регистра

          loop nreg_loop

          lea dx,cs:hit_msg
          @@out_str

; Ожидаем нажатия на любую клавишу

        mov ax,0
     int 16h

; Восстанавливаем содержимое регистров

        frstor  cs:regs_87

     pop bp
     pop ds
     pop dx
     pop cx
     pop bx
     pop ax
     popf

     ret

trace_msg db 13,10,'&gt;---- BREAK ----&gt; At address ','$'
hit_msg db 13,10,'Hit any key...','$'
r87_msg db 13,10,13,10,'Coprocessor state:',13,10,'$'
nr_msg db 13,10,'Numeric Registers:',13,10,'$'

regs_87 db 94 dup(?)
ten db 10

ntrace87 endp

;==========================================
; Процедура выводит на экран содержимое
; численного регистра с номером, заданным
; в регистре al

Print_numreg proc near
          push cx
          push bx

; Выводим обозначение численного регистра

          push dx
          @@out_ch 'S','T','('
          pop dx
          mov al, dl
          call Print_byte
          push dx
          @@out_ch ')','='
          pop dx

; Выводим содержимое численного регистра в
; шестнадцатеричном формате

          mov cx, 10    ; счетчик байтов в числе с
                                                 ; расширенной точностью
          mov bp, 10    ; первоначальное смещение
                                                 ; к старшему байту числа

; Смещение к полю первого численного регистра
; в области сохранения

          mov bx, offset cs:regs_87.st0

; Вычисляем смещение старшего байта численного
; регистра, номер которого задан в регистре DX

          mov ax, dx
          imul cs:ten
          add bx, ax
          dec bx

; Выводим в цикле 10 байтов числа

pr_lp:
          push bx

          add bx, bp
          mov al, cs:[bx]
          call Print_byte
          pop bx

          dec bp
          loop pr_lp

          push dx
          @@out_ch 13,10
          pop dx

          pop bx
          pop cx
          ret

Print_numreg endp


;==========================================
; Процедура выводит на экран содержимое AL

Print_byte proc near

          push ax
          push bx
          push dx

          call Byte_to_hex
          mov bx,dx
          @@out_ch bh
          @@out_ch bl

          pop dx
          pop bx
          pop ax
          ret
Print_byte endp

;==========================================
; Процедура выводит на экран содержимое AX

Print_word proc near

        push ax
     push bx
     push dx

        push ax
        mov cl,8
        rol ax,cl
        call Byte_to_hex
        mov bx,dx
        @@out_ch bh
        @@out_ch bl

        pop ax
     call Byte_to_hex
     mov bx,dx
        @@out_ch bh
        @@out_ch bl

     pop dx
     pop bx
     pop ax
     ret
Print_word endp

Byte_to_hex proc near
;--------------------
; al - input byte
; dx - output hex
;--------------------
     push ds
     push cx
     push bx

     lea bx,tabl
     mov dx,cs
     mov ds,dx

     push ax
     and al,0fh
     xlat
     mov dl,al

     pop ax
     mov cl,4
     shr al,cl
     xlat
     mov dh,al

     pop bx
     pop cx
     pop ds
     ret

tabl db '0123456789ABCDEF'
Byte_to_hex endp

     end

</FONT>
</PRE>
<P>
Работа программы основана на использовании команды FSAVE, сохраняющей
в памяти содержимое всех регистров сопроцессора. Область сохранения
описывается следующей структурой, определенной в файле sysp.inc:
<PRE>
<FONT COLOR=#000080>State87 struc
        cr dw ?
        sr dw ?
        tg dw ?
        cmdlo dw ?
        cmdhi dw ?
        oprlo dw ?
        oprhi dw ?
        st0 dt ?
        st1 dt ?
        st2 dt ?
        st3 dt ?
        st4 dt ?
        st5 dt ?
        st6 dt ?
        st7 dt ?
State87 ends

</FONT>
</PRE>
<P>
Для демонстрации возможностей ntrace87 мы немного изменили нашу
первую программу, работающую с сопроцессором - после каждой комадны
сопроцессора вставили вызов ntrace87:
<PRE>
<FONT COLOR=#000080>                  .MODEL  tiny
                  DOSSEG

                  EXTRN ntrace87:NEAR

                  .STACK  100h

                  .DATA
x  dd 1.0
y  dd 2.0
; Резервируем четыре байта для результата

z  dd ?

                  .CODE
                  .STARTUP

                  push cs
                  pop  ds

; Записываем в стек численных регистров
; значение x
                  call ntrace87

                  fld    x
                  call ntrace87

; Складываем содержимое верхушки стека
; с константой y

                  fadd   y
                  call ntrace87

; Записываем результат в ячейку z

                  fstp   z
                  call ntrace87

; Завершаем работу программы и
; возвращаем управление операционной системе

quit:
                  .EXIT   0

                  END

</FONT>
</PRE>
<P>
В процессе работы этой программы на каждом шаге на экран выводится
дамп содержимого регистров центрального процессора и сопроцессора
(пустые численные регистры не отображаются):
<PRE>
<FONT COLOR=#000080>&gt;---- BREAK ----&gt; At address 2314:0105

AX=0000 BX=0000 CX=00FF DX=2314 SP=FFFE BP=091C SI=0100 DI=FFFE
DS=2314 ES=2314 SS=2314 F=7202

Coprocessor state:
CNTR=037F STATE=4000 TAG=FFFF CMDADR=023256  OPRADR=02365E
Numeric Registers:

Hit any key...
&gt;---- BREAK ----&gt; At address 2314:010D

AX=0000 BX=0000 CX=00FF DX=2314 SP=FFFE BP=091C SI=0100 DI=FFFE
DS=2314 ES=2314 SS=2314 F=7202

Coprocessor state:
CNTR=037F STATE=7800 TAG=3FFF CMDADR=023246  OPRADR=02365E
Numeric Registers:
ST(00)=3FFF8000000000000000

Hit any key...
&gt;---- BREAK ----&gt; At address 2314:0115

AX=0000 BX=0000 CX=00FF DX=2314 SP=FFFE BP=091C SI=0100 DI=FFFE
DS=2314 ES=2314 SS=2314 F=7202

Coprocessor state:
CNTR=037F STATE=7800 TAG=3FFF CMDADR=02324E  OPRADR=023662
Numeric Registers:
ST(00)=4000C000000000000000

Hit any key...
&gt;---- BREAK ----&gt; At address 2314:011D

AX=0000 BX=0000 CX=00FF DX=2314 SP=FFFE BP=091C SI=0100 DI=FFFE
DS=2314 ES=2314 SS=2314 F=7202

Coprocessor state:
CNTR=037F STATE=4000 TAG=FFFF CMDADR=023256  OPRADR=023666
Numeric Registers:

Hit any key...

</FONT>
</PRE>
<H2><A NAME="ch12_6">12.6. Обработка особых случаев</A></H2>
<P>
В арифметическом сопроцессоре имеются два механизма обработки
ошибок, возникающих при выполнении различных команд. Первый механизм
основан на генерации так называемого прерывания особого случая
(INT&nbsp;10h). Это прерывание вырабатывается в том случае, когда
происходит какая-нибудь ошибка (например, деление на нуль) при
условии, что соответствующие биты масок особых случаев в регистре
управления не установлены. При втором способе обработки ошибок
все особые случаи маскируются (соответствующие биты управляющего
регистра устанавливаются в единицу) и в случае ошибки сопроцессор
в качестве результата возвращает некоторое заранее известное особое
значение (нечисло, неопределенность или бесконечность).
<P>
Программист может выбирать между этими способами обработки ошибок,
маскируя или разрешая прерывание по особому случаю. Если прерывание
особого случая замаскировано, можно предложить следующий способ
обнаружения ошибки:
<UL>
<LI>сбросить флажки особых случаев в регистре сосотояния;
<LI>выполнить одну или несколько команд сопроцессора;
<LI>проверить состояние флажков особых случаев в регистре состояния,
в частности, бит суммарной ошибки ES;
<LI>если какой-либо флажок установлен, вызвать программу обработки
ошибочной ситуации;
<LI>в программе обработки ошибочной ситуации можно сбросить флажки
особых случаев, записав соответствующее значение в регистр состояния.
</UL>
<P>
Кроме того, после выполнения команды полезно проверить получившийся
результат на принадлежность к множеству особых значений.
<P>
Рассмотрим возможные особые случаи сопроцессора в реальном режиме.
<H3>12.6.1. Неточный результат</H3>
<P>
В результате выполнения некоторых операций может возникнуть такая
ситуация, когда невозможно точно представить результат. Например,
при результатом деления числа 1.0 на 3.0 является бесконечная
периодическая двоичная дробь 0.010101... Такое число не может
быть представлено точно ни в одном формате вещественных чисел.
<P>
Обычно неточный результат является результатом округления и может
не рассматриваться как ошибка.
<H3>12.6.2. Переполнение</H3>
<P>
Если результат выполнения операции слишком велик и не может быть
представлен в формате приемника результата, фиксируется особый
случай переполнения.
<P>
Этот особый случай обязательно произойдет, например, при сложении
максимального числа расширенной точности самим с собой или при
преобразовании этого числа в формат с двойной или одинарной точностью.
<P>
Так как для хранения промежуточных результатов используется 80-битовое
представление, при выполнении операций над числами с одинарной
или двойной точностью переполнения, как правило, не происходит.
Огромный диапазон чисел с расширенной точностью гарантирует правильность
представления больших по абсолютной величине результатов операций
с числами одинарной и двойной точности.
<H3>12.6.3. Антипереполнение</H3>
<P>
Антипереполнение возникает тогда, когда результат слишком мал
для его представления в формате приемника результата операции,
но все же отличен от нуля. Например, если делается попытка преобразовать
наименьшее положительное число с расширенной точностью в формат
числа с двойной или одинарной точностью.
<P>
Если вы используете числа только с двойной или одинарной точностью,
а для хранения промежуточных результатов используете формат с
расширенной точностью, особый случай антипереполнения, как правило,
не возникает.
<H3>12.6.4. Деление на нуль</H3>
<P>
Этот особый случай возникает при попытке выполнить деление конечного
ненулевого числа на нуль.
<P>
В афинном режиме при делении конечных (положительных или отрицательных)
чисел на нуль (положительный или отрицательный) в качестве результата
возвращается бесконечность. Знак этой бесконечности зависит от
знака делимого и от знака нуля. Например, при делении положительного
ненулевого числа на положительный нуль получается положительная
бесконечность, при делении положительного ненулевого числа на
отрицательный нуль - отрицательная бесконечность.
<P>
В проективном режиме, а также при попытке деления нуля на нуль
возникает особый случай недействительной операции, который будет
рассмотрен ниже.
<H3>12.6.5. Недействительная операция</H3>
<P>
Этот особый случай возникает при попытке выполнения таких запрещенных
команд, как деление нуля на нуль, извлечения корня из отрицательного
числа, обращение к несуществующему регистру сопроцессора или при
попытке использования в качестве операндов команд нечисел, неопределенностей
или бесконечности (для трансцендентных функций).
<H3>12.6.6. Денормализованный операнд</H3>
<P>
Мы уже говорили о том, что сопроцессор использует операнды в нормализованной
форме. Однако при выполнении операции может оказаться, что результат
слишком мал по абсолютной величине для представления его в нормализованной
форме. Можно было бы считать такой результат нулевым, однако это
привело бы к снижению точности вычислений или даже к грубым ошибкам.
Например, вычисляется следующее выражение:
<P>
(y-x)+x;
<P>
Если разность (y-x) вызывает антипереполнение и в качестве результата
берется нулевое значение, то после вычисления всего выражения
получится x. Если же пойти на расширение диапазона представления
чисел за счет снижения точности и сформировать результат вычисления
разности (y-x) как денормализованное число, выражение будет вычислено
правильно и в результате получится y.
<P>
Таким образом, иногда целесообразно замаскировать особый случай
денормализованного операнда и использовать денормализованные числа.
Однако при попытке деления на ненормализованное число или извлечения
из него квадратного корня фиксируется особый случай недействительной
операции.<BR>
</BODY>
</HTML>
