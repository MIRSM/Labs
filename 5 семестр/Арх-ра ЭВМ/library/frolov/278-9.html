<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Аппаратное обеспечение IBM PC</TITLE>
<link rel=stylesheet type=text/css href="../../images/styles.css">
<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.04z">
</HEAD>
<body>
<H1>4.&nbsp;ЧАСЫ РЕАЛЬНОГО ВРЕМЕНИ&nbsp;</H1>
<P>
4.1. <A HREF="#ch4_1">Прочитать показания часов реального времени</A>
<P>
4.2. <A HREF="#ch4_2">Установить часы реального времени</A>
<P>
4.3. <A HREF="#ch4_3">Прочитать дату из часов реального времени</A>
<P>
4.4. <A HREF="#ch4_4">Установить дату в часах реального времени</A>
<P>
4.5. <A HREF="#ch4_5">Установить будильник</A>
<P>
4.6. <A HREF="#ch4_6">Сброс будильника</A>
<P>
4.7. <A HREF="#ch4_7" >Использование часов реального времени</A>
<P>
Компьютеры IBM&nbsp;AT и PS/2 оснащены часами реального времени.
Эти часы питаются от аккумулятора, поэтому их показания не пропадают
при выключении компьютера.
<P>
Доступ к часам реального времени возможен либо через ячейки КМОП-памяти,
либо через специальные функции BIOS (что более предпочтительно
с точки зрения независимости работы программы от особенностей
аппаратуры).
<P>
Использование регистров КМОП-памяти часами реального времени приведено
в таблице:
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=92>Регистр</TD><TD WIDTH=364>Назначение</TD></TR>
<TR><TD WIDTH=92>0</TD><TD WIDTH=364>счетчик секунд</TD></TR>
<TR><TD WIDTH=92>1</TD><TD WIDTH=364>регистр секунд будильника
</TD></TR>
<TR><TD WIDTH=92>2</TD><TD WIDTH=364>счетчик минут</TD></TR>
<TR><TD WIDTH=92>3</TD><TD WIDTH=364>регистр минут будильника
</TD></TR>
<TR><TD WIDTH=92>4</TD><TD WIDTH=364>счетчик часов</TD></TR>
<TR><TD WIDTH=92>5</TD><TD WIDTH=364>регистр часов будильника
</TD></TR>
<TR><TD WIDTH=92>6</TD><TD WIDTH=364>счетчик дней недели (1 - воскресенье)
</TD></TR>
<TR><TD WIDTH=92>7</TD><TD WIDTH=364>счетчик дней месяца</TD>
</TR>
<TR><TD WIDTH=92>8</TD><TD WIDTH=364>счетчик месяцев</TD></TR>
<TR><TD WIDTH=92>9</TD><TD WIDTH=364>счетчик лет (последние две цифры текущего года)
</TD></TR>
</TABLE>
<UL>
<LI>0aH регистр состояния A
</UL>
<PRE>
<FONT SIZE=2 COLOR=#000080 FACE="Courier New Cyr">7 6 5 4 3 2 1 0
T-T-T-T-T-T-T-¬
¦ ¦     ¦       ¦
LT+T+-+T+T+-+-+T-
¦ L=T=- L=====¦= переключатель скорости (установлен в 0110)
¦   L=========== 22-разрядный делитель (установлен в 010)
L=============== Флаг обновления, 0 означает готовность
                           данных для чтения.



</FONT>
</PRE>
<UL>
<LI>0bH регистр состояния B
</UL>
<PRE>
<FONT SIZE=2 COLOR=#000080 FACE="Courier New Cyr">7 6 5 4 3 2 1 0
T-T-T-T-T-T-T-¬
¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
LT+T+T+T+T+T+T+T-
 ¦ ¦ ¦ ¦ ¦ ¦ ¦ L= 1 - использование летнего времени
 ¦ ¦ ¦ ¦ ¦ ¦ ¦    (daylight savings enable);
 ¦ ¦ ¦ ¦ ¦ ¦ ¦    0 - стандартное время (установлен в 0)
 ¦ ¦ ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ ¦ ¦ L=== 12 или 24-часовой режим.  0 - 12-часовой
 ¦ ¦ ¦ ¦ ¦ ¦      режим (установлен в 1)
 ¦ ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ ¦ L===== режим данных BCD. 1 - двоичный, 0 - BCD.
 ¦ ¦ ¦ ¦ ¦        (установлен в 0)
 ¦ ¦ ¦ ¦ ¦
 ¦ ¦ ¦ ¦ L======= разрешение прямоугольной волны.
 ¦ ¦ ¦ ¦          1 - включение прямоугольной волны.
 ¦ ¦ ¦ ¦          (установлен в 0)
 ¦ ¦ ¦ ¦
 ¦ ¦ ¦ L========= разрешение прерывания по окончанию
 ¦ ¦ ¦            изменения данных (установлен в 0)
 ¦ ¦ ¦
 ¦ ¦ L=========== разрешение прерывания будильника
 ¦ ¦              (установлен в 0)
 ¦ ¦
 ¦ L============= разрешение периодических прерываний
 ¦                (установлен в 0)
 ¦
 L=============== флаг обновления, 0 означает готовность
                           данных для чтения КМОП-памяти.

0cH     регистр состояния C.
        Биты состояния прерывания, их можно только читать.
 
0dH     регистр состояния D.
        Если бит 7 равен 0, это означает,       что разрядился
        аккумулятор, питающий КМОП-память.



</FONT>
</PRE>
<P>
Часы реального времени вырабатывают аппаратное прерывание IRQ8,
которому соответствует прерывание с номером 70h. Это прерывание
может вырабатываться по трем причинам:
<UL>
<LI>Прерывание по окончанию изменения данных. Вырабатывается при
установленном в 1 бите 4 регистра состояния B после каждого обновления
регистров часов.
<LI>Прерывание будильника вырабатывается при совпадении регистров
часов и регистров будильника и при установленном в 1 бите 5 регистра
состояний B.
<LI>Периодическое прерывание вырабатывается с интервалом примерно
1 миллисекунда при установленном в 1 бите 6 регистра состояний
B.
</UL>
<P>
При срабатывании будильника BIOS вырабатывает прерывание INT&nbsp;4Ah.
Программа может подготовить собственный обработчик для этого прерывания.
<P>
Для работы с часами реального времени вы можете обращаться непосредственно
к перечисленным выше ячейкам КМОП-памяти, используя порты 70h
и 71h. Однако лучше всего воспользоваться функциями 2 - 7 прерывания
1Ah, описанными ниже.
<H2><A NAME="ch4_1">4.1. Прочитать показания часов реального времени</A>
</H2>
<PRE>
<FONT SIZE=2 COLOR=#000080 FACE="Courier New Cyr">На входе:       AH = 02h.

На выходе:      CH = часы в BCD-формате (например,
                13h означает 13 часов);

                CL = минуты в BCD-формате;

                DH = секунды в BCD-формате;

                CF = CY = 1, если часы реального времени
                  не установлены.


</FONT>
</PRE>
<H2><A NAME="ch4_2">4.2. Установить часы реального времени</A>
</H2>
<PRE>
<FONT SIZE=2 COLOR=#000080 FACE="Courier New Cyr">На входе:       AH = 03h;

                CH = часы в BCD-формате (например,
                  13h означает 13 часов);

                CL = минуты в BCD-формате;

                DH = секунды в BCD-формате;

                DL = 1, если необходимо использовать
                  летнее время (daylight savings time
                  option).

На выходе: не используются.


</FONT>
</PRE>
<H2><A NAME="ch4_3">4.3. Прочитать дату из часов реального времени</A>
</H2>
<PRE>
<FONT SIZE=2 COLOR=#000080 FACE="Courier New Cyr">На входе:       AH = 04h.

На выходе:      CH = столетие в BCD-формате ;

                CL = год в BCD-формате (например,
                  CX=1991h означает 1991 год);

                DH = месяц в BCD-формате;

                DL = число в BCD-формате;

                CF = CY = 1, если часы реального времени
                 не установлены.


</FONT>
</PRE>
<H2><A NAME="ch4_4">4.4. Установить дату в часах реального времени</A>
</H2>
<PRE>
<FONT SIZE=2 COLOR=#000080 FACE="Courier New Cyr">На входе:       AH = 05h;

                CH = столетие в BCD-формате ;

                CL = год в BCD-формате (например,
                  CX=1991h означает 1991 год);

                DH = месяц в BCD-формате;

                DL = число в BCD-формате;

На выходе:      не используются.


</FONT>
</PRE>
<H2><A NAME="ch4_5">4.5. Установить будильник</A></H2>
<PRE>
<FONT SIZE=2 COLOR=#000080 FACE="Courier New Cyr">На входе:       AH = 06h;

                CH = часы в BCD-формате;

                CL = минуты в BCD-формате;

                DH = секунды в BCD-формате.

На выходе:      CF = CY = 1, если часы реального времени
                 не установлены.


</FONT>
</PRE>
<P>
Эта функция позволяет установить будильник на заданное время.
Когда будильник &quot;зазвенит&quot;, будет вызвано прерывание
INT&nbsp;4Ah (это прерывание вызывают модули BIOS после прихода
аппаратного прерывания от часов реального времени IRQ8, т.е. прерывания
с номером 70h). Программа, использующая функцию будильника, должна
подготовить обработчик прерывания INT&nbsp;4Ah, завершающий свою
работу выполнением команды IRET.
<P>
Программа может установить только один будильник.
<H2><A NAME="ch4_6">4.6. Сброс будильника</A></H2>
<PRE>
<FONT SIZE=2 COLOR=#000080 FACE="Courier New Cyr">На входе:       AH = 07h.

На выходе: не используются.


</FONT>
</PRE>
<P>
Эта функция позволяет сбросить будильник, например, для того чтобы
установить его заново на другое время.
<H2><A NAME="ch4_7">4.7. Использование часов реального времени</A>
</H2>
<P>
Вы можете использовать часы реального времени для решения двух
задач. Во-первых, часы позволяют определить текущую дату и время
с точностью до секунды. Во-вторых, будильник можно использовать
для выполнения каких-либо действий в заданное время или периодически.
<P>
Так как установленное время срабатывания будильника хранится в
КМОП-памяти, питающейся от аккумулятора, будильник не будет сброшен
при случайном выключении компьютера.
<P>
Для работы с часами реального времени мы подготовили следующую
функцию:
<PRE>
<FONT SIZE=2 COLOR=#000080 FACE="Courier New Cyr">/**
*.Name         timer
*.Title        Работа с часами реального времени
*
*.Descr        Эта функция предназначена для обслуживания
*              системных часов реального времени через
*              прерывание INT 1Ah.
*
*.Proto        int timer(char fn, SYSTIMER *tm)
*
*.Params       char     fn - выполняемая функция:
*
*              RTC_GET_TIME      - прочитать показания часов;
*              RTC_SET_TIME      - установить часы;
*              RTC_GET_DATE      - прочитать дату;
*              RTC_SET_DATE      - установить дату;
*              RTC_SET_ALARM     - установить будильник;
*              RTC_CLEAR_ALARM   - сбросить будильник.
*
*                 Все эти константы описаны в файле sysp.h
*
*              SYSTIMER tm - структура, содержащая данные
*                            для установки часов или
*                            показания часов:
*
*              typedef struct _SYSTIMER_ {
*
*                 char hour;     // часы
*                 char min;      // минуты
*                 char sec;      // секунды
*                 unsigned year; // год
*                 char month;    // месяц
*                 char day;      // число
*                 char daylight_savings; // флаг
*                                       // использование
*                        // летнего времени
*                        // (для включения режима
*                        // должен быть равен 1)
*
*              } SYSTIMER;
*
*.Return       0   - успешное выполнение функции;
*              -1  - часы реального времени отсутствуют
*                    в компьютере;
*
*.Sample       setalarm.c
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

union REGS reg;

int timer(char fn, SYSTIMER *tm) {

        reg.h.ah = fn;

        switch (fn) {

                case RTC_SET_TIME:

                        reg.h.ch = tm-&gt;hour;
                        reg.h.cl = tm-&gt;min;
                        reg.h.dh = tm-&gt;sec;
                        reg.h.dl = tm-&gt;daylight_savings;

                        break;

                case RTC_SET_DATE:

                        reg.x.cx = tm-&gt;year;
                        reg.h.dh = tm-&gt;month;
                        reg.h.dl = tm-&gt;day;

                        break;

                case RTC_SET_ALARM:

                        reg.h.ch = tm-&gt;hour;
                        reg.h.cl = tm-&gt;min;
                        reg.h.dh = tm-&gt;sec;

                        break;

        }

        int86(0x1a,&amp;reg,&amp;reg);

        if(reg.x.cflag == 1) return(-1);

        switch (fn) {

                case RTC_GET_TIME:

                        tm-&gt;hour = reg.h.ch;
                        tm-&gt;min = reg.h.cl;
                        tm-&gt;sec = reg.h.dh;

                        break;

                case RTC_GET_DATE:

                        tm-&gt;year = reg.x.cx;
                        tm-&gt;month = reg.h.dh;
                        tm-&gt;day = reg.h.dl;

                        break;
        }

        return(0);
}


</FONT>
</PRE>
<P>
Эта функция выполняет все виды обслуживания часов реального времени,
которые поддерживаются BIOS.
<P>
Для иллюстрации основных приемов работы с часами мы подготовили
программу, которая выводит на экран текущие дату и время. Затем
устанавливается будильник. Он должен сработать через одну минуту
и подать звуковой сигнал.
<P>
Перед установкой будильника программа подключает свой обработчик
прерывания 4Ah. Это прерывание вызывается при срабатывании будильника.
Перед завершением работы программа сбрасывает будильник и восстанавливает
вектор прерывания&nbsp;4Ah.
<PRE>
<FONT SIZE=2 COLOR=#000080 FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

// Выключаем проверку стека и указателей

#pragma check_stack( off )
#pragma check_pointer( off )

// Макро для выдачи звукового сигнала

#define BEEP() _asm { \
        _asm mov bx,0 \
        _asm mov ax, 0E07h \
        _asm int 10h \
}

void main(void);

// Описание программы-обработчика прерывания
// будильника

void _interrupt _far alarm(void);

// Переменная для хранения старого
// вектора будильника

void (_interrupt _far *old_4a)(void);


void main(void) {

char *month_to_text[] = {

        &quot;январь&quot;,
        &quot;февраль&quot;,
        &quot;март&quot;,
        &quot;апрель&quot;,
        &quot;май&quot;,
        &quot;июнь&quot;,
        &quot;июль&quot;,
        &quot;август&quot;,
        &quot;сентябрь&quot;,
        &quot;октябрь&quot;,
        &quot;ноябрь&quot;,
        &quot;декабрь&quot;

};

SYSTIMER tmr;

// Определяем текущие дату и время

        timer(RTC_GET_DATE, &amp;tmr);
        timer(RTC_GET_TIME, &amp;tmr);

// Выводим дату и время на экран

        printf(&quot;\nСейчас %d год, %s, %d число.&quot;
                 &quot;\n&quot;,
                 bcd2bin(&amp;(tmr.year)),
                 month_to_text[bcd1bin(&amp;(tmr.month)) - 1],
                 bcd1bin(&amp;(tmr.day)));

        printf(&quot;\nВремя - %02.2d:%02.2d:%02.2d&quot;
                 &quot;\n&quot;,
                 bcd1bin(&amp;(tmr.hour)),
                 bcd1bin(&amp;(tmr.min)),
                 bcd1bin(&amp;(tmr.sec)));

// Для установки будильника увеличиваем
// счетчик минут на единицу. Для упрощения
// программы мы не проверяем счетчик на
// переполнение, поэтому если текущее
// значение счетчика минут равно 59,
// будильник не сработает. Вы можете сами
// немного усовершенствовать программу для
// проверки переполнения.

        bin1bcd(bcd1bin(&amp;(tmr.min)) + 1,
                                                 &amp;(tmr.min));

// Выводим на экран время, когда сработает
// будильник.

        printf(&quot;\nВремя срабатывания будильника&quot;
                                &quot;- %02.2d:%02.2d:%02.2d&quot;
                 &quot;\n&quot;,
                 bcd1bin(&amp;(tmr.hour)),
                 bcd1bin(&amp;(tmr.min)),
                 bcd1bin(&amp;(tmr.sec)));

// Подключаем свой обработчик прерывания
// будильника, старое значение вектора
// 0x4a сохраняем

        old_4a = _dos_getvect(0x4a);

        _dos_setvect(0x4a, alarm);

// Устанавливаем будильник

        timer(RTC_SET_ALARM, &amp;tmr);

        printf(&quot;\nБудильник установлен. Для отмены &quot;
                         &quot;и завершения программы нажмите&quot;
                         &quot;\nлюбую клавишу...&quot;);

        getch();

// Сбрасываем будильник и восстанавливаем
// вектор прерывания будильника

        timer(RTC_CLEAR_ALARM, &amp;tmr);

        _dos_setvect(0x4a, old_4a);

        exit(0);
}

// ----------------------------------
// Преобразование однобайтового
// числа из формата BCD в двоичный
// формат.
// ----------------------------------

int bcd1bin(char *bcd) {

        return( ((*bcd) &amp; 0x0f) +
                  10 * (((*bcd) &amp; 0xf0) &gt;&gt; 4) );

}

// ----------------------------------
// Преобразование двухбайтового
// числа из формата BCD в двоичный
// формат.
// ----------------------------------

int bcd2bin(char *bcd) {

        return( bcd1bin(bcd) + 
                        100 * bcd1bin(bcd + 1) );

}

// ----------------------------------
// Преобразование однобайтового
// числа из двоичного формата
// формат BCD.
// ----------------------------------

int bin1bcd(int bin, char *bcd) {

        int i;

        i = bin / 10;

        *bcd = (i &lt;&lt; 4) + (bin - (i * 10));

}

// ----------------------------------
// Программа получает управление
// при срабатывании будильника.
// Ее назначение - выдать звуковой сигнал.
// ----------------------------------

void _interrupt _far alarm(void) {

        BEEP();
        BEEP();
        BEEP();
        BEEP();
        BEEP();
        BEEP();
        BEEP();

}

</FONT>
</PRE>
</BODY>
</HTML>
