<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Аппаратное обеспечение IBM PC</TITLE>
<link rel=stylesheet type=text/css href="../../images/styles.css">
<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.04z">
</HEAD>
<body>
<H1>2.&nbsp;КЛАВИАТУРА</H1>
<P>
2.1. <A HREF="#ch2_1">Принципы работы клавиатуры</A>
<P>
2.2. <A HREF="#ch2_2">Порты для работы с клавиатурой</A>
<P>
2.3. <A HREF="#ch2_3">Аппаратное прерывание клавиатуры</A>
<P>
2.4. <A HREF="#ch2_4">Средства BIOS для работы с клавиатурой</A>
<P>
2.5. <A HREF="#ch2_5">Средства MS-DOS для работы с клавиатурой</A>
<P>
2.6. <A HREF="#ch2_6">Клавиатурные функции библиотеки Microsoft C</A>
<P>
В этом разделе мы подробно рассмотрим одно из важнейших устройств
персонального компьютера - клавиатуру. Практически ни одна программа
не обходится без обращения к клавиатуре.
<P>
Программа может использовать клавиатуру по-разному. Она может
задержать свое выполнение до тех пор, пока оператор не введет
какое-нибудь число или пока не нажмет какую-нибудь клавишу. Выполняя
некоторую работу, программа может периодически проверять, не нажал
ли оператор на клавишу, изменяющую режим работы программы. Резидентные
программы могут контролировать все нажатия на клавиши, активизируясь
при нажатии определенной заранее комбинации. Можно использовать
прерывание, вырабатываемое клавиатурой, например, для завершения
работы программы.
<P>
Мы расскажем о работе с клавиатурой на разных уровнях - от использования
клавиатурных портов ввода/вывода до средств, предоставляемых стандартными
библиотеками трансляторов Microsoft QC 2.5 и C 6.0. Какой уровень
вам следует выбрать, зависит от решаемой задачи. Единственное,
что можно порекомендовать - это использовать по возможности средства
высокого уровня. Если ваша программа работает с клавиатурой на
уровне портов ввода/вывода, ее работа может оказаться зависимой
от типа клавиатуры и от типа компьютера.
<H2><A NAME="ch2_1">2.1. Принципы работы клавиатуры</A></H2>
<P>
Клавиатура выполнена, как правило, в виде отдельного устройства,
подключаемого к компьютеру тонким кабелем. Малогабаритные компьютеры
Lap-Top используют встроенную клавиатуру.
<P>
Что же находится внутри клавиатуры? Оказывается, там есть компьютер!
Только этот компьютер состоит из одной микросхемы и выполняет
специализированные функции. Он отслеживает нажатия на клавиши
и посылает номер нажатой клавиши в центральный компьютер.
<P>
Если рассмотреть сильно упрощенную принципиальную схему клавиатуры,
представленную на рисунке, можно заметить, что все клавиши находятся
в узлах матрицы:<BR>
<P>
<IMG SRC="278/pic1.gif" ALT="Рис. 1. Упрощенная схема клавиатуры">
<P>
<CENTER>Рис.1. Упрощенная схема клавиатуры</CENTER>
<P>
Все горизонтальные линии матрицы подключены через резисторы к
источнику питания +5 В. Клавиатурный компьютер имеет два порта
- выходной и входной. Входной порт подключен к горизонтальным
линиям матрицы (X0-X4), а выходной - к вертикальным (Y0-Y5).
<P>
Устанавливая по очереди на каждой из вертикальных линий уровень
напряжения, соответствующий логическому 0, клавиатурный компьютер
опрашивает состояние горизонтальных линий. Если ни одна клавиша
не нажата, уровень напряжения на всех горизонтальных линиях соответствует
логической 1 (т.к. все эти линии подключены к источнику питания
+5 В через резисторы).
<P>
Если оператор нажмет на какую-либо клавишу, то соответствующая
вертикальная и горизонтальная линии окажутся замкнутыми. Когда
на этой вертикальной линии процессор установит значение логического
0, то уровень напряжения на горизонтальной линии также будет соответствовать
логическому&nbsp;0.
<P>
Как только на одной из горизонтальных линий появится уровень логического
0, клавиатурный процессор фиксирует нажатие на клавишу. Он посылает
в центральный компьютер запрос на прерывание и номер клавиши в
матрице. Аналогичные действия выполняются и тогда, когда оператор
отпускает нажатую ранее клавишу.
<P>
Номер клавиши, посылаемый клавиатурным процессором, однозначно
связан с распайкой клавиатурной матрицы и не зависит напрямую
от обозначений, нанесенных на поверхность клавиш. Этот номер называется
скан-кодом (Scan Code).
<P>
Слово scan (&quot;сканирование&quot;), подчеркивает тот факт,
что клавиатурный компьютер сканирует клавиатуру для поиска нажатой
клавиши.
<P>
Но программе нужен не порядковый номер нажатой клавиши, а соответствующий
обозначению на этой клавише ASCII-код. Этот код не зависит однозначно
от скан-кода, т.к. одной и той же клавише могут соответствовать
несколько значений ASCII-кода. Это зависит от состояния других
клавиш. Например, клавиша с обозначением '1' используется еще
и для ввода символа '!' (если она нажата вместе с клавишей SHIFT).
<P>
Поэтому все преобразования скан-кода в ASCII-код выполняются программным
обеспечением. Как правило, эти преобразования выполняют модули
BIOS. Для использования символов кириллицы эти модули расширяются
клавиатурными драйверами.
<P>
Если нажать на клавишу и не отпускать ее, клавиатура перейдет
в режим автоповтора. В этом режиме в центральный компьютер автоматически
через некоторый период времени, называемый периодом автоповтора,
посылается код нажатой клавиши. Режим автоповтора облегчает ввод
с клавиатуры большого количества одинаковых символов.
<P>
Следует отметить, что клавиатура содержит внутренний 16-байтовый
буфер, через который она осуществляет обмен данными с компьютером.
<P>
В настоящее время существует три различных типа клавиатуры. Это
клавиатура для компьютеров IBM PC/XT, 84-клавишная клавиатура
для IBM AT и 101-клавишная (расширенная) клавиатура для IBM AT.
Некоторые клавиатуры имеют переключатель режима работы (XT/AT),
расположенный на нижней крышке. Он должен быть установлен в правильное
положение.
<H2><A NAME="ch2_2">2.2. Порты для работы с клавиатурой</A></H2>
<P>
Для работы с клавиатурой типа PC/XT используются порты с адресами
60h и 61h.
<P>
Порт 60h при чтении содержит скан-код последней нажатой клавиши.
<P>
Порт 61h управляет не только клавиатурой, но и другими устройствами
компьютера, например, работой встроенного динамика. Этот порт
доступен как для чтения, так и для записи. Для нас важен самый
старший бит этого порта. Если в старший бит порта 61h записать
значение 1, клавиатура будет заблокирована, если 0 - разблокирована.
<P>
Так как порт 61h управляет не только клавиатурой, при изменении
содержимого старшего бита необходимо сохранить состояние остальных
битов этого порта. Для этого можно сначала выполнить чтение содержимого
порта в регистр, изменить состояние старшего бита, затем выполнить
запись нового значения в порт:
<PRE>
<FONT COLOR=#000080>          .........

        in      al, 61h
        or      al, 80h
        out     61h, al

          .........

</FONT>
</PRE>
<P>
Компьютер типа IBM AT позволяет управлять скоростными характеристиками
клавиатуры, а также зажигать или гасить светодиоды на лицевой
панели клавиатуры - Scroll Lock, Num Lock, Caps Lock.
<P>
Для расширенного управления клавиатурой используется порт 60h
в режиме записи. Этот порт используются для управления подчиненным
процессором Intel 8042, ответственным за обмен данными с клавиатурным
компьютером.
<P>
При использовании порта 60h на запись программа дополнительно
получает следующие возможности:
<UL>
<LI>&nbsp;установка времени ожидания перед переходом клавиатуры
в режим автоповтора;
<LI>&nbsp;установка периода генерации скан-кода в режиме автоповтора;
<LI>&nbsp;управление светодиодами, расположенными на лицевой панели
клавиатуры - Scroll Lock, Num Lock, Caps Lock.
</UL>
<P>
Процессор 8042 обслуживает не только клавиатуру, но и другие системы
компьютера. Через порт 64h, например, выполняется сброс (отключение)
процессора 80286 для возврата из защищенного режима работы в реальный.
<P>
Для посылки команды процессору 8042 вначале необходимо убедиться
в том, что его внутренняя очередь команд пуста. Это можно сделать,
прочитав слово состояния 8042 из порта с адресом 64h. Бит с номером
1 должен быть равен нулю.
<P>
Приведем фрагмент программы, составленной на языке ассемблера,
проверяющий состояние очереди команд процессора 8042:
<PRE>
<FONT COLOR=#000080>                ..........

        mov     cx,0               ; счетчик для ограничения времени
                                                ; ожидания готовности 8042

wait_loop:

; читаем порт состояния процессора 8042

        in      al,64h 
        and     al,00000010b  ; флаг готовности

; ожидаем готовность процессора 8042

        loopnz  wait_loop
                                                ; к приему команды
                ..........


</FONT>
</PRE>
<P>
После того, как программа дождется готовности процессора 8042,
она может послать ему команду, записав ее в порт с адресом 60h:
<PRE>
<FONT COLOR=#000080>                ..........

        mov     al,cmd             ; команда для 8042
        out     60h ,al            ; вывод команды в 8042

                ..........

</FONT>
</PRE>
<P>
Некоторые команды состоят более чем из одного байта. Остальные
байты команды необходимо записать в порт 60h, предварительно убедившись
в готовности процессора 8042 с помощью последовательности команд,
приведенной выше. В большинстве случаев можно также использовать
простую временную задержку:
<PRE>
<FONT COLOR=#000080>                ..........

        mov     al, cmd_byte1
        out     60h, al

        mov     cx, 2000h

wait_loop: loop wait_loop

        mov     al, cmd_byte2
        out     60h, al
                ..........

</FONT>
</PRE>
<P>
Мы приведем формат двух команд процессора 8042, имеющих отношение
к работе с клавиатурой - команду установки задержки и периода
автоповтора и команду управления светодиодами, расположенными
на клавиатуре.
<P>
Для установки характеристик режима автоповтора в порт 60h необходимо
записать код команды 0F3h, затем байт, определяющий характеристики
режима:
<PRE>
<FONT COLOR=#000080>Биты    Значение


0-4     Период автоповтора:

           0 - 30.0;       0Ah - 10.0;
           1 - 26.7;       0Dh -  9.2;
           2 - 24.0;       10h -  7.5;
           4 - 20.0; 14h -  5.0;
           8 - 15.0;       1Fh -  2.0.
                        
        Период автоповтора определяет количество
        посылок скан-кода, генерируемых процессором
        клавиатуры в одну секунду. Можно использовать не
        только те значения, которые приведены выше,
        но и промежуточные, например, 9 или 15h.

5-6     Задержка включения режима автоповтора:

            00 - 250 мс;
            01 - 500 мс;
            10 - 750 мс;
            11 - 1000 мс.

7       Зарезервировано, должно быть равно 0.

</FONT>
</PRE>
<P>
Первоначально при инициализации системы период задержки для включения
режима автоповтора устанавливается модулями BIOS равным 500 мс
при периоде автоповтора, равном 10 повторам в секунду. Если это
слишком медленно для вас, вы можете установить другие значения.
Некоторые прикладные программы, например, текстовый процессор
Microsoft Word, содержат средства для управления временными характеристиками
клавиатуры.
<P>
Для управления светодиодами, расположенными на лицевой панели
клавиатуры, используйте команду 0EDh. Вслед за этой командой в
порт 60h необходимо записать байт, имеющий следующий формат:
<PRE>
<FONT COLOR=#000080>Биты    Значение


0       1 - включить светодиод Scroll Lock;

1       1 - включить светодиод Num Lock;

2       1 - включить светодиод Caps Lock;

3-7     не используются.

</FONT>
</PRE>
<P>
Приведем пример простейшей программы, управляющей светодиодами
на лицевой панели компьютера. Такое управление может выполняться
только при использовании порта 60h управления клавиатурой, так
как BIOS не содержит соответствующей поддержки. Наша программа
после запуска включит все светодиоды и будет ожидать нажатия на
любую клавишу. После нажатия программа выключит светодиоды.
<PRE>
<FONT COLOR=#000080>#include &lt;stdio.h&gt;

void main(void);

void main(void) {

        int i;

// Посылаем процессору клавиатуры
// команду управления светодиодами

        outp(0x60,0xed);

// Перед посылкой второго байта команды
// выполняем небольшую задержку

        for(i=0; i&lt;4000; i++);

// Выводим второй байт команды,
// младшие три бита которого определяют
// состояние светодиодов на лицевой панели
// клавиатуры.

        outp(0x60,7);

// Ожидаем нажатия на любую клавишу.

        getch();

// Выключаем все светодиоды.

        outp(0x60,0xed);
        for(i=0; i&lt;4000; i++);
        outp(0x60,0);

        exit(0);
}

</FONT>
</PRE>
<H2><A NAME="ch2_3">2.3. Аппаратное прерывание клавиатуры</A>
</H2>
<P>
Клавиатура подключена к линии прерывания IRQ1. Этой линии соответствует
прерывание INT&nbsp;09h.
<P>
Клавиатурное прерывание обслуживается модулями BIOS. Драйверы
клавиатуры и резидентные программы могут организовывать дополнительную
обработку прерывания INT&nbsp;09h. Для этого может быть использована
цепочка обработчиков прерывания. В первой книге первого тома мы
приводили примеры расширения обработчика прерывания INT&nbsp;09h.
<P>
Как работает стандартный обработчик клавиатурного прерывания,
входящий в состав BIOS?
<P>
Этот обработчик выполняет следующие действия:
<UL>
<LI>читает из порта 60h скан-код нажатой клавиши;
<LI>записывает вычисленное по скан-коду значение ASCII-кода нажатой
клавиши в специальный буфер клавиатуры, расположенный в области
данных BIOS;
<LI>устанавливает в 1 бит 7 порта 61h, разрешая дальнейшую работу
клавиатуры;
<LI>возвращает этот бит в исходное состояние;
<LI>записывает в порт 20h значение 20h для правильного завершения
обработки аппаратного прерывания.
</UL>
<P>
Обработчик прерывания INT&nbsp;09h не просто записывает значение
ASCII-кода в буфер клавиатуры. Дополнительно отслеживаются нажатия
таких комбинаций клавиш, как Ctrl-Alt-Del, обрабатываются специальные
клавиши PrtSc и SysReq. При вычислении кода ASCII нажатой клавиши
учитывается состояние клавиш Shift и CapsLock.
<P>
Буфер клавиатуры имеет длину 32 байта и расположен по адресу 0000h:041Eh
для машин IBM PC/XT.
<P>
В IBM AT и PS/2 расположение клавиатурного буфера задается содержимым
двух слов памяти с адресами 0000h:0480h (компонента смещения адреса
начала буфера) и 0000h:0482h (смещение конца буфера). Обычно в
IBM AT эти ячейки памяти содержат значения, соответственно, 001Eh
и 003Eh. Так как смещения заданы относительно сегментного адреса
0040h, то видно, что обычное расположение клавиатурного буфера
в IBM AT и PS/2 соответствует его расположению в IBM PC/XT.
<P>
Клавиатурный буфер организован циклически. Это означает, что при
его переполнении самые старые значения будут потеряны. Две ячейки
памяти, находящиеся в области данных BIOS с адресами 0000h:041Ah
и 0000h:041Ch содержат, соответственно, указатели на начало и
конец буфера. Если значения этих указателей равны друг другу,
буфер пуст. (Можно удалить все символы из буфера клавиатуры, установив
оба указателя на начало буфера. Однако есть более предпочтительный
способ с использованием прерывания BIOS INT&nbsp;16h).
<P>
Указателями на начало и конец клавиатурного буфера обычно управляют
обработчики прерываний INT&nbsp;09h и INT&nbsp;16h.
<P>
Программа извлекает из буфера коды нажатых клавиш, используя различные
функции прерывания INT&nbsp;16h.
<P>
Помимо управления содержимым буфера клавиатуры, обработчик прерывания
INT&nbsp;09h отслеживает нажатия на так называемые переключающие
клавиши - NumLock, ScrollLock, CapsLock, Ins. Состояние этих клавиш
записывается в область данных BIOS в два байта с адресами 0000h:0417h
и 0000h:0418h.
<P>
Формат байта 0000h:0417h:
<PRE>
<FONT COLOR=#000080>Биты    Значение


0       Нажата правая клавиша Shift.

1       Нажата левая клавиша Shift.

2       Нажата комбинация клавиш Ctrl-Shift с любой
        стороны.

3       Нажата комбинация клавиш Alt-Shift с любой
        стороны.

4       Состояние клавиши ScrollLock.

5       Состояние клавиши NumLock.

6       Состояние клавиши CapsLock.

7       Состояние клавиши Insert.


</FONT>
</PRE>
<P>
Формат байта 0000h:0418h:
<PRE>
<FONT COLOR=#000080>Биты    Значение


0       Нажата левая клавиша Shift вместе с клавишей
        Ctrl.

1       Нажата левая клавиша Shift вместе с клавишей
        Alt.

2       Нажата клавиша SysReq.

3       Состояние клавиши Pause.

4       Нажата клавиша ScrollLock.

5       Нажата клавиша NumLock.

6       Нажата клавиша CapsLock.

7       Нажата клавиша Insert.

</FONT>
</PRE>
<P>
Если вы изменяете состояние светодиодов на панели клавиатуры,
не забывайте устанавливать соответствующие биты в байтах состояния
клавиатуры.
<P>
Программой обработки прерывания INT&nbsp;09h отслеживаются некоторые
комбинации клавиш. В таблице приведены эти комбинации и действия,
выполняемые обработчиком прерывания при их обнаружении:
<PRE>
<FONT COLOR=#000080>Комбинация клавиш   Выполняемые действия


Ctrl-Alt-Del        Сброс и перезагрузка системы.

Ctrl-NumLock,       Перевод машины в состояние ожидания
Pause               до нажатия любой клавиши.

Shift-PrtSc         Распечатка на принтере содержимого
                    видеопамяти.

Ctrl-Break          Выполнение прерывания INT&nbsp;1Bh,
                    завершающего работу программы.

</FONT>
</PRE>
<P>
Многие типы клавиатур имеют отдельную альтернативную цифровую
панель, напоминающую клавиатуру калькулятора. Если одновременно
с нажатием на клавишу Alt набрать число на этой панели (не большее,
чем 255 и не равное 0), то это число будет помещено в буфер клавиатуры,
как будто бы оно было введено нажатием на одну клавишу. Это число
будет также записано в слове по адресу 0000h:0419h в области данных
BIOS.
<P>
При переполнении внутреннего буфера клавиатуры или буфера, расположенного
в области данных BIOS, программа-обработчик прерывания INT&nbsp;09h
генерирует звуковой сигнал.
<P>
При составлении программ для MS-DOS у вас едва ли появится необходимость
непосредственного манипулирования содержимым буфера клавиатуры
- вы можете использовать прерывание BIOS INT&nbsp;16h для выполнения
практически всех клавиатурных операций.
<P>
В следующем разделе мы займемся непосредственно изучением средств
работы с клавиатурой, предоставляемых в распоряжение прерыванием
BIOS INT&nbsp;16h.
<H2><A NAME="ch2_4">2.4. Средства BIOS для работы с клавиатурой</A>
</H2>
<P>
Набор функций для работы с клавиатурой, предоставляемый в распоряжение
программиста прерыванием BIOS INT&nbsp;16h, включает в себя функции
для выборки кода нажатого символа из буфера с ожиданием нажатия,
функции для проверки содержимого буфера и для управления содержимым
буфера, функции для изменения скоростных характеристик клавиатуры.
<P>
2.4.1. <A HREF="#ch2_4_1">Чтение символа с ожиданием</A>
<P>
2.4.<FONT FACE="Arial">2. <A HREF="#ch2_4_2">Проверка буфера на наличие в нем символов</A></FONT>
<P>
2.4.<FONT FACE="Arial">3. <A HREF="#ch2_4_3">Получение состояния переключающих клавиш</A></FONT>
<P>
2.4.<FONT FACE="Arial">4. <A HREF="#ch2_4_4">Установка временных характеристик клавиатуры</A></FONT>
<P>
2.4.<FONT FACE="Arial">5. <A HREF="#ch2_4_5">Запись символов в буфер клавиатуры</A></FONT>
<P>
2.4.6<FONT FACE="Arial">. <A HREF="#ch2_4_6">Чтение символа с ожиданием для 101-клавишной клавиатуры</A></FONT>
<P>
2.4.7. <A HREF="#ch2_4_7">Проверка буфера на наличие в нем символов для 101-клавишной клавиатуры</A>
<P>
2.4.8. <A HREF="#ch2_4_8">Получение состояния переключающих клавиш для 101-клавишной клавиатуры</A>
<H3><A NAME="ch2_4_1">2.4.1. Чтение символа с ожиданием</A></H3>
<P>
Функция 00h выполняет чтение кода символа из буфера клавиатуры,
если он там есть. Если буфер клавиатуры пуст, программа переводится
в состояние ожидания до тех пор, пока не будет нажата какая-нибудь
клавиша. Скан-код и ASCII-код нажатой клавиши передаются программе.
<P>
Приведем формат вызова функции:
<PRE>
<FONT COLOR=#000080>На входе:       AH = 00h
        
На выходе:      AL = ASCII-код символа или 0, если AH содержит
                расширенный ASCII-код символа;

                AH = скан-код или расширенный ASCII-код
                символа, если AL=0;


</FONT>
</PRE>
<P>
Приведем таблицу скан-кодов для клавиатуры IBM PC/XT:
<PRE>
<FONT COLOR=#000080>----------T----------T------------T-------------T---------------¬
¦01   Esc ¦12   E    ¦23   H      ¦34   . &gt;     ¦45   NumLock   ¦
¦02   1 ! ¦13   R    ¦24   J      ¦35   / ?     ¦46   ScrollLock¦
¦03   2 @ ¦14   T    ¦25   K      ¦36 Shft(прав)¦47   Home [7]  ¦
¦04   3 # ¦15   Y    ¦26   L      ¦37   * PrtSc ¦48   Up   [8]  ¦
¦05   4 $ ¦16   U    ¦27   ; :    ¦38   Alt     ¦49   PgUp [9]  ¦
¦06   5 % ¦17   I    ¦28   &quot; '    ¦39   Пробел  ¦4a   K -       ¦
¦07   6 ^ ¦18   O    ¦29   ` ~    ¦3a   CapsLock¦4b   &lt;-   [4]  ¦
¦08   7 &amp; ¦19   P    ¦2a Shft(лев)¦3b   F1      ¦4c        [5]  ¦
¦09   8 * ¦1a   [ {  ¦2b   \ |    ¦3c   F2      ¦4d   -&gt;   [6]  ¦
¦0a   9 ( ¦1b   ] }  ¦2c   Z      ¦3d   F3      ¦4e   K +       ¦
¦0b   0 ) ¦1c   Enter¦2d   X      ¦3e   F4      ¦4f   End  [1]  ¦
¦0c   - _ ¦1d   Ctrl ¦2e   C      ¦3f   F5      ¦50   Dn   [2]  ¦
¦0d   + = ¦1e   A    ¦2f   V      ¦40   F6      ¦51   PgDn [3]  ¦
¦0e   Bksp¦1f   S    ¦30   B      ¦41   F7      ¦52   Ins  [0]  ¦
¦0f   Tab ¦20   D    ¦31   N      ¦42   F8      ¦53   Del  [.]  ¦
¦10   Q   ¦21   F    ¦32   M      ¦43   F9      ¦               ¦
¦11   W   ¦22   G    ¦33   , &lt;    ¦44   F10     ¦               ¦
L---------¦----------¦------------¦-------------¦----------------


</FONT>
</PRE>
<P>
Для остальных клавиш функция 00h прерывания INT&nbsp;16h возвращает
расширенный ASCII-код:
<PRE>
<FONT COLOR=#000080>г--------T--------------T--------------T-------------¬
¦ F1   3b¦ Shift-F1   54¦ Ctrl-F1   5e ¦ Alt-F1   68 ¦
¦ F2   3c¦ Shift-F2   55¦ Ctrl-F2   5f ¦ Alt-F2   69 ¦
¦ F3   3d¦ Shift-F3   56¦ Ctrl-F3   60 ¦ Alt-F3   6a ¦
¦ F4   3e¦ Shift-F4   57¦ Ctrl-F4   61 ¦ Alt-F4   6b ¦
¦ F5   3f¦ Shift-F5   58¦ Ctrl-F5   62 ¦ Alt-F5   6c ¦
¦ F6   40¦ Shift-F6   59¦ Ctrl-F6   63 ¦ Alt-F6   6d ¦
¦ F7   41¦ Shift-F7   5a¦ Ctrl-F7   64 ¦ Alt-F7   6e ¦
¦ F8   42¦ Shift-F8   5b¦ Ctrl-F8   65 ¦ Alt-F8   6f ¦
¦ F9   43¦ Shift-F9   5c¦ Ctrl-F9   66 ¦ Alt-F9   70 ¦
¦ F10  44¦ Shift-F10  5d¦ Ctrl-F10  67 ¦ Alt-F10  71 ¦
L--------¦--------------¦--------------¦--------------

г----------T----------T-------------T-------------¬
¦ Alt-A  1e¦ Alt-P  19¦ Alt-3     7a¦ Down  Dn  50¦
¦ Alt-B  30¦ Alt-Q  10¦ Alt-4     7b¦ Left  &lt;-  4b¦
¦ Alt-C  2e¦ Alt-R  13¦ Alt-5     7c¦ Right -&gt;  4d¦
¦ Alt-D  20¦ Alt-S  1f¦ Alt-6     7d¦ Up    Up  48¦
¦ Alt-E  12¦ Alt-T  14¦ Alt-7     7e¦ End       4f¦
¦ Alt-F  21¦ Alt-U  16¦ Alt-8     7f¦ Home      47¦
¦ Alt-G  22¦ Alt-V  2f¦ Alt-9     80¦ PgDn      51¦
¦ Alt-H  23¦ Alt-W  11¦ Alt--     82¦ PgUp      49¦
¦ Alt-I  17¦ Alt-X  2d¦ Alt-=     83¦             ¦
¦ Alt-J  24¦ Alt-Y  15¦             ¦ ^Left     73¦
¦ Alt-K  25¦ Alt-Z  2c¦             ¦ ^Right    74¦
¦ Alt-L  26¦          ¦ Shift-Tab 0f¦ ^End      75¦
¦ Alt-M  32¦ Alt-0  81¦ Ins       52¦ ^Home     77¦
¦ Alt-N  31¦ Alt-1  78¦ Del       53¦ ^PgDn     76¦
¦ Alt-O  18¦ Alt-2  79¦ ^PrtSc    72¦ ^PgUp     84¦
L----------¦----------¦-------------¦--------------


</FONT>
</PRE>
<P>
В следующей таблице приведены скан-коды клавиш, имеющихся только
на 101-клавишной клавиатуре:
<PRE>
<FONT COLOR=#000080>г-------------T------------------T------------------¬
¦ F11       85¦ Alt-Bksp      0e ¦  Alt- Д /      a4¦
¦ F12       86¦ Alt-Enter     1c ¦  Alt- Д *      37¦
¦ Shft-F11  87¦ Alt-Esc       01 ¦  Alt- Д -      4a¦
¦ Shft-F12  88¦ Alt-Tab       a5 ¦  Alt- Д +      4e¦
¦ Ctrl-F11  89¦ Ctrl-Tab      94 ¦  Alt- Д Enter  a6¦
¦ Ctrl-F12  8a¦                  ¦                  ¦
¦ Alt-F11   8b¦ Alt-up     Up 98 ¦ Ctrl- Д /      95¦
¦ Alt-F12   8c¦ Alt-down   Dn a0 ¦ Ctrl- Д *      96¦
¦ Alt-[     1a¦ Alt-left   &lt;- 9b ¦ Ctrl- Д -      8e¦
¦ Alt-]     1b¦ Alt-right  -&gt; 9d ¦ Ctrl- Д +      90¦
¦ Alt-;     27¦                  ¦                  ¦
¦ Alt-'     28¦ Alt-Delete    a3 ¦ Ctrl- Д Up [8] 8d¦
¦ Alt-`     29¦ Alt-End       9f ¦ Ctrl- Д 5  [5] 8f¦
¦ Alt-\     2b¦ Alt-Home      97 ¦ Ctrl- Д Dn [2] 91¦
¦ Alt-,     33¦ Alt-Insert    a2 ¦ Ctrl- Д Ins[0] 92¦
¦ Alt-.     34¦ Alt-PageUp    99 ¦ Ctrl- Д Del[.] 93¦
L-------------¦------------------¦-------------------


</FONT>
</PRE>
<P>
Буква &quot;Д&quot; в последней таблице обозначает дополнительную
(&quot;калькуляторную&quot;) клавиатуру.
<P>
Для демонстрации использования функции 00h прерывания INT&nbsp;16h
мы подготовили программу, выводящую на экран скан-коды и ASCII-коды
нажимаемых клавиш:
<PRE>
<FONT COLOR=#000080>#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;

void main(void);

void main(void) {

        union REGS  rg;

        printf(&quot;\nОпределение скан-кода и ASCII-кода клавиш.&quot;
          &quot;\nДля завершения работы нажмите клавишу ESC.\n\n&quot;);

        for(;;) {

// Вызываем прерывание INT 16h

                rg.h.ah = 0;
                int86(0x16, &amp;rg, &amp;rg);

// Выводим на экран содержимое регистров AH и AL,
// содержащих, соответственно, скан-код и ASCII-код
// нажатой клавиши.

                printf(&quot;\nScan = %02.2X Ascii = %02.2X&quot;,
                        rg.h.ah,
                        rg.h.al);

// Если была нажата клавиша ESC, завершаем работу программы

                if(rg.h.ah == 1) break;

        }
}

</FONT>
</PRE>
<H3><A NAME="ch2_4_2">2.4.2. Проверка буфера на наличие в нем
символов</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 01h.

На выходе:      ZF = 0, если в буфере имеется код нажатой
                        на клавиатуре клавиши;

                ZF = 1, если буфер клавиатуры пуст;

                AL = ASCII-код символа или 0, если AH содержит
                      расширенный ASCII-код символа;

                AH = скан-код или расширенный ASCII-код
                      символа, если AL=0.

</FONT>
</PRE>
<P>
Функция 01h поможет вам проверить состояние буфера клавиатуры
- есть там коды нажатых клавиш или нет. При этом программа не
переводится в состояние ожидания, даже если буфер клавиатуры пуст.
В этом случае в регистре флагов устанавливается в единицу флаг
ZF и управление возвращается программе.
<P>
Эту функцию удобно использовать во время выполнения какого-либо
длительного процесса (например, форматирования диска или передачи
данных по линии связи) для прерывания этого процесса по запросу
оператора.
<P>
Кроме того, функцию можно использовать вместе с функцией 00h для
сброса содержимого клавиатурного буфера. Для этого в цикле повторяют
вызов функции 01h, вслед за которым идет вызов функции 00h при
условии, что буфер клавиатуры не пуст. Сброс клавиатурного буфера
полезно выполнять перед вводом ответственной информации, так как
из-за случайного двойного или тройного нажатия на клавишу в буфере
клавиатуры могут оказаться лишние символы.
<P>
Приведем текст программы, выводящей на экран в цикле символ '*'.
При нажатии на любую клавишу, кроме ESC, программа выводит на
экран строку текста - инструкцию для завершения работы программы.
Если нажать на клавишу ESC, работа программы будет завершена.
<PRE>
<FONT COLOR=#000080>#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;

void main(void);

void main(void) {

        union REGS  rg;
        int   i, zflag;


        for(;;) {

// Выводим в цикле символ '*'

                putchar('*');

// Небольшая задержка во времени

                for(i=0; i&lt;1000; i++);

// Вызываем прерывание INT 16h для проверки буфера клавиатуры

// Устанавливаем флаг, который будет сброшен при нажатии на
// любую клавишу

                zflag = 1;

                _asm {

                        mov   ax, 0100h
                        int   16h

// Если нажатия не было,
// продолжаем выполнение программы

                        jz    nokey       

// При нажатии на любую клавишу
// сбрасываем флаг

                        mov   zflag, 0
nokey:

                }

                if(zflag == 0) {

// Если флаг сброшен, читаем код нажатой клавиши из буфера
// при помощи функции 01h прерывания INT 16h

                        rg.h.ah = 0;
                        int86(0x16, &amp;rg, &amp;rg);

// Если была нажата клавиша ESC, завершаем работу программы

                        if(rg.h.ah == 1) {

// Выводим на экран содержимое регистров AH и AL,
// содержащих, соответственно, скан-код и ASCII-код
// нажатой клавиши.

                                printf(&quot;\nScan = %02.2X Ascii = %02.2X&quot;,
                                        rg.h.ah,
                                        rg.h.al);

                                        break;
                        }
                        else printf(&quot;\nДля завершения нажмите ESC\n&quot;);
                }
        }
}

</FONT>
</PRE>
<H3><A NAME="ch2_4_3">2.4.3. Получение состояния переключающих
клавиш</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 02h
        
На выходе:      AL = Байт состояния переключающих клавиш


</FONT>
</PRE>
<P>
Функция возвращает в регистре AL состояние переключающих клавиш
(Shift, Ctrl, Alt, ScrollLock, NumLock, CapsLock, Ins). Формат
байта состояния соответствует формату байта, находящегося в области
данных BIOS по адресу 0000h:0417h:
<PRE>
<FONT COLOR=#000080>Биты    Значение


0       Нажата правая клавиша Shift.

1       Нажата левая клавиша Shift.

2       Нажата комбинация клавиш Ctrl-Shift с любой
        стороны.

3       Нажата комбинация клавиш Alt-Shift с любой
        стороны.

4       Состояние клавиши ScrollLock.

5       Состояние клавиши NumLock.

6       Состояние клавиши CapsLock.

7       Состояние клавиши Insert.

</FONT>
</PRE>
<P>
Функция может быть использована для анализа текущего состояния
переключающих клавиш.
<P>
Изменим текст предыдущей программы таким образом, чтобы завершение
ее работы происходило лишь в том случае, если переключающая клавиша
CapsLock находится в выключенном состоянии (соответствующий светодиод
не горит):
<PRE>
<FONT COLOR=#000080>#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;

void main(void);

void main(void) {

        union REGS  rg;
        int   i, zflag;


        for(;;) {

// Выводим в цикле символ '*'

                putchar('*');

// Небольшая задержка во времени

                for(i=0; i&lt;1000; i++);

// Вызываем прерывание INT 16h для проверки буфера клавиатуры

// Устанавливаем флаг, который будет сброшен при нажатии на
// любую клавишу

                zflag = 1;

                _asm {

                        mov   ax, 0100h
                        int   16h

// Если нажатия не было,
// продолжаем выполнение программы

                        jz    nokey

// При нажатии на любую клавишу
// сбрасываем флаг

                        mov   zflag, 0 
nokey:

                }

                if(zflag == 0) {

// Если флаг сброшен, читаем код нажатой клавиши из буфера
// при помощи функции 01h прерывания INT 16h

                        rg.h.ah = 0;
                        int86(0x16, &amp;rg, &amp;rg);

// Если была нажата клавиша ESC, завершаем работу программы,
// при условии, что переключатель CapsLock выключен

                        if(rg.h.ah == 1) {

// Дополнительно проверяем состояние клавиши CapsLock,
// этой клавише соответствует бит 0x40 в слове состояния

                                rg.h.ah = 2;
                                int86(0x16, &amp;rg, &amp;rg);

                                if((rg.h.al &amp; 0x40) == 0) break;

                                else printf(&quot;\nДля завершения нажмите&quot;
                                  &quot; ESC &quot;
                                  &quot;при выключенной клавише CapsLock.\n&quot;);
                        }
                        else printf(&quot;\nДля завершения нажмите ESC &quot;
                                  &quot;при выключенной клавише CapsLock.\n&quot;);
                }
        }
}

</FONT>
</PRE>
<H3><A NAME="ch2_4_4">2.4.4. Установка временных характеристик
клавиатуры</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 03h;

                AL = 05h;

                BL = Период автоповтора (количество повторов
                     за одну секунду):

                        0 - 30.0;       0Ah - 10.0;
                        1 - 26.7;       0Dh -  9.2;
                        2 - 24.0;       10h -  7.5;
                        4 - 20.0; 14h -  5.0;
                        8 - 15.0;       1Fh -  2.0.

                BH =    Задержка включения режима автоповтора:

                        0 - 250 мс;
                        1 - 500 мс;
                        2 - 750 мс;
                        3 - 1000 мс.
        
На выходе:      Не используются.


</FONT>
</PRE>
<P>
Мы уже рассказывали о возможности изменения временных характеристик
клавиатуры. Если BIOS, установленная в вашей машине, изготовлена
после 15 декабря 1985 года, вы можете воспользоваться этой функцией
для ускорения (или замедления) работы клавиатуры.
<P>
В качестве примера приведем две программы. Первая программа увеличивает
быстродействие клавиатуры до его верхнего предела, вторая восстанавливает
исходные значения временных характеристик.
<PRE>
<FONT COLOR=#000080>#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;

void main(void);

void main(void) {

        union REGS  rg;


                rg.h.al = 5;
                rg.h.ah = 3;

// Устанавливаем максимальное быстродействие клавиатуры

                rg.h.bl = 0;
                rg.h.bh = 0;

                int86(0x16, &amp;rg, &amp;rg);

}
#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;

void main(void);

void main(void) {

        union REGS  rg;


                rg.h.al = 5;
                rg.h.ah = 3;

// Восстанавливаем исходное быстродействие клавиатуры

                rg.h.bl = 0xa;
                rg.h.bh = 1;

                int86(0x16, &amp;rg, &amp;rg);

}

</FONT>
</PRE>
<H3><A NAME="ch2_4_5">2.4.5. Запись символов в буфер клавиатуры</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 05h;

                CL = ASCII-код записываемого символа;

                CH = скан-код записываемого символа, или 0.
        

На выходе:      AL = 0  - запись выполнена успешно;
                1       - буфер клавиатуры переполнен.


</FONT>
</PRE>
<P>
С помощью этой функции можно вставить символы в буфер клавиатуры,
как будто они были введены оператором.
<P>
Приведенная программа записывает в буфер клавиатуры пять символов
'*'. Запустите ее и посмотрите на системное приглашение. Вы увидите
что-нибудь похожее на C:\&gt;*****.
<PRE>
<FONT COLOR=#000080>#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;

void main(void);

void main(void) {

        union REGS  rg;
        int   i;

         for(i=0; i&lt;5; i++) {

                rg.h.ah = 5;

                rg.h.cl = '*';
                rg.h.ch = 9;

                int86(0x16, &amp;rg, &amp;rg);

         }
}

</FONT>
</PRE>
<H3><A NAME="ch2_4_6">2.4.6 Чтение символа с ожиданием для 101-клавишной
клавиатуры</A></H3>
<P>
Функция 10h полностью аналогична функции 00h, но она предназначена
для работы с клавиатурой, имеющей 101 клавишу.
<P>
Приведем формат вызова функции:
<PRE>
<FONT COLOR=#000080>На входе:       AH = 10h.
        
На выходе:      AL = ASCII-код символа или 0, если AH содержит
                расширенный ASCII-код символа;

                AH = скан-код или расширенный ASCII-код
                символа, если AL=0.

</FONT>
</PRE>
<P>
Функция определена для BIOS, изготовленной не раньше 15 декабря
1985 года.
<H3><A NAME="ch2_4_7">2.4.7. Проверка буфера на наличие в нем
символов для 101-клавишной клавиатуры</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 11h.

На выходе:      ZF = 0, если в буфере имеется код нажатой
                        на клавиатуре клавиши;

                ZF = 1, если буфер клавиатуры пуст;

                AL = ASCII-код символа или 0, если AH содержит
                        расширенный ASCII-код символа;

                AH = скан-код или расширенный ASCII-код
                        символа, если AL=0.

</FONT>
</PRE>
<P>
Функция 11h полностью аналогична функции 01h, но она предназначена
для работы с клавиатурой, имеющей 101 клавишу.
<P>
Эта функция определена для BIOS, изготовленной не раньше 15 декабря
1985 года.
<H3><A NAME="ch2_4_8">2.4.8. Получение состояния переключающих
клавиш для 101-клавишной клавиатуры</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 12h.
        
На выходе:      AL = Байт состояния переключающих клавиш.


</FONT>
</PRE>
<P>
Функция возвращает в регистре AL состояние переключающих клавиш
(Shift, Ctrl, Alt, ScrollLock, NumLock, CapsLock, Ins):
<PRE>
<FONT COLOR=#000080>Биты    Значение

0       Нажата левая клавиша Shift вместе с Ctrl.
1       Нажата левая клавиша Shift вместе с Alt.
2       Нажата правая клавиша Shift вместе с Ctrl.
3       Нажата правая клавиша Shift вместе с Alt.
4       Нажата клавиша ScrollLock.
5       Нажата клавиша NumLock.
6       Нажата клавиша CapsLock.
7       Нажата клавиша SysReq.

</FONT>
</PRE>
<P>
Функция 12h аналогична функции 02h, но она предназначена для работы
с клавиатурой, имеющей 101 клавишу и имеет другой формат байта
состояния.
<P>
Эта функция определена для BIOS, изготовленной не раньше 15 декабря
1985 года.
<H2><A NAME="ch2_5">2.5. Средства MS-DOS для работы с клавиатурой</A>
</H2>
<P>
К сожалению, MS-DOS не предоставляет программам каких-либо существенных
дополнительных возможностей по сравнению с функциями прерывания
BIOS INT&nbsp;16h. Поэтому многие программы работают с клавиатурой
через BIOS.
<P>
Однако, если ваша программа пользуется клавиатурными функциями
MS-DOS, то ей доступно средство переназначения ввода операционной
системы. Это возможно благодаря тому, что клавиатурные функции
MS-DOS являются функциями, работающими со стандартным вводом MS-DOS,
а стандартный ввод может быть переназначен.
<P>
Кроме того, некоторые клавиатурные функции автоматически посылают
введенные символы на устройство стандартного вывода. По умолчанию
это дисплей, но устройство стандартного вывода может быть переназначено
для вывода в файл, на принтер или другое устройство.
<P>
Вообще говоря, клавиатурные функции MS-DOS больше всего подходят
для тех программ, которые ведут с оператором &quot;построчный&quot;
диалог. Для таких программ при использовании средств переназначения
ввода/вывода возможна организация автоматического &quot;пакетного&quot;
выполнения, когда все сообщения выводятся в файл, а все данные,
которые обычно вводятся с клавиатуры, считываются из заранее подготовленного
файла &quot;ответов&quot;.
<P>
Некоторые клавиатурные функции MS-DOS отслеживают комбинации клавиш
Ctrl-C и Ctrl-Break. Если оператор ввел такую комбинацию клавиш,
вызывается прерывание INT&nbsp;23h, завершающее работу текущей
программы. Если ваша программа не должна завершаться при нажатии
этих комбинаций клавиш, можно либо создать и подключить собственный
обработчик для INT&nbsp;23h, либо использовать те клавиатурные
функции MS-DOS, которые не выполняют проверку указанных выше комбинаций
клавиш.
<P>
Приведем подробное описание клавиатурных функций прерывания MS-DOS
INT&nbsp;21h.
<P>
2.5.1. <A HREF="#ch2_5_1">Буферизованный ввод с эхо-выводом</A>
<P>
2.5.2. <A HREF="#ch2_5_2">Буферизованный ввод без эхо-вывода</A>
<P>
2.5.3. <A HREF="#ch2_5_3">Нефильтрованный ввод без эхо-вывода</A>
<P>
2.5.4. <A HREF="#ch2_5_4">Ввод/вывод на консоль</A>
<P>
2.5.5. <A HREF="#ch2_5_5">Ввод строки символов</A>
<P>
2.5.6. <A HREF="#ch2_5_6">Проверка состояния стандартного ввода</A>
<P>
2.5.7. <A HREF="#ch2_5_7">Сброс буфера клавиатуры</A>
<H3><A NAME="ch2_5_1">2.5.1. Буферизованный ввод с эхо-выводом</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 01h.
        
На выходе:      AL = ASCII-код символа или 0. Если регистр
                содержит 0, то следующий вызов этой же
                функции возвратит в регистре AL 
                расширенный ASCII-код символа.
                
                Функция проверяет комбинации клавиш
                Ctrl-C и Ctrl-Break.


</FONT>
</PRE>
<P>
Функция читает символы со стандартного устройства ввода. Если
стандартным устройством ввода является клавиатура, и буфер клавиатуры
пуст, выполнение программы задерживается до нажатия на любую клавишу.
<P>
Введенный символ выводится на стандартное устройство вывода.
<P>
Если программа в качестве ASCII-кода получила 0, она должна вызвать
эту функцию еще один раз. Во второй раз регистр AL будет содержать
расширенный ASCII-код нажатой клавиши.
<H3><A NAME="ch2_5_2">2.5.2. Буферизованный ввод без эхо-вывода</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 08h.
        
На выходе:      AL = ASCII-код символа или 0. Если регистр
                содержит 0, то следующий вызов этой же
                функции возвратит в регистре AL 
                расширенный ASCII-код символа.
                
                Функция проверяет комбинации клавиш
                Ctrl-C и Ctrl-Break.


</FONT>
</PRE>
<P>
Функция аналогична предыдущей. Она читает символы со стандартного
устройства ввода. Если стандартным устройством ввода является
клавиатура, и буфер клавиатуры пуст, выполнение программы задерживается
до нажатия на любую клавишу.
<P>
Эту функцию необходимо использовать в тех случаях, когда не требуется
автоматически дублировать на экране вводимые с клавиатуры символы.
Например, с ее помощью можно организовать ввод паролей.
<H3><A NAME="ch2_5_3">2.5.3. Нефильтрованный ввод без эхо-вывода</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 07h.
        
На выходе:      AL = ASCII-код символа или 0. Если регистр
                содержит 0, то следующий вызов этой же
                функции возвратит в регистре AL 
                расширенный ASCII-код символа.
                
                Функция не проверяет комбинации клавиш
                Ctrl-C и Ctrl-Break.


</FONT>
</PRE>
<P>
Если буфер клавиатуры пуст, выполнение программы задерживается
до нажатия на любую клавишу.
<P>
Эту функцию удобно использовать в тех случаях, когда завершение
программы по нажатию комбинаций клавиш Ctrl-C или Ctrl-Break по
тем или иным причинам нежелательно. Например, программа держит
в оперативной памяти буфера для данных, которые перед завершением
работы обязательно должны быть записаны на диск. Если оператор
в неподходящий момент времени нажал Ctrl-C и программа аварийно
завершила работу, содержимое буферов будет потеряно.
<H3><A NAME="ch2_5_4">2.5.4. Ввод/вывод на консоль</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 06h;

                DL = 0FFh - для ввода символа с консоли;
                  или:
                DL = код символа, не равный 0FFh - для
                  вывода символа на консоль.
        
На выходе:      ZF = 0, если в буфере имеется код нажатой
                        на клавиатуре клавиши;

                ZF = 1, если буфер клавиатуры пуст;

                AL = ASCII-код символа или 0, если AH содержит
                   расширенный ASCII-код символа.

                Функция проверяет комбинации клавиш
                Ctrl-C и Ctrl-Break.

</FONT>
</PRE>
<P>
Функция 06h может использоваться как для ввода с консоли, так
и для вывода символов на консоль. Режим работы функции зависит
от содержимого регистра DL при вызове функции. Если этот регистр
содержит значение 0FFh, функция выполняет ввод с консоли, в противном
случае символ, код которого записан в этот регистр, выводится
на консоль.
<P>
Очевидно, что с помощью этой функции нельзя вывести на консоль
символ с кодом 0FFh.
<P>
Основное отличие функции 06h от всех описанных ранее заключается
в том, что эта функция не ожидает, пока оператор нажмет на клавишу.
Если буфер клавиатуры пуст, функция просто устанавливает флаг
процессора ZF в 1.
<P>
Если в буфере клавиатуры имеются символы, флаг ZF сбрасывается
и в регистр AL функция записывает ASCII-код символа.
<H3><A NAME="ch2_5_5">2.5.5. Ввод строки символов</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH    = 0Ah;

                DS:DX = адрес буфера для ввода строки;
        
На выходе:      Буфер содержит введенную строку.

                Функция проверяет комбинации клавиш
                Ctrl-C и Ctrl-Break.

</FONT>
</PRE>
<P>
Функция предназначена для ввода с клавиатуры строки символов.
Перед вызовом функции необходимо специальным образом подготовить
буфер, адрес которого передается в регистрах DS:DX - в первый
байт буфера следует записать максимальную длину вводимой строки
(в диапазоне от 1 до&nbsp;244):
<PRE>
<FONT COLOR=#000080>----T---T---T---T---T---T- - -
¦max¦ ? ¦ ?   ?   ?   ?   ?   
L-T-+---+---+---+---+---+ -  -
  ¦
  L----&gt; максимальная длина вводимой строки


</FONT>
</PRE>
<P>
После возврата из функции буфер будет иметь следующий формат:
<PRE>
<FONT COLOR=#000080>----T---T---T---T---T---T- - -
¦max¦len¦ T   E   X   T   0Dh 
L-T-+-T-+---+---+---+---+ -  -
  ¦   ¦
  ¦   L------- длина введенной строки (без учета
  ¦                      завершающего символа CR)
  L----------- остается без изменений

</FONT>
</PRE>
<P>
Ввод осуществляется до тех пор, пока либо количество введенных
символов не достигнет max-1, либо пока не будет нажата клавиша
Enter (код 0Dh). Если оператор уже ввел max-1 символ и продолжает
вводить символы дальше, функция выдает звуковой сигнал на каждое
нажатие и игнорирует вводимые символы до тех пор, пока не будет
нажата клавиша Enter.
<P>
При вводе строки можно использовать стандартные средства редактирования
MS-DOS, используемые при вводе команд в режиме командной строки.
<H3><A NAME="ch2_5_6">2.5.6. Проверка состояния стандартного ввода</A>
</H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 0Bh.
        
На выходе:      AL = 0FFh, если в буфере имеется код нажатой
                           на клавиатуре клавиши;

                AL = 0,    если буфер клавиатуры пуст;

                Функция проверяет комбинации клавиш
                Ctrl-C и Ctrl-Break.


</FONT>
</PRE>
<P>
Эта функция проверяет состояние клавиатурного буфера. Вы можете
вызывать ее перед функциями 01h, 07h, 08h для того, чтобы избежать
ожидания нажатия на клавишу.
<P>
Если ваша программа выполняет какую-либо длительную обработку
(копирование файлов, форматирование дисков и&nbsp;т.п.), вы можете
вызывать эту функцию в процессе обработки для проверки нажатия
комбинации клавиш, прерывающих работу программы.
<H3><A NAME="ch2_5_7">2.5.7. Сброс буфера клавиатуры</A></H3>
<PRE>
<FONT COLOR=#000080>На входе:       AH = 0Ch;

                AL = 1, 6, 7, 8 или 0Ah.

На выходе:      не опеределены.

</FONT>
</PRE>
<P>
Функция очищает клавиатурный буфер, затем вызывает клавиатурную
функцию MS-DOS, номер которой определяется содержимым регистра
AL. Если же регистр AL содержит другое значение, кроме приведенных
выше, функция просто сбрасывает содержимое буфера и не выполняет
никаких других действий.
<P>
Эту функцию удобно использовать тогда, когда перед вводом символа
необходимо убедиться в том, что буфер клавиатуры пуст.
<H2><A NAME="ch2_6">2.6. Клавиатурные функции библиотеки Microsoft
C</A></H2>
<P>
Стандартные библиотеки трансляторов Microsoft QuickC и C 6.0 содержат
набор функций, предназначенных для работы с клавиатурой. Эти функции
повторяют и немного дополняют возможности функций MS-DOS и BIOS,
обслуживающих клавиатуру.
<P>
Самые простые из них - getch() и getche(). Они описаны в файле
conio.h.
<P>
Функция getch() имеет следующий прототип:
<PRE>
<FONT COLOR=#000080>int getch(void);

</FONT>
</PRE>
<P>
Эта функция возвращает ASCII-код прочитанного из клавиатурного
буфера символа, причем прочитанный символ не отображается на экране.
Если была нажата функциональная клавиша или клавиша перемещения
курсора, функция возвращает 0. В этом случае функцию надо вызвать
еще раз для получения расширенного ASCII-кода нажатой клавиши.
<P>
Функция обрабатывает клавиши Ctrl-С и Ctrl-Break - при вводе этих
комбинаций клавиш работа программы завершается.
<P>
Если клавиатурный буфер пуст, программа переводится в состояние
ожидания.
<P>
Функция getche() полностью аналогична функции getch(), за исключением
того, что прочитанный символ отображается на экране. Приведем
прототип функции getche():
<PRE>
<FONT COLOR=#000080>int getche(void);

</FONT>
</PRE>
<P>
Приведем пример программы, отображающей на экране ASCII-коды и
расширенные ASCII-коды нажимаемых клавиш:
<PRE>
<FONT COLOR=#000080>#include &lt;conio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;

void main() {
         int key;


// Читаем в цикле символы с клавиатуры и отображаем
// ASCII-коды нажатых клавиш.
// Выходим из цикла при нажатии не клавишу ESC

         for(;;) {

// Читаем символ

                  key = getch();

// Если прочитанный символ равен 0, вызываем функцию getch()
// для получения расширенного ASCII-кода нажатой клавиши

                  if( (key == 0) || (key == 0xe0) ) {
                                key = getch();
                                printf( &quot;Расширенный ASCII-код:\t&quot; );
                  }

                  else printf( &quot;ASCII-код:\t&quot;);

                  printf(&quot;%d\n&quot;,key);

// При нажатии на клавишу ESC выходим из цикла

                  if( key == 27) break;
         }
}

</FONT>
</PRE>
<P>
Для проверки буфера клавиатуры на наличие символов можно использовать
функцию kbhit(). Она также описана в файле conio.h:
<PRE>
<FONT COLOR=#000080>int kbhit(void);

</FONT>
</PRE>
<P>
Если буфер клавиатуры не пуст, функция возвращает ненулевое значение.
В этом случае программа может прочитать символы из буфера клавиатуры
при помощи фукнкций getch() и getche(). Если буфер клавиатуры
пуст, функция возвращает нулевое значение.
<P>
Приведем пример программы, ожидающей нажатия на любую клавишу.
Во время ожидания программа выводит на экран поочередно символы
&quot;&lt;&quot; и &quot;&gt;&quot;:
<PRE>
<FONT COLOR=#000080>#include &lt;conio.h&gt;

void main() {

        int key;

// Ожидаем нажатия на любую клавишу.
// Во время ожидания выводим на экран поочередно
// символы &quot;&lt;&quot; и &quot;&gt;&quot;

        while(!kbhit()) printf(&quot;&lt;\b&gt;\b&quot;);

// Как только будет нажата какая-нибудь клавиша,
// выводим ее ASCII-код

                  key = getch();

// Если прочитанный символ равен 0, вызываем функцию getch()
// для получения расширенного ASCII-кода нажатой клавиши

                  if( (key == 0) || (key == 0xe0) ) {
                                key = getch();
                                printf( &quot;Расширенный ASCII-код:\t&quot; );
                  }

                  else printf( &quot;ASCII-код:\t&quot;);

                  printf(&quot;%d\n&quot;,key);
}

</FONT>
</PRE>
<P>
Для ввода с клавиатуры строки символов можно использовать функцию
cgets(), работающую аналогично функции 0Ah прерывания MS-DOS INT&nbsp;21h:
<PRE>
<FONT COLOR=#000080>char *cgets(char *buffer);

</FONT>
</PRE>
<P>
Функция описана в файле conio.h.
<P>
Перед вызовом аргумент функции buffer должен указывать на массив,
размер которого должен быть достаточным для хранения вводимой
строки, завершающего строку нулевого байта и двух дополнительных
байтов. Первый элемент массива buffer[0] должен содержать максимальную
длину вводимой строки - как и для функции 0Ah прерывания MS-DOS
INT&nbsp;21h.
<P>
После завершения ввода второй элемент массива buffer[1] будет
содержать длину введенной строки, сама строка будет завершаться
символами новой строки NL, перевода строки LF и нулем.
<P>
Функция cgets() возвращает указатель на начало введенной строки
в буфере, т.е. на третий элемент массива buffer[2].
<P>
Приведем простой пример, в котором функция cgets() используется
для ввода целого числа:
<PRE>
<FONT COLOR=#000080>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;conio.h&gt;

#define MAX 80


char buf[MAX];

void main() {
        int     i;
        char    *bufptr;

// Устанавливаем максимально допустимую длину строки

        buf[0] = MAX + 2;

        printf(&quot;\nВведите целое число: &quot;);

// Вводим число, можно использовать клавиши редактирования

        bufptr = cgets(buf);

// Преобразуем введенное число к формату int
// и выводим его

        i = atoi(bufptr);
        printf(&quot;\nВы ввели число %d&quot;, i);
}

</FONT>
</PRE>
<P>
Существует и более удобная для использования функция, позволяющая
вводить строку с клавиатуры, а точнее, из стандартного потока
ввода. Это функция gets():
<PRE>
<FONT COLOR=#000080>char *gets(char *buffer);

</FONT>
</PRE>
<P>
Функция gets() описана в файле stdio.h.
<P>
Эта функция читает строку из стандартного потока ввода stdin и
запоминает ее в буфере buffer. Символ новой строки \n в конце
введенной строки функция заменяет на ноль.
<P>
После завершения ввода функция возвращает указатель на заполненный
буфер или NULL в случае ошибки или условия &quot;Конец файла&quot;.
<P>
Обратим ваше внимание на отличия между функциями cgets() и gets():
<UL>
<LI>Функция cgets() позволяет редактировать вводимую строку символов,
функция gets() просто записывает в буфер все символы подряд (в
том числе и коды клавиш редактирования).
<LI>Программе, использующей для ввода с клавиатуры функцию cgets(),
недоступны средства переназначения ввода операционной системы.
Если же программа использует функцию gets(), которая читает строку
из стандартного потока ввода, можно использовать средства переназначения.
<LI>Перед вызовом функции cgets() необходимо специальным образом
подготовить буфер для вводимой строки (записать в первый байт
буфера длину вводимой строки). Функция gets() не требует никакой
подготовки буфера.
</UL>
<P>
Еще одна полезная функция, которую можно использовать для ввода
с клавиатуры - scanf(). Эта функция подробно описана во всех книгах
по языку программирования Си, поэтому мы не будем ее подробно
рассматривать. Отметим только, что с помощью этой функции можно
организовать ввод чисел в заданном формате. Однако можно сначала
ввести строку при помощи функций cgets() или gets(), а уже потом
выполнять все необходимые проверки и преобразования этой строки.
</BODY>
</HTML>
