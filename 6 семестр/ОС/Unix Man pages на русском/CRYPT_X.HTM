<html>
<head>
<title>CRYPT(3X) </title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/header0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="_pic_/logo.gif" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>

<h3 align=center>CRYPT(3X) </h3>
<p align=justify><b>НАЗВАНИЕ</b><br>
crypt - функции шифровки пароля и файла
<p><b>СИНТАКСИС</b>
<pre>
	cc [flag ...] file ... -lcrypt
	
	char *crypt (key, salt)
	char *key, *salt;
	
	void setkey (key)
	char *key;
	
	void encrypt (block, flag)
	char *block;
	int flag;
	
	char *des_crypt (key, salt)
	char *key, *salt;
	
	void des_setkey (key)
	char *key;
	
	void des_encrypt (block, flag)
	char *block;
	int flag;
	
	int run_setkey (p,key)
	int p[2];
	char *key;
	
	int run_crypt (offset, buffer, count, p)
	long offset;
	char *buffer;
	unsigned int count;
	int p[2];
	
	int crypt_close (p)
	int p[2];
</pre>
<p align=justify><b>ОПИСАНИЕ</b><br>
des_crypt - это функция шифровки пароля.  Она  основана
на алгоритме шифровки перемешиванием, назначение  которого, помимо всего прочего -  затруднить  использование
аппаратных средств контекстного поиска.
<p align=justify>Аргумент key представляет собой пароль, введенный пользователем. Salt - это двухсимвольная строка, выбираемая
из множества [a-zA-Z0-9./].  Она  настраивает  алгоритм
перемешивания на один из 4096 вариантов, после чего пароль используется как ключ для циклической шифровки некоторой строковой константы. Возвращаемое значение указывает на зашифрованный пароль. Его первые два  символа
равны salt.
<p align=justify>Функции des_setkey и des_encrypt обеспечивают    доступ
(на довольно примитивном уровне) к алгоритму  перемешивания. Аргумент функции  des_setkey  -  это  символьный
массив длиной 64, содержащий только символы с  числовым
значением 0 и 1 и изображающий битовую строку. В каждой
из восьми груп по 8 символов-"битов" наименее  значащий
"бит" игнорируется. Полученный 56-битовый ключ  передается компьютеру и используется в алгоритме  перемешивания для шифровки строки block в функции des_encrypt.
<p align=justify>Аргумент функции des_encrypt - символьный массив длиной
64, содержащий только символы с числовым значением 0  и
1. Аргумент преобразуется на месте в массив того же вида, изображающий биты аргумента после применения  алгоритма перемешивания с ключом, установленным  в  функции
des_setkey. Если flag равен 0, аргумент  зашифровывается, в противном случае расшифровывается.
<p align=justify>Следует заметить, что международная версия <a href=CRYPT.htm>crypt(3X)</a> не
обеспечивает расшифровку. Международная версия входит в
состав Утилит языка программирования С, а  национальная
версия - в состав Утилит  управления  защитой.  Попытка
использовать международную версию crypt для расшифровки
вызовет сообщение об ошибке.
<p align=justify>Функции crypt, setkey и encrypt  являются  "фасадными".
Они вызывают функции des_crypt,des_setkey и des_encrypt
соответственно.
<p align=justify>Программы run_setkey и run_crypt разработаны для приложений, использующих криптографические средства  [таких,
как <a href=ED.htm>ed(1)</a> и <a href=VI.htm>vi(1)</a>], и требующих совместимости с  утилитой пользователя crypt(1). Run_setkey образует два  канала p[0] и p[1], соединяющих с crypt(1), при этом  аргумент key используется как пароль. Run_crypt  преобразует текст из открытого в зашифрованный  (и  наоборот),
обращаясь к crypt(1) через каналы p[0] и p[1]. Аргумент
offset указывает позицию относительно начала  файла,  с
которой начинается текст, заданный  аргументом  buffer;
аргумент count указывает длину  текста.  По  завершении
шифровки используется функция crypt_close,  закрывающая
каналы.
<p align=justify>Run_setkey возвращает -1, если соединение с crypt(1) не
установлено (это возможно в международной версии  UNIX,
где утилита crypt(1) недоступна). Если функции  передан
пустой ключ, возвращается 0, в остальных случаях  возвращается 1. Run_crypt возвращает -1 при неуспешном чтении или записи по каналу, образованному  run_setkey,  в
противном случае возвращается 0.
<p align=justify><b>ДИАГНОСТИКА</b><br>
В международной  версии  <a href=CRYPT.htm>crypt(3X)</a>  недопустимо  значение аргумента flag функции des_encrypt, равное  1.  Оно
вызывает сообщение об ошибке.
<p><b>СМ. ТАКЖЕ</b><br>
<a href=GETPASS.htm>getpass(3C)</a>, <a href=PASSWD.htm>passwd(4)</a>, <a href=CRYPT.htm>crypt(3C)</a>.<br>
crypt(1), <a href=LOGIN.htm>login(1)</a>, <a href=PASSWD~2.htm>passwd(1)</a> в Руководстве пользователя.
<p align=justify><b>ПРЕДОСТЕРЕЖЕНИЯ</b><br>
Возвращаемое значение функции crypt указывает на статические данные, изменяемые при каждом вызове.
ежду данными.
<p align=justify>Символ ~ в начале имени файла используется  для  ссылки
на  основной  каталог  пользователя. Если указан только
этот символ, то есть ~, он заменяется на имя  основного
каталога  пользователя,  хранящееся  в переменной home.
Если после символа ~ указано имя,  состоящее  из  букв,
цифр  и  символов  -, csh ищет пользователя с указанным
именем и подставляет его основной каталог; так,  ~guest
будет  расширено  до  /usr/guest,  а  ~guest/chmach  до
/usr/guest/chmach. Если за символом ~ идет символ,  отличный  от  буквы  и от /, или ~ появляется не в начале
слова, этот символ остается неизменным.
<p align=justify>Выражение a{b,c,d}e является сокращением  для  abe  ace
ade. При подстановке сохраняется порядок слева направо,
результаты  поиска  имен файлов сортируются отдельно на
нижнем уровне. Эта конструкция  может  быть  вложенной.
Так,  ~guest/s1/{oldls,ls}.c  будет  расширено до /usr/
guest/s1/oldls.c /usr/guest/s1/ls.c (даже если эти файлы и не существуют), если основной каталог пользователя
guest есть /usr/guest. Аналогично, ../{memo,*box} будет
расширено до ../memo ../box ../mbox (обратите внимание,
что memo не было отсортировано  вместе  с  результатами
сопоставления  с  шаблоном  *box).  Как частный случай,
конструкции {, } и { } остаются неизменными.
<p align=justify><B>Ввод/вывод</b><br>
Стандартый ввод и вывод команды может быть переназначен
следующим образом:
<dl>
<dt>&lt; имя<dd>
Открыть файл с данным именем (к имени вначале применяются подстановка переменных,  подстановка  результатов выполнения команд и генерация имен  файлов) как стандартный ввод.
<p><dt>&lt;&lt; слово<dd>
Читать с ввода csh до тех пор, пока не  встретится
строка, совпадающая со словом. К слову не применяются подстановка переменных, подстановка результатов выполнения команд  и  генерация  имен  файлов,
каждая считываемая строка сравнивается  со  словом
перед выполнением подстановок всех типов.  Если  в
слове не встречаются символы \, ", ', `, то в промежуточных строках производятся подстановки  переменных и подстановки  результатов  выполнения  команд, символ \ при этом экранирует символы $, `  и
\. В подставляемых результатах  выполнения  команд
сохраняются  все  пробелы,  табуляции  и  переводы
строк, а последний перевод строки удаляется. Получившийся текст помещается в некий временный  файл,
который передается команде в качестве стандартного
ввода.
<p><dt>> имя
<br>>! имя
<br>>& имя
<br>>!& имя<dd>
Имя файла, который будет использоваться в качестве
стандартного вывода. Если файл не  существует,  он
создается, если существует, то  очищается,  старое
содержимое при этом теряется.
<p align=justify>Если определена переменная noclobber, то файл обязан не существовать или являться байториентированным   устройством   (например,   терминалом    или
/dev/null), иначе фиксируется ошибка. Такое соглашение предохраняет от случайного  разрушения  файлов. В этом случая использование ! служит для  подавления контроля.
<p align=justify>Использование & приводит к назначению на указанный
файл не только стандартного вывода, но и стандартного протокола. Имя подвергается тем же подстановкам, что и в случае &lt; имя.
<p><dt>>> имя
<br>>>! имя
<br>>>& имя
<br>>>!& имя<dd>
Аналогично >, но с двумя отличиями: информация помещается в конец файла и, если определена переменная noclobber, то в случае отсутствия файла фиксируется ошибка, если только не использовалась форма
записи с !.
</dl>
<p align=justify>Команде передается окружение, которое было в момент запуска csh, модифицированное переназначениями  ввода/вывода  и  предыдущими командами конвейера. Так, команды,
читаемые из файла, по умолчанию не имеют доступа к этому файлу, в качестве стандартного ввода  им  передается
стандартный  ввод csh. Для использования данных из того
же файла необходимо использовать &lt;&lt;. Этот механизм позволяет использовать в конвейерах командные файлы csh  и
дает возможность csh читать со стандартного ввода с помощью блочного  ввода/вывода.  Обратите  внимание,  что
стандартный  ввод  команды,  выполняемой асинхронно, не
назначается на /dev/null, а  остается  тем  же,  что  и
стандартный ввод csh. Если это терминал, то при попытке
чтения со стандартного ввода процесс будет заблокирован
и пользователю будет выдано сообщение (см. выше Сообщения о состоянии процесса).
<p align=justify>Стандартный протокол может быть направлен туда же, куда
и стандартный вывод, с помощью |& вместо |.
<p align=justify>Выражения
Некоторые из встроенных команд (которые  будут  описаны
ниже) понимают выражения, операции в которых  сходны  с
имеющимися в языке C, с теми же приоритетами. Выражения
могут быть использованы в командах @, exit, if и while.
Имеются  следующие  операции,  перечисленные  в порядке
возрастания приоритетов:
<pre>
	||  &&  |  ^  &  ==  !=  =~  !~  &lt;=  >=  &lt;  >
	&lt;&lt;  >>  +  -  *  /  %  !  ~  ( )
</pre>
Укажем группы операций, имеющих одинаковый приоритет:
<pre>
	==  !=  =~  !~
	&lt;=  >=  &lt;  >
	&lt;&lt;  >>
	+  *  /  %
</pre>
<p align=justify>Операции ==, !=, =~ и !~ сравнивают свои аргументы  как
цепочки  символов;  все  остальные оперируют с числами.
Операции =~ и !~ похожи на != и ==, но правый операнд в
них  является  шаблоном  (содержащим,  например  *,  ?,
[...])  с  которым  сопоставляется  левый  операнд. Это
уменьшает  необходимость  в   использовании   оператора
switch в командных файлах, когда на самом деле требуется сопоставление с шаблоном.
<p align=justify>Цепочки, начинающиеся с 0, рассматриваются, как восьмеричные числа. Пустые и пропущенные аргументы рассматриваются, как 0. Результатами выражений являются  цепочки
символов, представляющие десятичные числа. Важно  отметить, что никакие два компонента выражения не могут появиться в одном слове; во всех случаях, кроме тех, когда они граничат с символами &, |, <, >, (, ) они должны
быть окружены пробелами.
<p align=justify>Операндами в выражениях могут выступать также результаты завершения команд, взятых в скобки { и  },  а  также
запросы информации о файлах в виде -отношение файл, где
отношение может быть следующим:
<table>
<tr><td>r <td>   Файл доступен на чтение.
<tr><td>w  <td>  Файл доступен на запись.
<tr><td>x  <td>  Файл доступен на выполнение.
<tr><td>e  <td>  Файл существует.
<tr><td>o  <td>  Пользователь является владельцем файла.
<tr><td>z  <td>  Файл имеет нулевой размер.
<tr><td>f  <td>  Файл является обычным.
<tr><td>d  <td>  Файл является каталогом.
</table>
<p align=justify>К указанному имени применяется подстановка  результатов
выполнения команд и генерация имен файлов, затем проверяется, верно  ли  указанное  отношение  для  реального
пользователя. Если файл не существует  или  недоступен,
все запросы возвращают ложь (0). Результатом завершения
команды будет истина (1), если  команда  завершилась  с
кодом 0, иначе возвращается ложь. Если требуется  более
детальная информация о завершении, команду следует  выполнять вне выражения и проверять код завершения.
<p align=justify><b>Передачи управления</b><br>
Csh содержит набор команд, которые могут быть использованы для передач управления внутри командных файлов, их
можно с успехом использовать и при вводе  с  терминала,
правда при этом возникают некоторые ограничения. Команды передачи управления требуют от csh повторного чтения
или пропуска файла ввода поэтому, из соображений реализации, имеются некоторые  ограничения  на  расположение
ряда подобных команд.
<p align=justify>Команды  foreach,  switch  и  while,  а   также   форма
if-then-else  команды  if  требуют, чтобы главное слово
находилось на отдельной строке, как показано ниже.
<p align=justify>Если ввод csh не является адресуемым, csh при появлении
цикла буферизует ввод и для реализации цикла адресуется
к этому  внутреннему  буферу.  (Пока  позволяет  размер
внутреннего буфера, можно выполнять передачи управления
назад и в неадресуемом вводе.)
<p align=justify><b>Встроенные команды</b><br>
Встроенные  команды  выполняются  в  рамках  csh.  Если
встроенная команда является  не  последним  компонентом
конвейера, она выполняется в порожденном процессе.
<dl>
<dt>alias
<br>alias кличка
<br>alias кличка список_слов<dd>
Первая форма выводит все клички и  соответствующие
им списки слов. Вторая печатает список слов, имеющий указанную кличку. Последняя форма  присваивает
кличку списку_слов; список_слов при этом подвергается подстановке результатов выполнения  команд  и
генерации имен файлов. В  качестве  кличек  нельзя
использовать слова alias и unalias.
<p><dt>alloc [аргумент]<dd>
Показывает размер отведенной динамической  памяти,
как занятой, так и свободной. Если  указан  произвольный аргумент, показывается количество  занятых
и свободных блоков различных размеров. Первый размер блока равен 8, каждый следующий равен  удвоенному предыдущему. Вывод этой команды  может  отличаться от описанного в  тех  системах,  в  которых
применена схема управления  памятью,  отличная  от
применяемой на компьютерах VAX.
<p><dt>break<dd>
Приводит к передаче  управления  на  конец  самого
внутреннего цикла foreach или while. Оставшиеся на
текущей строке команды тем не  менее  выполняются.
Таким образом, написание нескольких  команд  break
на одной строке может быть использовано для выхода
сразу из нескольких циклов.
<p><dt>breaksw<dd>
Приводит к выходу из переключателя (switch), передает управление за endsw.
<p><dt>case метка:<dd>
Метка условия в операторе switch, описанном ниже.
<p><dt>cd
<br>cd имя
<br>chdir
<br>chdir имя<dd>
Изменяет текущий каталог пользователя  на  указанный. Если аргумент не указан, устанавливается  основной каталог пользователя. Если  имя  в  текущем
каталоге не найдено (и не начинается с /,  ./  или
../), то поиск имени производится во  всех  компонентах значения переменной cdpath. Наконец, если и
этот поиск безуспешен, а имя является именем переменной csh, значение которой начинается с /, делается попытка установить  текущий  каталог,  равный
этому значению.
<p><dt>continue<dd>
Приводит к передаче управления  на  начало  самого
внутреннего цикла foreach или while. Оставшиеся на
текущей строке команды тем не менее выполняются.
<p><dt>default:<dd>
Помечает случай по умолчанию в  операторе  switch.
Он должен находиться после всех меток условия.
<p><dt>dirs Печатает стек каталогов; вершина стека расположена
слева, первый каталог в стеке является текущим.
<p><dt>else
<br>end
<br>endif
<br>endsw<dd>
См. ниже описания операторов foreach, if,  switch,
и while.
<p><dt>eval аргумент ...<dd>
[Аналогично <a href=SH.htm>sh(1)</a>.] Аргументы читаются,  как  если
бы они поступали со стандартного ввода, и рассматриваются как команды, которые выполняются в  текущем контексте. Обычно используется для  выполнения
команд, сгенерированных как результаты подстановки
переменных и результатов  выполнения  команд,  так
как  грамматический  разбор  выполняется  до  этих
подстановок. См. также <a href=TEST.htm>test(1)</a>.
<p><dt>exec команда
Указанная команда подменяет текущий csh.
<p><dt>exit
<br>exit(выражение)<dd>
Csh завершается либо с кодом, хранящемся  в  переменной status (первая форма) либо с кодом,  равным
значению выражения (вторая форма).
<p><dt>foreach имя (список_слов)
<br>    ...
<br>end<dd>
Переменной имя последовательно  присваиваются  все
слова из списка_слов и каждый раз выполняется последовательность команд между  foreach  и  end.  (И
foreach, и end должны быть единственными командами
на своих строках.) Встроенная команда continue может быть использована для принудительного перехода
к следующей итерации, а встроенная команда   break
- для   принудительного   завершения  цикла.  Если
foreach вводится с терминала, все тело цикла  сначала считывается с приглашением ?, а затем начинается выполнение цикла.
<p><dt>glob список_слов<dd>
Аналогично  <a href=ECHO.htm>echo(1)</a>, но управляющие последовательности, заданные как \0n,  не  интерпретируются,  и
слова при выводе разделяются пустыми символами (то
есть  символами  с  нулевым кодом), что удобно для
программ, которые хотят использовать csh для генерации имен файлов из списка слов.
<p><dt>goto слово<dd>
Указанное слово подвергается подстановке результатов выполнения команд  и  генерации  имен  файлов.
Формируется цепочка символов  метка.  Csh  ищет  в
предыдущем вводе строку формата метка:,  возможно,
начинающуюся с пробелов  и  табуляций.  Выполнение
продолжается после найденной строки.
<p><dt>history
<br>history n
<br>history -r n
<br>history -h n<dd>
Показывает список команд из протокола; если указано n, показываются последние n  команд.  Опция  -r
инвертирует порядок вывода команд, первыми показываются самые последние команды. Опция -h  приводит
к печати команд без их номеров. Это  используется,
чтобы сделать файл для команды source -h.
<p><dt>if (выражение) команда<dd>
Если указанное выражение истинно, выполняется  команда  (со  своими аргументами). Подстановка переменных в команду if производится  рано,  тогда  же
происходит подстановка и в команду. Команда должна
быть  простой,  не  допускаются  ни  конвейеры, ни
списки команд, ни списки команд в скобках. Обратите внимание: переназначение ввода/вывода осуществляется даже если выражение ложно, то есть  команда
не выполняется.
<p><dt>if (выражение) then
<br> ...
<br>else if (выражение2) then
<br> ...
<br>else
<br> ...
<br>endif<dd>
Если указанное выражение истинно,  то  выполняются
команды до первого else; иначе если выражение2 истинно, выполняются команды до второго else и  т.д.
Допустимо любое количество пар else-if;  требуется
ровно один endif. Часть else может  быть  опущена.
(Слова else и endif  должны  появляться  в  начале
строк; конструкция if-then  должна  быть  одна  на
строке или после else.)
<p><dt>jobs
<br>jobs -l<dd>
Выводит активные задания; опция -l добавляет к информации идентификаторы процессов.
<p><dt>kill %задание
<br>kill -сигнал %задание ...
<br>kill идентификатор_процесса
<br>kill -сигнал идентификатор_процесса ...
<br>kill -l<dd>
Посылает сигнал завершения (15) или указанный сигнал  указанным заданиям или процессам. Сигналы задаются номером или названием (как указано во включаемом файле &lt;sys/signal.h>, только без  приставки
SIG).  Названия  сигналов  выводятся по kill -l. В
этой команде нет умолчания, то есть просто kill не
посылает сигнала текущему заданию.
<p><dt>login<dd>
Завершить   "входной"   csh,   заменив   его    на
/bin/login. Это один из способов закончить работу,
сделанный для совместимости с <a href=SH.htm>sh(1)</a>.
<p><dt>logout
Завершить "входной" csh. Используется, если  установлена переменная ignoreeof.
<p><dt>notify
<br>notify %задание ...<dd>
Информировать пользователя асинхронно,  сразу  же,
как изменится состояние  текущего  или  указанного
заданий; обычно информация выдается перед  приглашением. Информация всегда выдается асинхронно, если установлена переменная notify.
<p><dt>onintr
<br>onintr onintr метка<dd>
Управляет действиями при прерываниях. Первая форма
восстанавливает  действия  по  умолчанию,  которые
заключаются в завершении выполнения командных файлов и возврате на уровень ввода команд с  терминала.  Вторая  форма onintr приводит к игнорированию
всех прерываний. Последняя форма приводит к выполнению команды goto метка при получении  прерывания
или  завершении по прерыванию порожденного процесса.
<p align=justify>В любом случае, если csh запущен асинхронно и прерывания уже игнорируются, все формы onintr не имеют смысла и прерывания  продолжают  игнорироваться
как в csh, так и во всех запускаемых командах.
<p><dt>popd
<br>popd +n<dd>
Вытолкнуть элемент из стека каталогов,  перейдя  к
новому каталогу. С аргументом +n удаляет n-ый элемент стека. Элементы стека нумеруются от  вершины,
начиная с 0.
<p><dt>pushd
<br>pushd имя
<br>pushd +n<dd>
Без аргументов pushd меняет два  верхних  элемента
стека каталогов. Если аргумент указан, pushd изменяет текущий каталог (как cd)  и  помещает  старый
текущий каталог (из переменной cwd) в стек каталогов. С числовым аргументом, извлекает  n-ый  аргумент стека каталогов, помещает его на вершину стека и устанавливает его в качестве текущего каталога. Элементы стека нумеруются от вершины,  начиная
с 0.
<p><dt>rehash<dd>
Переустановить внутреннюю хэш-таблицу  содержимого
каталогов, содержащихся  в  переменной  path.  Это
требуется, если в эти каталоги добавлены новые команды после того, как  был  запущен  csh.  Команду
rehash необходимо выполнить, если Вы добавили  какую-нибудь команду в свой  каталог  или  системный
программист изменил содержимое  системных  каталогов.
<p><dt>repeat число команда<dd>
Команда, к которой применимы  те  же  ограничения,
что и в команде оператора if (см. выше),  выполняется заданное число раз. Переназначение  ввода/вывода осуществляется ровно один раз,  включая  случай, когда число равно 0.
<p><dt>set
<br>set имя
<br>set имя=слово
<br>set имя[индекс]=слово
<br>set имя=(список_слов)<dd>
Первая форма команды показывает значения всех  переменных csh. Значения, размер которых более одного слова, заключаются в скобки. Вторая форма присваивает переменной пустую  цепочку.  Третья  форма
присваивает переменной одно слово. Четвертая форма
заменяет значение указанного компонента; этот компонент обязан существовать. Последняя форма  присваивает переменной список слов. Во всех случаях  к
значению применяется подстановка  результатов  выполнения команд и генерация имен файлов.
<p align=justify>Аргументы могут повторяться, позволяя одной командой set изменить значения  нескольких  переменных.
Отметим, что подстановка значений переменных  производится для всех аргументов до выполнения  присваиваний.
<p><dt>setenv
<br>setenv имя
<br>setenv имя значение<dd>
Первая форма выводит текущие значения  всех  переменных окружения. Последняя форма присваивает значение   (цепочку  символов)  переменной окружения.
Вторая форма присваивает переменной окружения пустую цепочку. Наиболее часто используемые  переменные  окружения USER, TERM и PATH автоматически импортируются  и  экспортируются  из  csh-переменных
user,  term,  и  path соответственно; использовать
для них setenv не нужно.
<p><dt>shift
<br>shift переменная<dd>
Слова, составляющие значение переменной argv сдвигаются влево, удаляя argv[1]. Если  значение  argv
не  определено или имеет в качестве значения менее
одного слова, фиксируется ошибка. Вторая форма выполняет те же действия над указанной переменной.
<p><dt>source имя
<br>source -h имя<dd>
Csh читает команды из файла  имя.  Команды  source
могут быть вложены, однако слишком большая вложенность может  привести  к  исчерпанию  дескрипторов
файлов в csh. Ошибка на любом  уровне  вложенности
прерывает сразу все команды source. Обычно  вводимые по source команды не  помещаются  в  протокол,
опция -h вызывает помещение команд в протокол  без
выполнения.
<p><dt>switch (цепочка)
<br>case метка1:
<br>    ...
<br>  breaksw
<br>...
<br>default:
<br>    ...
<br>  breaksw
<br>endsw<dd>
Каждая метка условия сопоставляется с цепочкой,  к
которой применяется подстановка результатов выполнения команд и генерация имен файлов. В метке  условия могут использоваться символы *, ? и [...], к
меткам применяется подстановка  значений  переменных. Если ни одна из меток условий не соответствует цепочке, выполнение  продолжается  после  метки
default. Каждая метка условия, в том  числе  метка
default, должна располагаться с начала строки. Команда breaksw приводит к  передаче  управления  за
endsw. Иначе управление  проходит  по  последующим
меткам (как в языке C). Если ни одна из меток  условий не соответствует цепочке,  а  метка  default
отсутствует, управление передается за endsw.
<p><dt>umask
umask значение<dd>
Маска режима  создания  файлов  выводится  (первая
форма) или устанавливается (вторая  форма).  Маска
задается восьмеричными цифрами.  Обычные  значения
маски 002 (дает все права доступа группе и  доступ
на чтение и выполение остальным) или 022,  (дающий
все права, кроме записи, всем пользователям).
<p><dt>unalias шаблон
Все клички, имена которых соответствуют указанному
шаблону, удаляются. Так, командой unalias * удаляются вообще все  клички.  Ситуация,  когда  нечего
удалять, ошибкой не считается.
<p><dt>unhash<dd>
Запретить использование внутренней хэш-таблицы для
ускорения поиска выполняемых программ.
<p><dt>unset шаблон<dd>
Все переменные, имена которых  соответствуют  указанному шаблону, удаляются. Так, командой unset  *
удаляются вообще все переменные;  это  приводит  к
очень неприятным последствиям. Ситуация, когда нечего удалять, ошибкой не считается.
<p><dt>unsetenv шаблон<dd>
Все переменные, имена которых  соответствуют  указанному шаблону, удаляются из окружения. См. также
выше команду setenv.
<p><dt>wait <dd>Ожидание завершения всех фоновых  процессов.  Если
csh интерактивный, то по прерыванию ожидание прекращается, а csh печатает имена и номера всех заданий.
<p><dt>while (выражение)
<br>    ...
<br>end<dd>
Пока  вычисление  выражения дает ненулевой результат, выполняются команды между while  и  end.  Для
принудительного  завершения  цикла  или перехода к
следующей  итерации  можно  использовать   команды
break  и  continue.  И  while,  и  end должны быть
единственными командами на своих строках. При вводе цикла с терминала происходит то  же,  что  и  в
случае цикла foreach.
<p><dt>@
<br>@ имя = выражение
<br>@ имя[индекс] = выражение<dd>
Первая форма  печатает  значения  всех  переменных
csh. Вторая форма присваивает переменной  значение
выражения. Если выражение содержит знаки  операций
&lt;, >, & или |, то они должны обязательно оказаться
внутри скобок ( ). Третья форма заменяет  значение
указанного компонента; этот компонент  обязан  существовать.
</dl>
<p align=justify>Как и в языке C, доступны операции *=, +=  и  т.д.
Отделять имя от знака = пробелом  не  обязательно.
Пробелы, однако, обязательно должны разделять компоненты выражения, иначе  они  будут  трактоваться
как одно слово.
<p align=justify>Специальные постфиксные операторы ++  и  --  соответственно  увеличивают и уменьшают значения переменной, например @ i++.
<p align=justify>Предопределенные переменные и переменные окружения
Следующие переменные имеют для csh  специальное  значение. Переменные argv, cwd, home, path, prompt, shell  и
status при инициалиализации устанавливаются всегда. Переменные cwd и status изменяются автоматически, остальные - только по указанию пользователя.
<p align=justify>Csh копирует значение переменной окружения USER в  свою
переменную user, TERM - в term и HOME - в home, при изменении значения этих переменных csh  производится  обратное копирование. То же происходит с переменной окружения PATH; не надо все время заботиться о присваивании
этих  переменных,  достаточно  их  определить  в  файле
.cshrc; порожденные процессы импортируют значение  path
из окружения и реэкспортируют его в случае изменения.
<p align=justify>Итак, опишем значения специальных переменных csh.
<dl>
argv <dd>Значение этой  переменной  устанавливается  равным
значению аргументов запуска csh.  Именно  из  этой
переменной  подставляются  позиционные  параметры,
то есть $1 заменяется на $argv[1] и т.д.
<p><dt>cdpath<dd>
Список каталогов,  в  которых  производится  поиск
подкаталогов командой chdir.
<p><dt>cwd <dd> Полное маршрутное имя текущего каталога.
<p><dt>echo <dd>Устанавливается, если при вызове csh указана опция
-x. Вызывает выдачу каждой команды перед  выполнением. Для невстроенных команд все подстановки производятся перед выдачей. Встроенные команды  выдаются перед применением подстановок результатов выполнения команд и генерацией имен файлов, так  как эти подстановки проводятся затем избирательно.
<p><dt>histchars<dd>
Этой переменной можно присвоить  цепочку  из  двух
символов, которые задают подстановки из протокола.
Первый символ замещает используемый  по  умолчанию
символ !. Второй символ замещает символ ^ в  быстрых подстановках.
<p><dt>history<dd>
Может быть задано числовое  значение,  управляющее
размером протокола. Слишком большое значение может
привести к переполнению памяти.  Последняя  выполненная команда всегда сохраняется в протоколе.
<p><dt>home <dd>Основной каталог пользователя, инициализируемый из
окружения. Символ ~ при генерации имен файлов ссылается на эту переменную.
<p><dt>ignoreeof<dd>
Если значение этой переменной установлено, то  csh
игнорирует конец файла для вводных  устройств-терминалов. Это предохраняет от случайного завершения
csh с помощью CTRL+D.
<p><dt>mail <dd>Имена файлов, в которых csh ищет письма. Поиск писем производится с некоторым временным  интервалом
перед выдачей приглашения после завершения команд.
Если найден файл, имеющий  время  доступа  меньшее
или равное времени модификации, выдается сообщение
You have new mail.
<p align=justify>Если первое слово значения переменной mail является числом, оно задает интервал опроса писем, в секундах. Значение по умолчанию равно 10 минутам.
<p align=justify>Если указано несколько файлов для поиска,  сообщение будет выглядеть, как New  mail  in  имя_файла,
если письмо обнаружено в файле имя_файла.
<p><dt>noclobber<dd>
Как уже упоминалось в разделе "Ввод/вывод", на переназначение вывода накладываются ограничения, дающие гарантию, что файлы не будут случайно  разрушены и что >> ссылаются на существующие файлы.
<p><dt>notify<dd>
Если эта переменная  установлена,  csh  асинхронно
информирует о завершениях  заданий.  По  умолчанию
информация выдается перед приглашением.
<p><dt>path <dd>Каждое слово переменной path задает каталог, в котором ищутся команды для выполнения. Пустое  слово
означает текущий каталог. Если переменная path  не
определена, все маршрутные имена должны быть  полными. Обычное значение для переменной path  -  это
., /bin и /usr/bin, но  в  разных  системах  могут
быть разные соглашения. Для суперпользователя список поиска по умолчанию - /etc, /bin  и  /usr/bin.
Если при запуске csh не указаны опции -c и -t, содержимое каталогов из переменной  path  хешируется
после чтения файла .cshrc и при  каждом  изменении
переменной path. Если в указанные каталоги  добавляются новые команды, требуется выполнить  rehash,
иначе команды могут быть не найдены.
<p><dt>prompt<dd>
Цепочка символов (приглашение), которая  выводится
перед каждым чтением команд с терминального ввода.
Если в цепочке появляется символ !, он будет заменен на текущий номер команды (если он не экранирован предшествующим \). Значения по умолчанию: "% "
для  обычного пользователя и "# " для суперпользователя.
<p><dt>savehist<dd>
Задаваемое числовое значение управляет количеством
элементов протокола, которые сохраняются  в  файле
~/.history, когда пользователь выходит из системы.
Все команды, на которые были ссылки  из  этих  команд, также сохраняются. При запуске csh  помещает
файл ~/.history  в  протокол  (аналогично  команде
source), позволяя сохранять протокол между сеансами. Слишком большие значения  переменной  savehist
замедляют запуск csh.
<p><dt>shell<dd>
Файл, в котором находится  shell.  Используется  в
порожденных процессах для интерпретации файлов,  у
которых установлен бит выполнения, но которые  являются для системы неисполняемыми. (См. ниже  описание выполнения внешних команд.) Инициализируется
в (зависящий от системы) файл, хранящий csh.
<p><dt>status<dd>
Код завершения последней команды. Если она  завершилась аварийно, к коду добавляется 128.  Встроенные команды при аварийном завершении возвращают 1,
при нормальном - 0.
<p><dt>verbose<dd>
Устанавливается опцией -v при запуске csh; вызывает печать каждой команды после завершения  подстановок из протокола.
</dl>
<p align=justify><b>Выполнение внешних команд</b><br>
Если сгенерированная для выполнения команда оказывается
не внутренней, csh  пытается  выполнить  ее  с  помощью
execve(2). Каждое слово переменной path обозначает  каталог, из которого csh пытается выполнить команду. Если
при запуске не указаны опции -c и -t, csh хеширует  содержимое каталогов из переменной path, поэтому  попытка
выполнения делается только для  имеющихся  команд,  что
сильно ускоряет поиск выполняемой команды, если  список
поиска очень длинный. Если этот  механизм  выключен  (с
помощью unhash), или если при запуске не указаны  опции
-c или -t, а также во всех случаях для каждой компоненты переменной path, которая не начинается с символа  /,
csh конкатенирует компоненту  path  с  именем  команды,
формируя маршрутное имя файла, и пытается этот файл выполнить.
<p align=justify>Команды, заключенные в скобки, всегда выполняются в порожденном процессе. Так, (cd; pwd); pwd печатает основной каталог пользователя, оставляя текущий каталог  неизменным и печатая его вслед за основным, а cd; pwd делает текущим основной  каталог  пользователя.  Команды,
заключенные в скобки, обычно используются,  чтобы  предохранить текущий csh от  изменения  текущего  каталога
командами chdir.
<p align=justify>Если к файлу есть права доступа на выполнение, но он не
является двоичным выполняемым файлом, то  предполагается, что это командный файл и для его чтения запускается
новый csh.
<p align=justify>Если слово shell является кличкой,  то  соответствующие
ей слова при формировании команды будут подставлены перед списком аргументов. Первое слово  при  этом  должно
быть полным маршрутным именем командного интерпретатора
(например, $shell). Обратите внимание, что  это  специальный случай подстановки клички,  который  выполняется
очень поздно и позволяет только подставить слова  перед
списком аргументов без всякой модификации.
<p align=justify><b>Обработка аргументов</b><br>
Если аргумент 0 csh равен -, то  csh  считается  "входным". Опции интерпретируются следующим образом:
<table>
<tr valign=top><th>-b <td>  Вызывает прерывание процесса обработки опций,  оставшиеся аргументы не  будут  обрабатываться,  как
опции. Используется для передачи опций  командному
файлу, без опасения, что их обработает запускаемый
csh.
<tr valign=top><th>-c <td>  Команды читаются из (одного) файла,  имя  которого
следует за -c и обязано  присутствовать.  Все  остальные аргументы помещаются в переменную argv.
<tr valign=top><th>-e <td>  Csh завершается, если хотя бы одна из  команд  завершается аварийно или выдает ненулевой код завершения.
<tr valign=top><th>-f <td>  Более  быстрый запуск csh, без поиска и выполнения
файла .cshrc из основного каталога пользователя.
<tr valign=top><th>-i <td>  Csh является  интерактивным  и  выдает  на верхнем
уровне  приглашения, даже если стандартный ввод не
является терминалом. Без этой опции  csh  является
интерактивным,  только  если  стандартный  ввод  и
стандартный вывод назначены на терминал.
<tr valign=top><th>-n <td>  Происходит грамматический разбор команд,  без  выполнения. Эта опция используется для  синтаксической проверки командных файлов.
<tr valign=top><th>-s  <td> Исходная информация для команд  берется  со  стандартного ввода.
<tr valign=top><th>-t  <td> Из файла ввода считывается и выполняется ровно одна строка. В ней может использоваться символ \ для
экранирования перевода строки и продолжения команды на следующей строке.
<tr valign=top><th>-v <td>  Устанавливает переменную verbose; вызывает  печать
каждой команды  после  завершения  подстановок  из
протокола.
<tr valign=top><th>-x  <td> Устанавливает  переменную  echo.  Вызывает  выдачу
каждой команды перед выполнением.
<tr valign=top><th>-V <td>  Устанавливает  переменную  verbose  до  выполнения
файла .cshrc.
<tr valign=top><th>-X <td>  То же для -x, что -V для -v.
</table>
<p align=justify>После обработки опций, если остались еще аргументы и не
было опций -c, -i, -s, или -t, первый из оставшихся аргументов берется в качестве имени файла с  выполняемыми
командами.  Csh  открывает  этот файл, сохраняя его имя
для возможной последующей подстановки  вместо  $0.  Так
как  многие  системы  используют стандартный shell, командные файлы которого несовместимы с csh, то csh будет
выполнять стандартный shell, если первый символ командного файла не есть #, то есть если командый файл не начинается с комментария. Оставшиеся аргументы  инициализируют переменную argv.
<p align=justify><b>Обработка сигналов</b><br>
Обычно csh игнорирует сигналы выхода (3). Задания,  запущенные асинхронно, не получают  сигналов,  сгенерированных с клавиатуры, в том числе сигнал 1.  Реакция  на
остальные сигналы наследуется от родительского  процесса. Обработка прерываний и сигналов  завершения  в  командных файлах управляется командой  onintr.  "Входной"
csh перехватывает сигнал завершения, остальные передают
реакцию на него порожденным процессам в том же  состоянии, что получили от родителей. В любом случае прерывания запрещены  во  время  чтения  "входным"  csh  файла
.logout.
<p align=justify><b>ФАЙЛЫ</b><br>
<pre>
	~/.cshrc     Читается в начале выполнения каждым csh.
	~/.login     Читается  "входным"   csh   после   чтения
	             .cshrc.
	~/.logout    Читается  "входным" csh при завершении.
	/bin/sh      Стандартный shell для командных файлов, не
	             начинающихся с #.
	/tmp/sh*     Временные файлы для <<.
	/etc/passwd  Источник информации об основных  каталогах
	             пользователей для подстановки ~имя_файла.
</pre>
<p align=justify><b>ОГРАНИЧЕНИЯ</b><br>
Слова не могут быть длиннее 1024 символов. Система  ограничивает список аргументов 10240 символами. Число аргументов в команде,  к  которой  применяется  генерация
имен файлов, ограничено 1/6 от числа символов, допустимых в списке аргументов. Подстановка результатов выполнения команд не может подставить больше  символов,  чем
допустимо в списке аргументов. Для обнаружения зацикливания csh ограничивает число подстановок вместо  кличек
в одной строке двадцатью.
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/footer0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table>
</body>
</html>
