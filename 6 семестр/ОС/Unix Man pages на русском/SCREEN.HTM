<html>
<head>
<title>SCREEN(HW)</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/header0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="_pic_/logo.gif" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>

<h3 align=center>SCREEN(HW)</h3>
<p align=justify><b>НАЗВАНИЕ</b><br>
screen - файлы tty[01-n], color, monochrome, ega, vga
 - адаптер дисплея и видеомонитор.
<p align=justify><b>ОПИСАНИЕ</b><br>
Файлы устройств tty[01-n] обоеспечивают символьный ввод/вывод между
системой,  дисплеем  видеомонитора  и  клавиатурой.  Каждый из этих
файлов   соответствует   отдельному   устройству   телетайпа.  Хотя
количество экранов  ограничивается 12,  точное число  (n) доступных
экранов зависит  от объема  памяти компьютера.  По умолчанию экраны
устанавливаются в режим терминала ASCII 80x25.
<p align=justify>
Сообщения  ядра  системы  об  ошибках  записываются в /dev/console,
обычно  соответствующему  текущему  экрану.  Если  по умолчанию для
записи системных сообщений об ошибках установлено устройство вывода
/dev/console,  и  используемый  экран  переключается  в графический
режим,  то   сообщения  на   консоли  не   высвечиваются.     Когда
видеоустройство возвращается  в текстовый  режим, то  высвечивается
соответствующее  информационное  сообщение,  а  текст  сообщений об
ошибках может быть восстановлен из файла /usr/adm/messages.
<p align=justify>
Хотя  все  устройства  tty[01-n]  могут  быть открыты одновременно,
только одно из  них может быть  активным в данный  момент. Активное
устройство   формирует   свой   экран   и   перехватывает  на  себя
управление клавиатурой.  Будет ошибкой  пытаться получить  доступ к
файлам color, monochrome или ega, если отсутствует  соответствующий
адаптер или нет связанного с ним экрана в многоэкранном режиме.
<p align=justify>
Для  переключения  на  следующий  экран  введите  код  Ctrl-PrtSc с
помощью клавиш Ctrl и PrtSc. Любой активный экран может быть выбран
введением  кода  alt-Fn,  где  Fn  - одна из функциональных клавиш.
Например, F1 относится к устройству tty01.
<p align=justify><i>Режимы управления</i><br>
Для  изменения   режима  дисплея   видеомонитора  откройте    файл,
соответствующий этому режиму. Например, для переключения выдачи  на
дисплей CGA программа должна открыть файл /dev/color и использовать
отображение  селектора  ioctl  s,  возвращенного  после вызова open
(команды  открытия),  на  файловый  дескриптор.  Применение  файлов
устройств поможет обеспечить программную совместимость  в будущем.
<p align=justify>
Экраны могут быть назначены различным адаптерам (в многоадаптерных
системах) с использованием следующих ioctl s:
<dl>
<dt>SWAPMONO
<dd>Выбирает   монохромный   дисплей   в    качестве устройства вывода видеомонитора.
<dt>SWAPCGA
<dd>Выбирает регулярный  цветной дисплей  в качестве устройства вывода видеомонитора.
<dt>SWAPEGA
<dd>Выбирает улучшенный  цветной дисплей  в качестве устройства вывода видеомонитора.
<dt>SWAPVGA
<dd>Выбирает    видеографический  растровый  цветной
дисплей    в    качестве    устройства    вывода
видеомонитора.
</dl><p align=justify>
Чтобы  узнать  какой  тип  адаптера  дисплея  в  настоящий   момент
присоединен  к  видеомонитору,  вы  можете использовать ioctl(2) со
следующим параметром:
<dl>
<dt>CONS_CURRENT
<dd>Возвращает тип адаптера дисплея  присоединенного
в текущий момент к видеомонитору: MONO, CGA, EGA или VGA.
</dl>
<p align=justify><i>Режимы дисплея</i><br>
Для изменения  видеорежима дисплея  могут использоваться  следующие
селекторы ioctl s:
<dl>
<dt>SW_B80x25
<dd>Выбирает чернобелый текстовый режим 80x25 (MONO,
CGA, EGA, VGA).
<dt>SW_C80x25
<dd>Выбирает цветной текстовый режим 80x25 ( CGA,
EGA, VGA).
<dt>SW_BG320
<dd>Выбирает чернобелый графический режим 320x200
(CGA, EGA, VGA).
<dt>SW_CG320
<dd>Выбирает цветной графический режим 320x200
( CGA, EGA, VGA).
<dt>SW_BG640
<dd>Выбирает чернобелый графический режим 640x200
( CGA, EGA, VGA).
<dt>SW_EGAMONO80x25
<dd>Выбирает режим EGA 7 - эмулирует поддержку,
предоставляемую монохромным дисплеем.(EGA, VGA).
<dt>SW_EGAMONOAPA
<dd>Выбирает графический режим EGA F 640x350. (EGA с
мнохромным монитором.)
<dt>SW_ENHMONOAPA2
<dd>Выбирает режим EGA F* (EGA с монохромным
монитором).
<dt>SW_ENHB40x25
<dd>Выбирает черно-белый текстовый режим 40x25 EGA.
(EGA, VGA).
<dt>SW_ENHC40x25
<dd>Выбирает цветной текстовый режим 40x25 EGA.
(EGA, VGA).
<dt>SW_ENHB80x25
<dd>Выбирает черно-белый текстовый режим 80x25 EGA.
(EGA, VGA).
<dt>SW_ENHC80x25
<dd>Выбирает цветной текстовый режим 80x25 EGA.
(EGA, VGA).
<dt>SW_CG320_D
<dd>Выбирает графический режим EGA 320x200 (режим
EGA D.) (EGA, VGA).
<dt>SW_CG640_E
<dd>Выбирает графический режим EGA 640x200 (режим
EGA E.) (EGA, VGA).
<dt>SW_CG640x350
<dd>Выбирает графический режим EGA 640X350 (режим
EGA 10.) (EGA, VGA).
<dt>SW_ENH_CG640
<dd>Выбирает графический режим EGA 10*. (EGA, VGA).
<dt>SW_MCAMODE
<dd>Инициализирует монохромный адаптер .(MONO).
<dt>SW_VGA40x25
<dd>Выбирает цветной режим VGA 40X25 (режим VGA
1+). (VGA).
<dt>SW_VGA80x25
<dd>Выбирает чернобелый режим VGA 80X25 (режим VGA
2+). (VGA).
<dt>SW_VGAM80x25
<dd>Выбирает режим VGA 7+ - эмулирует поддержку,
предоставляемую монохромным дисплеем. (VGA с
мнохромным монитором.)
<dt>SW_VGA11
<dd>Выбирает графический режим VGA 640x480 (режим
VGA 11.) (VGA).
<dt>SW_VGA12
<dd>Выбирает графический режим VGA 640x480 (режим
VGA 12.) (VGA).
<dt>SW_VGA13
<dd>Выбирает графический режим VGA 320x200 (режим
VGA 13.) (VGA).
</dl>
<p>Попытка  переключения  в   режим,  не  соответствующий   устройству дисплея, повлечет ошибку.
<p align=justify><i>Получение информации о режиме дисплея</i><br>
Следующие  запросы  ioctl()  обеспечивают  получение  информации  о
текущем режиме дисплея:
<dl>
<dt>CONS_GET
<dd>Возвращает текущий режим дисплея, установленный
для текущего адаптера дисплея.  (Все типы.)
<dt>CGA_GET
<dd>Возвращает текущий режим дисплея, установленный
 для графического адаптера дисплея. (Только
CGA.)
<dt>EGA_GET
<dd>Возвращает текущий режим дисплея, установленный
для улучшенного графического адаптера дисплея.
(Только EGA.)
<dt>MCA_GET
<dd>Возвращает текущий режим дисплея, установленный
 для монохромного адаптера дисплея. (Только
MONO.)
<dt>VGA_GET
<dd>Возвращает текущий режим дисплея, установленный
для видеографического растрового адаптера
дисплея.  (Только VGA.)
</dl>
<p align=justify><i>Режимы отображения памяти</i><br>
Процедура  ioctl(2)  используется  для  отображения  памяти дисплея
различных  устройств  в  область  данных  пользователя.  На 20286-х
машинах ioctl() возвращает селектор памяти дисплея. Макрос  sotofar
используется для создания  дальнего указателя этого  селектора так,
чтобы  можно  было  работать  с  памятью  дисплея.  Макрос  sotofar
находится в файле /usr/include/sys/sysmacros.h. На 80386-х  машинах
ioctl() возвращает символьный указатель (char *).
<p align=justify>
За  детальной  информацией  о   различных  дисплеях,  адаптерах   и
контроллерах обращайтесь к документации по аппаратной части.
<p align=justify>
Для отображения памяти дисплея можно использовать следующие запросы
ioctl():
<dl>
<dt>MAPCONS
<dd>Отображает память  дисплея адаптера,  используемого в
текущий  момент,  в  область пользовательских данных.
(Все типы адаптеров.)
<dt>MAPMONO
<dd>Отображает  память  дисплея  монохромного   адаптера,
используемого   в   текущий    момент,   в    область
пользовательских данных.  (Только MONO.)
<dt>MAPCGA
<dd> Отображает   память   дисплея   цветного графического
адаптера, используемого   в   текущий    момент,    в
область пользовательских данных.  (Только CGA.)
<dt>MAPEGA
<dd>Отображает память  дисплея улучшенного   графического
адаптера, используемого    в    текущий  момент,    в
область пользовательских данных.  (Только EGA.)
<dt>MAPVGA
<dd>Отображает   память      дисплея    видеографического
растрового адаптера, используемого     в      текущий
момент,       в  область   пользовательских   данных.
(Только VGA.)
</dl><p align=justify>
Например,   для    получения    указателя   на    начало    области
пользовательских данных, связанной  с памятью дисплея  адаптера CGA
можно использовать следующий код:
<pre>
    char far *dp;
    int selector;
          .
          .
          .
    fd=open("/dev/color",O_WRONLY);
    selector=ioctl(fd,MAPCGA,0);
    dp=sotofar(selector,0);
          .
          .
          .
</pre><p align=justify>
Обратите  внимание,  что,  когда  память  дисплея  отображается   в
пльзовательское пространство,  регистры начального  адреса адаптера
не  устанавливаются.  Этот  начальный  адрес  может быть установлен
двумя  способами,   так  чтобы   начальный  адрес   памяти  дисплея
соответствовал верхнему левому углу экрана:
<ol>
<li>Переключите  режим  с  помощью  ioctl()  ("переключение"   может
выполняться и  на уже  установленный режим).  Смотрите подраздел
"Режимы дисплея" в данном разделе.
<li>Измените   начальный  адрес  с  помощью   in-on-port/out-on-port
(операций через порты) ioctl().
</ol><p align=justify>
Эти операции  могут использоваться  также для  определения текущего
значения  регистра  начального  адреса,   а  затем  для   установки
указателя на заданное смещение в отображенном пространстве данных.
<p align=justify><i>Порт ввода/вывода графического адаптера</i><br>
Вы  можете   использовать  ioctl(2)   для  записи   байта  в   порт
графического адаптера или чтения байта из этого порта. Параметр arg
функции ioctl использует следующую структуру данных io_arg:
<pre>
    struct port_io_arg {
      struct port_io_struct args[4];
    };
</pre><p align=justify>
Как показано выше структура  io_arg указывает на массив  из четырех
структур данных port_io. Структура port_io имеет следующий формат:
<pre>
    struct port_io_struct {
       char  dir; /*direction flag (in vs. out)*/
       unsigned_int port; /*port address*/
       char data; /*byte of data*/
    };
</pre><p align=justify>
Для одного вызова ioctl вы можете задать одну, две, три или  четыре
структуры  port_io_struct.  Величина  dir  может принимать значение
IN_ON_PORT для задания чтения байта из порта графического  адаптера
или значение  OUT_ON_PORT для  записи байта  в этот  порт. Величина
port  является   целым  числом,   задающим  адрес   нужного   порта
графического адаптера. Величина data содержит байт, принимаемый  из
порта или посылаемый в этот порт.
<p align=justify>
Если  вы  не  используете  ни  одну  из структур port_io, присвойте
величине port нулевое значение и опустите неиспользуемые  структуры
в конце  массива. Адреса  и назначение  портов различных  адаптеров
смотрите в документации по аппаратной части.
<p align=justify>
Для работы  с портом  графического адаптера  вы можете использовать
следующие команды ioctl(2):
<dl>
<dt>MGAIO 
<dd>Чтение  или  запись  байта  в  порт   монохромного
адаптера. (Только MONO.)
<dt>CGAIO 
<dd>Чтение   или   запись   байта   в   порт  цветного
графического адаптера. (Только CGA.)
<dt>EGAIO
<dd>Чтение  или  запись   байта  в  порт   улучшенного
графического адаптера. (Только EGA.)
<dt>VGAIO
<dd>Чтение или запись  байта в порт  видеографического
растрового адаптера. (Только VGA.)
<dt>CONSIO
<dd>Чтение   или   запись   байта   в   порт  текущего
графического адаптера. (Все типы адаптеров.)
</dl><p align=justify>
Для чтения  байта из  любого порта  графического адаптера присвойте
величине dir  значение IN_ON_PORT,  а величине  port -  адрес порта
графического адаптера. Считанный байт будет возвращен в  переменную
data.
<p align=justify>
Для  записи  байта  присвойте  величине  dir  значение OUT_ON_PORT,
величине port - адрес порта графического адаптера, а величине  data
- байт, который вы хотите записать в порт.
<p align=justify><i>Функциональные клавиши</i><br>
ioctl(2)  может  использоваться  для  задания  или  для   получения
текущего назначения  функциональных клавиш.  При этом  параметр arg
функции ioctl использует следующую структуру данных fkeyarg:
<pre>
   struct fkeyarg {
      unassigned int keynum;
      char keydef [MAXFK];
        /*Comes from
      char flen; ioctl.h via comcrt.h*/
   }
</pre><p align=justify>
Для получения или  назначения определений функциональных  клавиш вы
можете использовать следующие запросы ioctl(2):
<dl>
<dt>GETKEY
<dd>Получает текущее определение функциональной  клавиши.
Номер  этой  клавиши  должен  быть  записан в keynum.
 Строка, приписанная данной клавише, будет  возвращена
в keydef, а длина этой  строки - в flen, когда  ioctl
завершит свою работу.
<dt>SETKEY
<dd>Приписывает  данную  строку  функциональной  клавише.
Номер этой  клавиши должен  быть записан  в keynum, а
длина  строки  (количество  символов)  - в переменную
flen.
</dl>
<p align=justify><i>Экранные управляющие последовательности</i><br>
Следующие  символьные  последовательности  определяются  стандартом
ANSI X3.64-1979 и могут использоваться для управления и модификации
экрана дисплея.  Для достижения  желаемого эффекта  каждое Pn нужно
заменить соответствующим десятичным кодом ASCII. Последняя  колонка
содержит коды termcap(M), где "n/a" означает "не применяется".
<p align=justify>
Использование  в  управляющей  последовательности  7- и 8-разрядных
символов является  допустимым для  каждого определенного  действия.
Например,  команда   ANSI  ED   может  быть   вызвана  с    помощью
последовательности  "ESC[  Pn  j"  (0x1b-0x5b-Pn-0x4a,  7-разрядные
символы)  или   последовательности  "CSI   Pn  j"    (0x9b-Pn-0x4n,
8-разрядные символы).
<table border=1>
<tr><th>Обозначение ISO<th>Последовательность<th>Действие<th>Код termcap</tr>
<tr valign=top><td>ED<br>(Erase in Display)<td>CSI pN J<td>Очищает весь дисплей или его 
 часть. Pn=0: очистка с
 активной позиции до конца
 дисплея. Pn=1: очистка от
 начала дисплея до активной
 позиции. Pn=2: очистка всего
 дисплея.
<td>cd</tr>
<tr valign=top><td>EL<br>(Erase in Line)<td>CSI Pn K<td>Очищает всю строку или ее 
 часть. Pn=0: очистка с
 активной позиции до конца
 строки. Pn=1: очистка от
 начала строки до активной
 позиции. Pn=2: очистка всей
 строки.
<td>ce</tr>
<tr valign=top><td>ECH<br>(Erase Character)<td>CSI Pn X<td>Стирает символы Pn. n/a</tr>
<tr valign=top><td>CBT<br>(Cursor Backward Tabulation)<td>CSI Pn Z<td>Передвигает активную позицию 
 назад на Pn табуляций.
<td>bt</tr>
<tr valign=top><td>SU<br>(Scroll Up)<td>CSI Pn S<td>Прокручивает экран вверх на Pn 
 строк, вставляя снизу пустые
 строки.
<td>sf</tr>
<tr valign=top><td>SD<br>(Scroll Down)<td>CSI Pn T<td>Прокручивает экран вниз на Pn 
 строк, вставляя сверху пустые
 строки.
<td>sr</tr>
<tr valign=top><td>CUP<br>(Cursor Position)<td>CSI P1;P2 H<td>Перемещает активную позицию на 
 координату P1 по вертикали и
 P2 по горизонтали.
<td>cm</tr>
<tr valign=top><td>HVP<br>(Horizontal & Vertica Position)<td>CSI P1;P2 f<td>Перемещает активную позицию на 
 координату P1 по вертикали и
l P2 по горизонтали.
<td>n/a</tr>
<tr valign=top><td>CUU<br>(Cursor Up)<td>CSI Pn A<td>Перемещает активную позицию 
 на Pn строк вверх.
<td>up(ka)</tr>
<tr valign=top><td>CUD<br>(Cursor Down)<td>CSI Pn B<td>Перемещает активную позицию 
 на Pn строк вниз.
<td>do(kd)</tr>
<tr valign=top><td>CUF<br>(Cursor Forward)<td>CSI Pn C<td>Перемещает активную позицию 
 на Pn позиций вправо.
<td>nd(kr)</tr>
<tr valign=top><td>CUB<br>(Cursor Backward)<td>CSI Pn D<td>Перемещает активную позицию 
 на Pn позиций назад.
<td>bs(kl)</tr>
<tr valign=top><td>HPA<br>(Horizontal Position Absolute)<td>CSI Pn `<td>Перемещает активную позицию 
 на колонку Pn.
<td>n/a</tr>
<tr valign=top><td>HPR<br>(Horizontal Position Relative)<td>CSI Pn a<td>Перемещает активную позицию
 на Pn символов вправо.
<td>n/a</tr>
<tr valign=top><td>VPA<br>(Vertical Position Absolute)<td>CSI Pn d<td>Перемещает активную позицию
 на строку Pn.
<td>n/a</tr>
<tr valign=top><td>VPR<br>(Vertical Position Relative)<td>CSI Pn e<td>Перемещает активную позицию 
 на Pn строк вниз.
<td>n/a</tr>
<tr valign=top><td>IL<br>(Insert Line)<td>CSI Pn L<td>Вставляет Pn новых пустых
 строк.
<td>al</tr>
<tr valign=top><td>ICH<br>(Insert Character)<td>CSI Pn @<td>Вставляет Pn пустых позиций
 для Pn символов.
<td>ic</tr>
<tr valign=top><td>DL<br>(Delete Line)<td>CSI Pn M<td>Удаляет Pn строк.<td>
dl</tr>
<tr valign=top><td>DCH<br>(Delete Character)<td>CSI Pn P<td>Удаляет Pn символов.<td>
dc</tr>
<tr valign=top><td>CPL<br>(Cursor to Previous Line)<td>CSI Pn F<td>Перемещает активную позицию
 на Pn строк вверх и на начало
 строки.
<td>n/a</tr>
<tr valign=top><td>CNL<br>(Cursor to Next Line)<td>CSI Pn E<td>Перемещает активную позицию 
 на Pn строк вниз и на начало
 строки.
<td>n/a</tr>
<tr valign=top><td>CGR<br>(Select Graphic Rendition)<td>CSI 0 m<td>Сброс ярких, мигающих, пустых,
 подчеркнутых и инвертированных
 символов. Цвет:
 восстанавливает нормальные
 установки цветов.
<td>n/a</tr>
<tr valign=top><td>SGR<td>CSI 1 m<td>Устанавливает атрибут яркости.
 Цвет: устанавливает атрибут
 интенсивности (меняет color на
 lt_color).
<td>n/a</tr>
<tr valign=top><td>SGR<td>CSI 4 m<td>Устанавливает подчеркивание.
 Цвет: без изменения.
<td>n/a</tr>
<tr valign=top><td>SGR<td>CSI 5 m<td>Устанавливает мигание. Цвет:
 меняет фон с lt_color на
 color; символ мигает.
<td>n/a</tr>
<tr valign=top><td>SGR<td>CSI 7 m<td>Устанавливает инвертирование.
 Цвет: инвертирует выбранные
 цвета.
<td>so</tr>
<tr valign=top><td>SGR<td>CSI 10 m<td>Выбирает первичный шрифт. 
<td>GE</tr>
<tr valign=top><td>SGR<td>CSI 11 m<td>Выбирает первый альтернативный 
 шрифт. Разрешает высвечивание
 символов ASCII с кодами,
 меньшими 32, в виде символов,
 зашитых в ПЗУ.
<td>n/a</tr>
<tr valign=top><td>SGR<td>CSI 12 m<td>Выбирает второй альтернативный
 шрифт. Перед выдачей в виде
 символов, зашитых в ПЗУ,
 переключает старший бит
 расширенного кода ASCII.
<td>GS</tr>
<tr valign=top><td>SGR<td>ESC[ 4 m<td>Устанавливает подчеркивание.
 Цвет: без изменения.
<td>n/a</tr>
<tr valign=top><td>SGR<td>CSI3 C m<td>Цвет: выбор цвета символа C
 (см. таблицу 1 ниже).
<td>n/a</tr>
<tr valign=top><td>SGR<td>CSI4 C m<td>Цвет: выбор цвета фона C 
 (см. таблицу 1 ниже).
<td>n/a</tr>
<tr valign=top><td>SGR<td>SCI 8 m<td>Устанавливает мигание.
<td>n/a</tr>
</table><p>
Следующие коды цветов и последовательности определены Международной
организацией по стандартизации ISO DP 6429.
<center><table border=1>
<caption><div align=right><i>Таблица 1</i></div></caption>
<tr><th>С<th>Цвет</tr>
<tr><td>0<td>Черный</tr>
<tr><td>1<td>Красный</tr>
<tr><td>2<td>Зеленый</tr>
<tr><td>3<td>Желтый</tr>
<tr><td>4<td>Синий</tr>
<tr><td>5<td>Маджента</tr>
<tr><td>6<td>Циан</tr>
<tr><td>7<td>Белый</tr>
</table>
<p><table border=1>
<tr><th>Обозначение ISO<th>Последовательность<th>Действие<th>Код termcap</tr>
<tr valign=top><td>SM<br>(Set Mode)<td>ESC[2h<td>Блокировка         клавиатуры. Игнорирует ввод с  клавиатуры, пока      она     не     будет разблокирована.   Символы   не сохраняются.
<td>n/a</tr>
<tr valign=top><td>MC<br>(Media Copy)<td>ESC[2i<td>Содержимое экрана пересылается на главный адаптер.    Текущее содержимое  экрана  посылается прикладной программе.
<td>n/a</tr>
<tr valign=top><td>RM<br>(Reset Mode)<td>ESC[2l<td>Снимает блокировку  клавиатуры и восстанавливает  прием ввода с клавиатуры.
<td>n/a</tr>
</table></center>
<p>
Следующие    коды    цветов    и    последовательности   составляют
дополнительные управляющие последовательности.
<p><center><table border=1>
<caption><div align=right><i>Таблица 2</i></div></caption>
<tr><th>Сn<th>Цвет<th>Cn<th>Цвет</tr>
<tr><td>0<td>Черный<td>8<td>Серый</tr>
<tr><td>1<td>Красный<td>9<td>С.-голубой</tr>
<tr><td>2<td>Зеленый<td>10<td>С.-зеленый</tr>
<tr><td>3<td>Желтый<td>11<td>С.-циановый</tr>
<tr><td>4<td>Синий<td>12<td>С.-красный</tr>
<tr><td>5<td>Маджента<td>13<td>C. маджента</tr>
<tr><td>6<td>Циан<td>14<td>Желтый</tr>
<tr><td>7<td>Белый<td>15<td>C.-белый</tr>
</table>
<p><table border=1>
<tr><th>Обозначение ISO<th>Последовательность<th>Действие<th>Код termcap</tr>
<tr valign=top><td>n/a<td>CSI=cA<td>Устанавливает цвет бордюра с. c - десятичное значение, выбираемое из таблицы 2, приведенной выше. (Эта последовательность под- держивается не на всякой аппаратуре.)
<td>n/a</tr>
<tr valign=top><td>n/a<td>CSI=p;dB<td>Задает параметры "звонка" p и d в десятичном виде. p - период звучания в единицах 840.3 наносекунд, а d - длительность звучания в единицах 100 миллисекунд.
<td>n/a</tr>
<tr valign=top><td>n/a<td>CSI=s;eC<td>Устанавливает вид курсора с начальной линией s и последней линией e.
<td>n/a</tr>
<tr valign=top><td>n/a<td>CSI=xD<td>Включает или выключает (x=1 или 0) интенсивность цвета фона.
<td>n/a</tr>
<tr valign=top><td>n/a<td>CSI=xE<td>Устанавливает или сбрасывает (x=1 или 0) бит мигания вместо бита интенсивности фона контроллера дисплея 6845.
<td>n/a</tr>
<tr valign=top><td>n/a<td>CSI=cF<td>Устанавливает нормальный цвет символов с.(с - десятичное число, выбираемое из таблицы 2.)
<td>n/a</tr>
<tr valign=top><td>n/a<td>CSI=c G<td>Устанавливает нормальный фон. (См. таблицу 2.)
<td>n/a</tr>
<tr valign=top><td>n/a<td>CSI=c H<td>Устанавливает инвертированный цвет символов. (См. таблицу 2.)
<td>n/a</tr>
<tr valign=top><td>n/a<td>CSI=c I<td>Устанавливает инвертированный цвет фона. (См. таблицу 2.)
<td>n/a</tr>
<tr valign=top><td>n/a<td>CSI=c J<td>Устанавливает цвет символов в графике. (См. таблицу 2.)
<td>n/a</tr>
<tr valign=top><td>n/a<td>CSI=c K<td>Устанавливает цвет фона в графике. (См. таблицу 2.)
<td>n/a</tr>
<tr valign=top><td>n/a<td>ESC[Png<td>Обеспечивает доступ к альтернативному графическому набору символов, который не совпадает с набором "графического режима". Смотрите документацию по десятичным/символьным кодам (Pn) и возможным высвечиваемым символам.
<td>n/a</tr>
<tr valign=top><td>n/a<td>ESCQFn'string'<td>Приписывает строку string функциональной клавише Fn. Ограничителями строки ' и ' могут служит любые символы, не встречающиеся в этой строке. Функциональные клавиши нумеруются от 0 до 9 (F1=0, F2=1 и т.д.)
<td>n/a</tr>
<tr valign=top><td>n/a<td>ESC[Pnz<br>CSIPnz<td>Pn должно быть равно номеру экрана, на который осуществляется переключение. Срабатывает только в том случае, если экран был сконфигурирован во время загрузки, в противном случае никакого эффекта не будет.<td>n/a</tr>
</table></center>
<p><b>ФАЙЛЫ</b>
<pre>
/dev/console
/dev/tty[02-n]
/dev/color
/dev/monochrome
/dev/ega
/dev/vga
</pre>
<p><b>СМ. ТАКЖЕ</b><br>
console(5), ioctl(2), keyboard(HW), keymap(5), mapkey(8),
mapchan(5), multiscreen(5), setcolor(1), stty(1), systty(5),
vidi(1), termcap(5), tty(5)
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/footer0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table>
</body>
</html>
