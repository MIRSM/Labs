<html>
<head>
<title>SIGSET(2)</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/header0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="_pic_/logo.gif" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>

<h3 align=center>SIGSET(2)</H3>
<p><b>НАЗВАНИЕ</b><br>
sigset, sighold, sigignore, sigpause - процедуры управления
сигналами.
<p><b>СИНТАКСИС</b>
<pre>
   #include &lt;signal.h&gt;
   void (*sigset(sig,func))()
   int sig;
   void (*func)();
   int sighold(sig)
   int sig;
   int sigrelse(sig)
   int sig;
   int sigignore(sig)
   int sig;
   int sigpause(sig)
   int sig;
</pre>
<p align=justify><b>ОПИСАНИЕ</b><br>
Эти  функции   обеспечивают  управлением   сигналами  для    процессов
прикладных программ. Системный вызов sigset задает реакцию системы  на
сигнал sig. Эта реакция заключается либо в вызове обработчика  сигнала
процесса func, либо в выполнении определенного системой действия.
<p align=justify>
Параметру sig может быть  присвоено любое из приведенных  значений, за
исключением  значения  SIGKILL.  Сигналы,  зависящие от аппаратной или
программной реализации, не  приведены (см. "Примечания"  ниже). Каждое
значение  sig  является  макросом,  определенным  в  файле  &lt;signal.h&gt;
и который  может быть  представлен в  виде выражения-константы.
<table>
<tr><td>SIGHUP<td>прекращение сетевой связи</tr>
<tr><td>SIGINT<td>прерывание</tr>
<tr><td>SIGQUIT*<td>выход</tr>
<tr><td>SIGILL*<td>неверная инструкция (не удерживается при получении)</tr>
<tr><td>SIGTRAP*<td>прерывание трассировки (не удерживается при получении)</tr>
<tr><td>SIGABRT*<td>аварийный выход</tr>
<tr><td>SIGFPE*<td>ошибка операции с плавающей точкой</tr>
<tr><td>SIGKILL<td>уничтожение (не может быть получен или опущен)</tr>
<tr><td>SIGSYS*<td>неверный аргумкент в системном вызове</tr>
<tr><td>SIGPIPE<td>запись в канал конвейера без последующего чтения</tr>
<tr><td>SIGALRM<td>сигнал тревоги</tr>
<tr><td>SIGTERM<td>сигнал программного завершения</tr>
<tr><td>SIGUSR1<td>определенный пользователем сигнал 1</tr>
<tr><td>SIGUSR2<td>определенный пользователем сигнал 2</tr>
<tr><td>SIGCLD<td>смерть дочернего процесса</tr>
<tr><td>SIGPWR<td>сбой питания</tr>
<tr><td>SIGPOLL<td>ожидание выбираемого события (см. "Примечания" ниже)</tr>
</table>
<p align=justify>
В отношении звездочек (*) в вышеприведенном списке смотрите текст под
SIG_DFL.
<p align=justify>
Следующие  значения  для  определенных  системой  действий  func также
определяются  в  файле  &lt;signal.h&gt;.  Каждое  из них является макросом,
который  может  быть  представлен  в  виде  выражения-константы   типа
указателя на функцию, возвращающую void, и имеет уникальное  значение,
которое не соответствует ни одной определенной функции.
<ul>
<li><b>SIG_DFL</b> - реакция системы по умолчанию.
По  получении  сигнала  sig  получающий  процесс   подлежит
завершению со  всеми последствиями,  описанными в  <a href=EXIT.htm>exit(2)</a>.
Кроме того в текущем рабочем каталоге этого процесса  будет
оставлен  "статический   образ",  если   значение  sig    в
вышеприведенном     списке     помечено     звездочкой    и
удовлетворяются следующие условия:
<p>
Эффективный  пользовательский  идентификатор  и
действительный пользовательский идентификатор
получающего сигнал процесса совпадают.
<p>
Существует обычный файл с именем core, который  доступен
для записи,  или этот  файл может  быть создан.  Если он
должен  быть  создан,  тоон  будет  иметь следующие
свойства:
<ul type=disk>
<li>режим доступа 0666, модифицированный маской  создания
файлов [см. <a href=UMASK.htm>umask(2)</a>]
<li>идентификатор владельца файла совпадает с
эффективным  пользовательским идентификатором
получающего сигнал процесса
<li>групповой идентификатор файла совпадает с эффективным
групповым идентификатором получающего сигнал
процесса.
</ul>
<li><b>SIG_IGN</b> - игнорирование сигнала
Ожидание  сигнала  sig  отменяется,  и  реакция  системы на
сигнал этого типа устанавливается на его игнорирование.
<li><b>SIG_HOLD</b> - удержание сигнала
Сигнал sig подлежит удержанию по его получении.
Удерживается всякий ожидаемый сигнал этого типа. По каждому
типу удерживается только один сигнал.
</ul>
<p align=justify>
В любом другом случае func должен быть указателем на
функцию-обработчик, которая вызывается при возникновении сигнала  sig.
В  этом  случае  sigset  определяет,  что  процесс  должен вызвать эту
функцию по получении  сигнала sig. Любой  ожидаемый сигнал этого  типа
сбрасывается.  Адрес  данного  обработчика  поддерживается  длявсех
вызовов прочих функций управления сигналами, перечисленными здесь.
<p align=justify>
При возникновении  сигнала его  значение sig  передается обработчику в
качестве единственного  аргумента. Перед  вызовом обработчика  реакция
системы на сигнал устанавливается на SIG_HOLD. При нормальном возврате
из обработчика реакция системы на сигнал восстанавливается на func,  и
любой  ожидаемый  сигнал  этого  типа  сбрасывается.Если выполняется
нелокальный  переход  goto(longjmp  -  дальний прыжок),  тодля
восстановления реакции системы на сигнал и сброса любого удерживаемого
сигнала данного типа должен быть вызван sigrelse.
<p align=justify>
В принципе после возврата  из обработчика сигнала процесс,  получивший
этот сигнал, должен  возобновить свое выполнение  в точке, где  он был
прерван.  Однако,  если  сигнал  ловится  во  время  системных вызовов
<a href=READ.htm>read(2)</a>,  <a href=WRITE.htm>write(2)</a>,  <a href=OPEN.htm>open(2)</a>  или  <a href=IOCTL.htm>ioctl(2)</a>,  когда работает системный
вызов sigpause или <a href=WAIT.htm>wait(2)</a>, которые задерживают возврат из-за  наличия
предварительно  приостановленного  процесса  (или  зомби-процесса), то
будет выполняться обработчик сигнала, после чего прерванный  системный
вызов может  возвратить вызывавшему  процессу -1  со значением  errno,
установленным в EINTR.
<p align=justify>
sighold и sigrelse используются для установления критических  областей
кода.  sighold  соответствует  поднятию  уровня приоритета и удержанию
сигнала,  пока  этот  приоритет  не  будет  снижен с помощью sigrelse.
sigrelse восстанавливает  реакцию системы  на сигнал  в предварительно
заданную с помощью sigset.
<p align=justify>
sigignore устанавливает реакцию на сигнал sig в SIG_IGN (см. выше).
<p align=justify>
sigpause  приостанавливает  вызывающий  процесс,  пока  он  не получит
сигнал;  аналогично  работает  <a href=PAUSE.htm>pause(2)</a>.Однако,  при  получениии
удержании  сигнала  sig,  он  сбрасывается, и активизируется системная
реакция  на  этот  сигнал.  Этот  системный вызов полезен для проверки
переменных, которые  меняют свое  значение при  возникновении сигнала.
При этом правильные действия таковы: вначале sighold используется  для
блокировки  сигнала,  затем  проверяются переменные.  Если  онине
изменились, то вызывается sigpause для ожидания сигнала. Вызов  sigset
потерпит крах, если выполнится одно из следующих условий:
<dl>
<dt>[EINVAL]
<dd>Сигнал sig  имеет неверное значение (включая SIGKILL),  или
обработка sig по умолчанию не может быть изменена.
<dt>[EINTR]
<dd>Сигнал был получен во время системного вызова sigpause.
</dl>
<p><b>СМ. ТАКЖЕ</b><br>
<a href=KILL~1.htm>kill(2)</a>, <a href=PAUSE.htm>pause(2)</a>, <a href=SIGNAL.htm>signal(2)</a>, <a href=WAIT.htm>wait(2)</a>, setjmp(2)
<p align=justify><b>ДИАГНОСТИКА</b><br>
При  успешном  завершении  sigset  возвращает  предыдущее значение
реакции  системы  на  заданный сигнал  sig.  В  противном случае
возвращается значение SIG_ERR,  а errno указывает  на ошибку.SIG_ERR
определяется в файле &lt;signal.h&gt;
<p align=justify>
Что  касается  других  функций,то  при  их  успешном выполнении
возвращается значение  0. В  противном случае  возвращается значение
-1, а errno указывает на ошибку.
<p align=justify><b>Примечания</b><br>
Сигнал SIGPOLL возникает, когда файловый дескриптор, соответствующий
файлу STREAMS [см. <a href=INTRO~1.htm>intro(2)</a>], задает ожидание "выбираемого" события.
Для  того,  чтобы  этот  сигнал  был  послан, процесс должен сделать
специальный запрос с помощью  вызова I_SETSIG <a href=IOCTL.htm>ioctl(2)</a>. В  противном
случае этот процесс никогда не получит сигнал SIGPOLL.
<p align=justify>
В целях компактности прикладные программы должны использовать только
символические имена сигналов, а  не их значения, и  применять только
те сигналы, которые перечислены здесь. Реакция на сигнал SIGKILL  по
умолчанию не может быть изменена.
<p align=justify>
Специальные  разработки  могут  определять  собственные  сигналы,  а
обработчику сигналов могут быть переданы дополнительные определенные
в  разработке  аргументы,  соответствующие  аппаратным  сигналам.  В
случае  некоторых  аппаратно генерируемых  сигналов  может  оказаться
невозможным возобновление выполнения процессов в точке  их
прерывания.
<p align=justify>
Сигнальный тип SIGSEGV резервируется на случай некорректного доступа
к  информационному объекту.  Если разрабатываемая  программа в
состоянии определить возникновение  подобного состояния, то  следует
использовать этот сигнальный тип.
<p align=justify>
Другие  функции  управления  сигналами,  <a href=SIGNAL.htm>signal(2)</a>  и  <a href=PAUSE.htm>pause(2)</a>,  не
следует  использовать  в  соединении  с  приведенными  функциями для
обработки специфических типов сигналов.
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/footer0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table>
</body>
</html>
