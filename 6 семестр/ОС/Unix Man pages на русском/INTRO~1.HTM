<html>
<head>
<title>INTRO(2)</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/header0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="_pic_/logo.gif" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>

<h3 align=center>INTRO(2)</H3>
<p><b>НАЗВАНИЕ</b><br>
intro - введение в описание системных вызовов и номеров ошибок
<p><b>СИНТАКСИС</b>
<pre>
        #include &lt;errno.h&gt;
</pre>
<p align=justify><b>ОПИСАНИЕ</b><br>
В  этом разделе описываются все системные вызовы. Большинство из них имеют одно или несколько  значений  кода
завершения  при  ошибке.  Состояние ошибки определяется
возвращением значения, невозможного  в  другом  случае.
Почти всегда это -1 или указатель NULL; детали оговариваются при описании каждого вызова. Номер ошибки доступен  также через внешнюю переменную errno. Эта переменная не обнуляется при успешных вызовах,  поэтому  имеет
смысл  использовать ее значение только в случае обнаружения ошибки.
<p align=justify>
В описании каждого системного вызова приводится  список
возможных номеров ошибок. Ниже приводится полный список
номеров ошибок и их мнемонических имен, как они определены во включаемом файле &lt;errno.h&gt;.
<dl>
<dt><b><i>1  EPERM Не владелец</i></b>
<dd>Обычно эта ошибка указывает на попытку модифицировать файл, доступ к которому разрешен  только  его
владельцу и суперпользователю.
<dt><b><i>2  ENOENT       Не найден файл или каталог</i></b>
<dd>Эта  ошибка  имеет место, если имя файла указано и
файл должен был бы существовать, однако  его  нет;
или если один из каталогов, указанных в маршрутном
имени, не существует.
<dt><b><i>3  ESRCH Нет такого процесса</i></b>
<dd>Процесс, соответствующий заданному  идентификатору
процесса (pid)  в  системном  вызове  <a href=KILL~1.htm>kill(2)</a>  или
<a href=PTRACE.htm>ptrace(2)</a>, не может быть найден.
<dt><b><i>4  EINTR Прерывание системного вызова</i></b>
<dd>Асинхронный сигнал (такой  как  сигнал  прерывания
или выхода), перехватываемый пользователем, пришел
во  время выполнения системного вызова. Если после
обработки  сигнала  будет  продолжено   выполнение
программы,  то  системный вызов завершится с ошибкой.
<dt><b><i>5  EIO  Ошибка ввода/вывода</i></b>
<dd>Обнаружена ошибка ввода/вывода. Эта  ошибка  может
иногда иметь место во время вызова, который следует за вызовом, к которому на самом деле  относится
эта ошибка.
<dt><b><i>6  ENXIO Неверное устройство или адрес</i></b>
<dd>Ввод/вывод в специальный файл ссылается на устройство, которое не существует; или исчерпаны  лимиты
устройства для ввода/вывода. Эта ошибка может также  иметь  место, если магнитофон находится в пассивном состоянии или не установлен пакет дисков.
<dt><b><i>7  E2BIG Длинный список аргументов</i></b>
<dd>При  обращении  к  системному  вызову из семейства
<a href=EXEC.htm>exec(2)</a> задан список аргументов, содержащий  более
5120 байт.
<dt><b><i>8  ENOEXEC      Неверный формат выполняемого файла</i></b>
<dd>Сделан запрос на выполнение файла, который, хотя и
имеет соответствуюшие права, не начинается  с  допустимого магического числа [см. a.out(4)].
<dt><b><i>9  EBADF Неверный номер файла</i></b>
<dd>Или дескриптор файла указывает на неоткрытый файл,
или запрос на чтение (соответственно запись)  сделан для файла, открытого только для записи  (соответственно чтения).
<dt><b><i>10  ECHILD      Нет порожденных процессов</i></b>
<dd>Системный вызов <a href=WAIT.htm>wait(2)</a> был выполнен процессом, не
имеющим  существующих  порожденных  процессов  или
процессов, которых он не дождался.
<dt><b><i>11  EAGAIN      Слишком много процессов</i></b>
<dd>Системный  вызов  <a href=FORK.htm>fork(2)</a> завершился аварийно, так
как системная таблица процессов полна или  пользователю  не разрешено более создавать новые процессы.
<dt><b><i>12  ENOMEM      Исчерпано пространство</i></b>
<dd>Во время  выполнения  системных  вызовов  <a href=EXEC.htm>exec(2)</a>,
<a href=BRK.htm>brk(2)</a>,  или <a href=SBRK.htm>sbrk(2)</a> программе потребовалось места
в памяти больше, чем система может  выделить.  Это
не  временное  условие; максимальный размер пространства является системным параметром. Ошибка  может также  иметь  место, если набор секций  команд
данных и стека требует  слишком  много  сегментных
регистров или, если при вызове <a href=FORK.htm>fork(2)</a> недостаточно места в области подкачки.
<dt><b><i>13  EACCES      Нарушение прав доступа</i></b>
<dd>Была предпринята попытка получить доступ к  файлу,
а прав для этого нет.
<dt><b><i>14  EFAULT      Недопустимый адрес</i></b>
<dd>Произошло прерывание при попытке использования аргументов системного вызова.
<dt><b><i>15  ENOTBLK     Требуется блочное устройство</i></b>
<dd>Не блочный файл указан там, где ожидался  блочный,
например, в вызове <a href=MOUNT~1.htm>mount(2)</a>.
<dt><b><i>16  EBUSY       Устройство или ресурс заняты</i></b>
<dd>Была  сделана попытка смонтировать устройство, которое уже смонтировано, или была  предпринята  попытка  размонтировать устройство, на котором находится активный файл (открытый файл, текущий  каталог,  смонтированный  файл или активная секция команд). Эта ошибка также имеет  место  при  попытке
разрешить сбор статистики, если он уже разрешен.
<dt><b><i>17  EEXIST      Файл уже существует</i></b>
<dd>Существующий файл указан в неподходящем контексте,
например  в  качестве  аргумента системного вызова
<a href=LINK~1.htm>link(2)</a>.
<dt><b><i>18  EXDEV       Ссылка на другое устройство</i></b>
<dd>Была предпринята попытка  создать  ссылку на файл,
расположенный на другом устройстве.
<dt><b><i>19  ENODEV      Неподходящее устройство</i></b>
<dd>Была предпринята попытка выполнить  системный  вызов, неподходящий в данном контексте, например попытка чтения с устройства,  открытого  только  для
записи.
<dt><b><i>20  ENOTDIR     Требуется каталог</i></b>
<dd>Там где ожидалось имя каталога, указано нечто другое;  например,  в маршрутном имени или в качестве
аргумента системного вызова <a href=CHDIR.htm>chdir(2)</a>.
<dt><b><i>21  EISDIR      Попытка записи в каталог</i></b>
<dt><b><i>22  EINVAL      Недопустимый аргумент</i></b>
<dd>Недопустимое значение аргумента (например, размонтирование несмонтированного  устройства;  указание
неопределенного  сигнала  при вызове <a href=SIGNAL.htm>signal(2)</a> или
<a href=KILL~1.htm>kill(2)</a>; чтение или запись в  файл,  для  которого
вызов  <a href=LSEEK.htm>lseek(2)</a>  вернул  отрицательный указатель).
Также устанавливается  математическими  функциями,
описанными в разделе 3M настоящего Справочника.
<dt><b><i>23  ENFILE      Переполнена таблица файлов</i></b>
<dd>Системная таблица открытых  файлов  переполнена  и
временно не может быть  выполнен  системный  вызов
<a href=OPEN.htm>open(2)</a>.
<dt><b><i>24  EMFILE      Слишком много открытых файлов</i></b>
<dd>Никакой процесс не может иметь больше, чем NOFILES
(по умолчанию 20) одновременно открытых дескрипторов файлов.
<dt><b><i>25  ENOTTY      Не символьное устройство</i></b>
<dd>Была предпринята попытка выполнить системный вызов
<a href=IOCTL.htm>ioctl(2)</a> к файлу, который не является  специальным
символьным.
<dt><b><i>26  ETXTBSY     Перегружена секция команд</i></b>
<dd>Была предпринята попытка выполнить файл, который в
данный  момент открыт для записи. Эта ошибка может
также означать попытку записи в  файл,  содержащий
выполняющуюся в данный момент программу.
<dt><b><i>27  EFBIG       Слишком большой файл</i></b>
<dd>Размер  файла превысил максимально допустимое значение ULIMIT [см. <a href=ULIMIT.htm>ulimit(2)</a>].
<dt><b><i>28  ENOSPC      Исчерпано пространство на устройстве</i></b>
<dd>При записи [посредством <a href=WRITE.htm>write(2)</a>] в  обычный  файл
на  устройстве  не  осталось свободного места. При
выполнении <a href=FCNTL.htm>fcntl(2)</a> установка или снятие блокировки с записей файла не может быть произведено,  так
как в системе не осталось больше места.
<dt><b><i>29  ESPIPE      Ошибка позиционирования</i></b>
<dd>Аргументом системного вызова <a href=LSEEK.htm>lseek(2)</a> является канал.
<dt><b><i>30  EROFS       Смонтировано только для чтения</i></b>
<dd>Попытка модифицировать файл или каталог на устройстве, смонтированном только для чтения.
<dt><b><i>31  EMLINK      Слишком много ссылок</i></b>
<dd>Была предпринята попытка  создать  более  чем  100
ссылок на файл.
<dt><b><i>32  EPIPE       Канал разрушен</i></b>
<dd>Была предпринята попытка записать в канал, из  которого ни один процесс не читает данных. При  этом
обычно генерируется сигнал; если сигнал  игнорируется, то возвращается ошибка.
<dt><b><i>33  EDOMВыход за границы области определения</i></b>
<dd>Аргумент  функции,  описанной  в разделе 3M, лежит
вне ее области определения.
<dt><b><i>34  ERANGE      Переполнение</i></b>
<dd>Результат функции, описанной в  разделе  3M,  непредставим с допустимой в машине точностью.
<dt><b><i>35  ENOMSG      Нет сообщений такого типа</i></b>
<dd>Была предпринята попытка получить сообщение  типа,
который не существует в указанной очереди  сообщений [см. <a href=MSGOP.htm>msgop(2)</a>].
<dt><b><i>36  EIDRM       Идентификатор удален</i></b>
<dd>Эта ошибка возвращается процессам,  которые возобновляют выполнение из-за  удаления  идентификатора
очереди  сообщений, семафора или разделяемого сегмента из системной таблицы  имен [см.  <a href=MSGCTL.htm>msgctl(2)</a>,
<a href=SEMCTL.htm>semctl(2)</a>, <a href=SHMCTL.htm>shmctl(2)</a>].
<dt><b><i>37-44   Зарезервированные номера</i></b>
<dt><b><i>45  EDEADLK     Тупик обнаружен и обойден</i></b>
<dd>Была обнаружена и исправлена  тупиковая  ситуация.
Эта ошибка свойственна операциям блокировки файлов
и их частей.
<dt><b><i>46  ENOLCK      Ошибка блокировки</i></b>
<dd>При  выполнении <a href=FCNTL.htm>fcntl(2)</a> установка или снятие блокировки файла не может быть произведено, так как в
системе не осталось больше места.
<dt><b><i>60  ENOSTR      Не псевдоустройство</i></b>
<dd>Попытка  выполнить  системные  вызовы  <a href=PUTMSG.htm>putmsg(2)</a> и
<a href=GETMSG.htm>getmsg(2)</a> для дескриптора файла, а файл не является псевдоустройством.
<dt><b><i>62  ETIME       Истекло время для операции с псевдоустройством</i></b>
<dd>Время, отведенное на вызов <a href=IOCTL.htm>ioctl(2)</a> для псевдоустройства, истекло. Причина этой ошибки  для  разных
устройств  разная - возможно, проявился дефект аппаратуры, или, быть может, виновата программа. Может быть, для операции просто отведено недостаточное время. Результат операции  <a href=IOCTL.htm>ioctl(2)</a>  неопределен.
<dt><b><i>63  ENOSR       Исчерпаны ресурсы псевдоустройств</i></b>
<dd>При  попытке выполнить системный вызов <a href=OPEN.htm>open(2)</a> для
псевдоустройства не было  доступных  очередей  или
структур данных.
<dt><b><i>64  ENONET      Машина не в сети</i></b>
<dd>Эта ошибка возможна  только  при работе с системой
разделения удаленных файлов (РУФ). Она имеет  место, когда пользователь пытается афишировать, скрывать, монтировать, размонтировать удаленные ресурсы в то время, когда компьютер еще не проделал все
положенные процедуры для подключения к сети.
<dt><b><i>65  ENOPKG      Не та конфигурация</i></b>
<dd>Эта ошибка имеет место, когда пользователь пытается использовать системный вызов, не входящий в текущую конфигурацию системы.
<dt><b><i>66  EREMOTE     Удаленный ресурс</i></b>
<dd>Эта  ошибка  возможна только при работе с РУФ. Она
имеет место, когда пользователь пытается  афишировать ресурс, который не находится на локальной машине, или пытается монтировать/размонтировать устройство, которое находится на удаленной системе.
<dt><b><i>67  ENOLINK     Разорвана связь</i></b>
<dd>Эта  ошибка  возможна только при работе с РУФ. Она
имеет место, когда происходит обращение к  удаленной системе, связи с которой в данный момент нет.
<dt><b><i>68  EADV Ошибка афиширования</i></b>
<dd>Эта  ошибка  возможна только при работе с РУФ. Она
имеет место, когда пользователь пытается  афишировать  ресурс, который уже афиширован, или пытается
прекратить работу РУФ или начать  размонтирование,
когда есть еще афишированные ресурсы.
<dt><b><i>69  ESRMNT      Есть смонтированные</i></b>
<dd>Эта  ошибка  возможна только при работе с РУФ. Она
имеет место, когда пользователь  пытается  прекратить работу  РУФ в то время, когда есть еще ресурсы, смонтированные с удаленной системы.
<dt><b><i>70  ECOMM       Ошибка связи</i></b>
<dd>Эта ошибка возможна только при работе с  РУФ.  Она
имеет  место,  когда пользователь пытается послать
сообщение на удаленную машину, связи с  которой  в
данный момент нет.
<dt><b><i>71  EPROTO      Ошибка протокола</i></b>
<dd>Обнаружена какая-либо ошибка протокола. Эта ошибка
специфична для различных устройств, но не означает
сбоя оборудования.
<dt><b><i>74  EMULTIHOP   Нет прямой связи</i></b>
<dd>Эта  ошибка  возможна только при работе с РУФ. Она
имеет место, когда пользователь пытается  получить
доступ  к удаленным ресурсам, которые напрямую недоступны.
<dt><b><i>77  EBADMSG     Недопустимое сообщение</i></b>
<dd>При   выполнении   системных   вызовов    <a href=READ.htm>read(2)</a>,
<a href=GETMSG.htm>getmsg(2)</a>  или вызова <a href=IOCTL.htm>ioctl(2)</a> для псевустройства,
с аргументом I_RECVFD, в начале очереди  оказалось
нечто,  что не может быть обработано. Что   именно
- зависит от системного вызова:
<ul>
<a href=READ.htm>read(2)</a>    Управляющая информация  или  переданный дескриптор файла.<br>
<a href=GETMSG.htm>getmsg(2)</a>  Переданный дескриптор файла.<br>
<a href=IOCTL.htm>ioctl(2)</a>   Управляющая информация или данные.
</ul>
<dt><b><i>83  ELIBACC     Нет доступа к разделяемой библиотеке</i></b>
<dd>Попытка выполнить вызов <a href=EXEC.htm>exec(2)</a> для  файла  a.out,
который ссылается  на  разделяемую  библиотеку,  а
библиотека не существует  или  у  пользователя  не
хватает прав для ее использования.
<dt><b><i>84  ELIBBAD     Повреждение разделяемой библиотеки</i></b>
<dd>Попытка  выполнить  вызов <a href=EXEC.htm>exec(2)</a> для файла a.out,
который ссылается  на  разделяемую  библиотеку,  а
<a href=EXEC.htm>exec(2)</a> не может загрузить эту библиотеку. Возможно, структура разделяемой библиотеки нарушена.
<dt><b><i>85  ELIBSCN     Повреждение секции библиотек</i></b>
<dd>Попытка  выполнить  вызов <a href=EXEC.htm>exec(2)</a> для файла a.out,
который ссылается на разделяемую библиотеку,  а  в
секции  библиотек (.lib) файла a.out находятся неверные данные. В секции библиотек хранятся  сведения для <a href=EXEC.htm>exec(2)</a> о том, какие разделяемые библиотеки  требуются. Возможно, структура файла a.out нарушена.
<dt><b><i>86  ELIBMAX     Много ссылок на разделяемые библиотеки</i></b>
<dd>Попытка выполнить вызов <a href=EXEC.htm>exec(2)</a> для  файла  a.out,
который  использует  больше разделяемых библиотек,
чем разрешено в данной конфигурации системы.
<dt><b><i>87  ELIBEXEC    Выполняется разделяемая библиотека</i></b>
<dd>Попытка выполнить  вызов  <a href=EXEC.htm>exec(2)</a>  непосредственно
для разделяемой библиотеки, что запрещено.
</dl>
<p align=justify><b>ОПРЕДЕЛЕНИЯ</b><br>
<i>Идентификатор процесса (pid)</i>. Каждый активный процесс в
системе имеет уникальный   номер  (положительное  целое
число) называемый  идентификатором  процесса.  Значение
этого идентификатора лежит в пределах от 0 до 30000.
<p align=justify>
</i>Идентификатор родительского процесса (ppid)</i>. Новый процесс  создан  активным  в  данный момент процессом [см.
<a href=FORK.htm>fork(2)</a>], который называется родительским.
<p align=justify>
<i>Идентификатор группы процессов</i>. Каждый активный процесс
является членом группы процессов, которая идентифицируется положительным целым числом, называемым идентификатором  группы  процессов. Этим идентификатором является
идентификатор лидера группы. Группировка процессов позволяет посылать сигналы между взаимосвязанными  процессами [см. <a href=KILL~1.htm>kill(2)</a>].
<p align=justify>
<i>Идентификатор группы терминала</i>. Каждый активный процесс
может быть членом группы терминала, которая идентифицируется положительным целым числом, называемым идентификатором группы терминала. Этот способ группирования используется  для  терминирования  группы взаимосвязанных
процессов при терминировании одного из процессов группы
[см. <a href=EXIT.htm>exit(2)</a> и <a href=SIGNAL.htm>signal(2)</a>].
<p align=justify>
<i>Реальный идентификатор пользователя и реальный  идентификатор группы</i>. Каждый пользователь, известный системе,
идентифицируется  положительным  целым  числом (от 0 до
65535), называемым реальным идентификатором пользователя.
<p align=justify>
Каждый пользователь является  также  членом  какой-либо
группы. Группа также идентифицируется положительным целым числом, называемым реальным идентификатором группы.
<p align=justify>
Активный процесс имеет реальный идентификатор пользователя и реальный идентификатор группы, которые  устанавливаются  равными реальному идентификатору пользователя
и реальному идентификатору  группы  того  пользователя,
кто запустил данный процесс.
<p align=justify>
<i>Действующий идентификатор пользователя процесса и  действующий  идентификатор  группы процесса</i>. Активный процесс имеет  действующий  идентификатор  пользователя  и
действующий  идентификатор группы, которые используются
для определения прав доступа к файлам (см. ниже).  Действующий идентификатор пользователя и действующий идентификатор  группы обычно равны реальному идентификатору
пользователя и реальному  идентификатору  группы,  если
только сам процесс или один из его предков не был запущен из файла, имеющего установленный бит разрешения переустановки идентификатора пользователя или группы [см.
<a href=EXEC.htm>exec(2)</a>].
<p align=justify>
<i>Суперпользователь</i>. Процесс рассматривается  как  суперпользовательский и имеет специальные привилегии, например,  все права доступа к любому файлу, если его действующий идентификатор пользователя есть 0.
<p align=justify>
<i>Специальные  процессы</i>. Процессы, имеющие идентификаторы
процесса 0 и 1, являются специальными; в дальнейшем они
называются proc0 и proc1.
<p align=justify>
<i>Proc0</i> - это планировщик. Proc1 - процесс  инициализации
работы  (init).  Proc1  является предком любого другого
процесса в  системе  и  используется  для  контроля  за
структурой процессов.
<p align=justify>
<i>Дескриптор файла</i>. Дескриптор файла есть небольшое целое
число,  используемое  для операций ввода/вывода в файл;
он может принимать значения от 0 до (NOFILES - 1), поэтому процесс не может иметь одновременно открытыми  более  чем  NOFILES дескрипторов файлов. Дескриптор файла
возвращается такими системными  вызовами,  как  <a href=OPEN.htm>open(2)</a>
или <a href=PIPE.htm>pipe(2)</a> и используется как аргумент в системных вызовах, подобных <a href=READ.htm>read(2)</a>, <a href=WRITE.htm>write(2)</a>, <a href=IOCTL.htm>ioctl(2)</a> и <a href=CLOSE.htm>close(2)</a>.
<p align=justify>
<i>Имя файла</i>.  Имя,  содержащее от 1 до 14 символов, может
использоваться в качестве имени обычного файла,  специального файла или каталога.
<p align=justify>
Эти  символы  могут быть любыми доступными символами из
набора символов ASCII, кроме символов \0 (null) и /.
<p align=justify>
Не рекомендуется использовать в именах  файлов  символы
*, ?, [ или ], так как shell трактует их особым образом
[см.  <a href=SH.htm>sh(1)</a>]. Хотя это и разрешено, но не рекомендуется
использовать в именах файлов управляющие символы.
<p align=justify>
<i>Маршрутное имя и маршрут</i>. Маршрутное имя  есть  цепочка
символов,  заканчивающаяся нулевым байтом, и, возможно,
начинающаяся с символа /, за которым указаны  ноль  или
более  имен каталогов, разделенных символами /, а затем
(необязательное) имя файла.
<p align=justify>
Если маршрутное имя начинается с символа /, то  маршрут
начинается с корневого каталога. Иначе, маршрут начинается с текущего рабочего каталога.
<p align=justify>
Одиночный символ / обозначает корневой каталог.
<p align=justify>
Если не  оговорено  противное,  пустое  маршрутное  имя
рассматривается как имя несуществующего файла.
<p align=justify>
<i>Каталог</i>.   Элементы  каталога  называются  ссылками  на
файл. Любой каталог содержит по крайней мере две  ссылки: . и .., указывающие, соответственно, на сам каталог
и на вышележащий каталог (надкаталог).
<p align=justify>
<i>Корневой каталог и текущий рабочий каталог</i>. Каждый процесс имеет ассоциированный с ним корневой каталог и текущий  рабочий каталог, для того, чтобы определить, как
осуществлять поиск по маршруту. Корневой  каталог  процесса не обязан совпадать с корневым каталогом корневой
файловой системы.
<p align=justify>
<i>Права доступа  к  файлу</i>. Процессу предоставляются права
на чтение, запись и выполнение/просмотр файла, если истинно хотя бы одно из следующих условий:
<ol>
<li>Действующий  идентификатор  пользователя  процесса
есть идентификатор суперпользователя.
<li>Действующий  идентификатор  пользователя  процесса
совпадает с идентификатором владельца файла и  соответствующие  биты для владельца в режиме доступа
к файлу (0700) равны 1.
<li>Действующий идентификатор пользователя процесса не
совпадает с идентификатором  владельца  файла,  но
действующий идентификатор группы процесса совпадает с идентификатором группы файла, и соответствующие  биты  для  группы  в  режиме  доступа к файлу
(0070) равны 1.
<li>Действующий идентификатор пользователя процесса не
совпадает с идентификатором владельца файла и действующий идентификатор группы процесса не совпадает с идентификатором группы файла, но соответствующие биты для прочих пользователей в режиме доступа к файлу (0007) равны 1.
</ol><p align=justify>
Если  все  перечисленные  условия  ложны, прав на соответствующую операцию с файлом у процесса нет.
<p align=justify>
<i>Идентификатор очереди сообщений</i>. Идентификатор  очереди
сообщений  (msqid)  есть уникальное положительное целое
число, возвращаемое системным вызовом <a href=MSGGET.htm>msgget(2)</a>. С каждым таким идентификатором ассоциирована очередь сообщений и структура данных. Структура данных,  обозначаемая
msqid_ds, содержит следующие компоненты:
<pre>
struct ipc_perm msg_perm; /* Структура прав на выполнение операций */
struct msg *msg_first;    /* Указатель на первое сообщение в очереди */
struct msg *msg_last;     /* Указатель на последнее сообщение */
ushort msg_cbytes;/* Текущее число байт в очереди */
ushort msg_qnum;  /* Число сообщений в очереди */
ushort msg_qbytes;/* Макс. допустимое число байт в очереди */
ushort msg_lspid; /* Идентификатор последнего отправителя */
ushort msg_lrpid; /* Идентификатор последнего получателя */
time_t msg_stime; /* Время последн. отправления */
time_t msg_rtime; /* Время последнего получения */
time_t msg_ctime; /* Время последнего изменения */
</pre><dl>
<dt>msg_perm 
<dd>Структура  типа ipc_perm, которая определяет права
на операции с сообщениями (см. ниже). Эта структура содержит следующие элементы:
<pre>
ushort cuid; /* Идентификатор пользователя, создавшего очередь */
ushort cgid; /* Идентификатор группы создателя очереди */
ushort uid;  /* Идентификатор пользователя */
ushort gid;  /* Идентификатор группы */
ushort mode; /* Права на чтение/запись */
ushort seq;  /* Последовательность номеров используемых слотов */
key_t  key;  /* Ключ */
</pre>
<dt>msg_first 
<dd>Указатель на первое сообщение в очереди.
<dt>msg_last 
<dd>Указатель на последнее сообщение в очереди.
<dt>msg_cbytes 
<dd>Текущее количество байт в очереди.
<dt>msg_qnum 
<dd>Текущее количество сообщений в очереди.
<dt>msg_qbytes 
<dd>Максимально допустимое количество байт в очереди.
<dt>msg_lspid 
<dd>Идентификатор процесса, который последним выполнял
операцию msgsnd [см. <a href=MSGOP.htm>msgop(2)</a>].
<dt>msg_lrpid 
<dd>Идентификатор процесса, который последним выполнял
операцию msgrcv [см. <a href=MSGOP.htm>msgop(2)</a>].
<dt>msg_stime 
<dd>Время выполнения последней операции msgsnd.
<dt>msg_rtime 
<dd>Время выполнения последней операции msgrcv.
<dt>msg_ctime 
<dd>Время выполнения последней операции <a href=MSGCTL.htm>msgctl(2)</a>, которая изменила  какой-либо  элемент  вышеописанной
структуры.
</dl><p align=justify>
Время измеряется в секундах, начиная с 00:00:00 1 января 1970 года (по Гринвичу).
<p align=justify>
Права на операции с сообщениями. В  описании  системных
вызовов  <a href=MSGOP.htm>msgop(2)</a> и <a href=MSGCTL.htm>msgctl(2)</a> права, требуемые для операций, записаны в фигурных скобках { и }. Права состоят
в следующем:
<table>
<tr><td>00400<td>Чтение для владельца.</tr>
<tr><td>00200<td>Запись для владельца.</tr>
<tr><td>00040<td>Чтение для группы.</tr>
<tr><td>00020<td>Запись для группы.</tr>
<tr><td>00004<td>Чтение для остальных.</tr>
<tr><td>00002<td>Запись для остальных.</tr>
</table><p align=justify>
Процессу  предоставляются  права  на чтение и запись по
идентификатору очереди, если истинно хотя  бы  одно  из
следующих условий:
<ol>
<li>Действующий  идентификатор  пользователя  процесса
есть идентификатор суперпользователя.
<li>Действующий  идентификатор  пользователя  процесса
совпадает со  значением  компонента  msg_perm.cuid
или msg_perm.uid структуры данных, ассоциированной
с  идентификатором очереди, и соответствующие биты
для владельца в msg_perm.mode (0600) равны 1.
<li>Действующий идентификатор группы процесса совпадает  со  значением  компонента  msg_perm.cgid   или
msg_perm.gid  структуры  данных, ассоциированной с
идентификатором очереди,  и  соответствующие  биты
для группы в msg_perm.mode (0060) равны 1.
<li>Соответствующие  биты  для  прочих пользователей в
msg_perm.mode (0006) равны 1.
</ol><p align=justify>
Если все перечисленные условия  ложны,  прав  на  соответствующую операцию с сообщениями у процесса нет.
<p align=justify>
<i>Идентификатор  множества  семафоров</i>. Идентификатор множества семафоров (semid) есть уникальное  положительное
целое  число, возвращаемое системным вызовом <a href=SEMGET.htm>semget(2)</a>.
С каждым таким идентификатором ассоциировано  множество
семафоров и структура данных. Структура данных, обозначаемая semid_ds, содержит следующие компоненты:
<pre>
struct ipc_perm sem_perm; /* Структура прав на выполнение операций */
struct sem *sem_base;     /* Указатель на первый  семафор в множестве */
ushort sem_nsems; /* Количество семафоров в множестве */
time_t sem_otime; /* Время последней операции */
time_t sem_ctime; /* Время последнего изменения */
</pre><dl>
<dt>sem_perm 
<dd>Структура типа ipc_perm, которая определяет  права
на операции с семафорами (см. ниже). Эта структура
содержит следующие элементы:
<pre>
ushort cuid; /* Идентификатор пользователя, создавшего множество семафоров */
ushort cgid; /* Идентификатор группы создателя множества семафоров */
ushort uid;  /* Идентификатор пользователя */
ushort gid;  /* Идентификатор группы */
ushort mode; /* Права на чтение/изменение */
ushort seq;  /* Последовательность номеров используемых слотов */
key_t  key;  /* Ключ */
</pre>
<dt>sem_base 
<dd>Указатель на первый семафор в множестве  (см.  ниже).
<dt>sem_nsems 
<dd>Количество семафоров в множестве. Каждый семафор в
множестве имеет целый положительный номер, называемый sem_num, и принимает последовательные  значения от 0 до (sem_nsems - 1).
<dt>sem_otime 
<dd>Время последней операции <a href=SEMOP.htm>semop(2)</a>.
<dt>sem_ctime 
<dd>Время последней операции <a href=SEMCTL.htm>semctl(2)</a>, которая  изменила какой-либо элемент вышеописанной структуры.
</dl>
<p align=justify>
Время измеряется в секундах, начиная с 00:00:00 1 января 1970 года (по Гринвичу).
<p align=justify>
<i>Семафор</i> - это структура, содержащая следующие элементы:
<pre>
ushort semval;  /* Значение семафора */
short  sempid;  /* Идентификатор процесса, выполнявшего последнюю операцию */
ushort semncnt; /* Число процессов, ожидающих увеличения значения семафора */
ushort semzcnt; /* Число процессов, ожидающих обнуления значения семафора */
</pre><dl>
<dt>semval 
<dd>Неотрицательное  целое число, являющееся значением
семафора.
<dt>sempid 
<dd>Идентификатор процесса, который последним выполнял
какую-либо операцию с данным семафором.
<dt>semncnt 
<dd>Счетчик числа процессов, ожидающих, когда значение
данного семафора станет больше его текущего значения.
<dt>semzcnt 
<dd>Счетчик числа процессов, ожидающих, когда значение
данного семафора станет равным нулю.
</dl><p align=justify>
Права на операции с семафорами.  В  описании  системных
вызовов  <a href=SEMOP.htm>semop(2)</a> и <a href=SEMCTL.htm>semctl(2)</a> права, требуемые для операций, записаны в фигурных скобках { и }. Права состоят
в следующем:
<table>
<tr><td>00400<td>Чтение для владельца.</tr>
<tr><td>00200<td>Изменение для владельца.</tr>
<tr><td>00040<td>Чтение для группы.</tr>
<tr><td>00020<td>Изменение для группы.</tr>
<tr><td>00004<td>Чтение для остальных.</tr>
<tr><td>00002<td>Изменение для остальных.</tr>
</table>
<p align=justify>
Процессу предоставляются права на  чтение  и  изменение
значений семафоров  по  идентификатору  множества, если
истинно хотя бы одно из следующих условий:
<ol>
<li>Действующий  идентификатор  пользователя  процесса
есть идентификатор суперпользователя.
<li>Действующий  идентификатор  пользователя  процесса
совпадает  со  значением  компонента sem_perm.cuid
или sem_perm.uid структуры данных, ассоциированной
с идентификатором  множества  семафоров,  и  соответствующие  биты  для  владельца  в sem_perm.mode
(0600) равны 1.
<li>Действующий идентификатор группы процесса совпадает  со  значением  компонента  sem_perm.cgid   или
sem_perm.gid  структуры  данных, ассоциированной с
идентификатором множества семафоров, и  соответствующие биты для группы в sem_perm.mode (0060) равны 1.
<li>Соответствующие биты для  прочих  пользователей  в
sem_perm.mode (0006) равны 1.
</ol><p align=justify>
Если все перечисленные условия  ложны,  прав  на  соответствующую операцию с семафорами у процесса нет.
<p align=justify>
<i>Идентификатор разделяемого сегмента памяти</i>. Идентификатор  разделяемого сегмента памяти (shmid) есть уникальное положительное целое число,  возвращаемое  системным
вызовом <a href=SHMGET.htm>shmget(2)</a>. С каждым таким идентификатором ассоциирован сегмент памяти (называемый разделяемым сегментом)  и структура данных. Заметим, что разделяемый сегмент памяти должен быть явно удален пользователем после
того, как удалена последняя ссылка на сегмент. Структура данных, обозначаемая  shmid_ds,  содержит  следующие
компоненты:
<pre>
struct ipc_perm shm_perm; /* Структура прав на выполнение операций */
int    shm_segsz; /* Размер сегмента */
struct region *shm_reg;   /* Указатель на структуру области памяти */
char   pad[4];    /* Информация для подкачки */
ushort shm_lpid;  /* Идентификатор процесса, вып. последнюю операцию */
ushort shm_cpid;  /* Идентификатор процесса, создавшего сегмент */
ushort shm_nattch;/* Число процессов, подсоединивших сегмент */
ushort shm_cnattch;       /* Для shminfo */
time_t shm_atime; /* Время последнего подсоединения */
time_t shm_dtime; /* Время последнего отсоединения */
time_t shm_ctime; /* Время последнего изменения */
</pre><dl>
<dt>shm_perm 
<dd>Структура типа ipc_perm, которая определяет  права
на  операции с разделяемыми сегментами (см. ниже).
Эта структура содержит следующие элементы:
<pre>
ushort cuid; /* Идентификатор пользователя, создавшего сегмент */
ushort cgid; /* Идентификатор группы создателя сегмента */
ushort uid;  /* Идентификатор пользователя */
ushort gid;  /* Идентификатор группы */
ushort mode; /* Права на чтение/изменение */
ushort seq;  /* Последовательность номеров используемых слотов */
key_t  key;  /* Ключ */
</pre>
<dt>shm_segsz 
<dd>Размер разделяемого сегмента памяти в байтах.
<dt>shm_lpid 
<dd>Идентификатор   процесса,  последним  выполнившего
операцию <a href=SHMOP.htm>shmop(2)</a>.
<dt>shm_cpid 
<dd>Идентификатор процесса,  создавшего  идентификатор
разделяемого сегмента памяти.
<dt>shm_nattch 
<dd>Счетчик  количества  процессов, к которым в данный
момент подсоединен разделяемый сегмент памяти.
<dt>shm_atime 
<dd>Время последней операции shmat(2).
<dt>shm_dtime 
<dd>Время последней операции shmdt(2).
<dt>shm_ctime 
<dd>Время последней операции <a href=SHMCTL.htm>shmctl(2)</a>, которая  изменила какой-либо элемент вышеописанной структуры.
</dl><p align=justify>
Время измеряется в секундах, начиная с 00:00:00 1 января 1970 года (по Гринвичу).
<p align=justify>
Права  на  операции с разделяемыми сегментами памяти. В
описании системных вызовов <a href=SHMOP.htm>shmop(2)</a> и <a href=SHMCTL.htm>shmctl(2)</a>  права,
требуемые для операций, записаны в фигурных скобках { и
}. Права состоят в следующем:
<table>
<tr><td>00400<td>Чтение для владельца.</tr>
<tr><td>00200<td>Запись для владельца.</tr>
<tr><td>00040<td>Чтение для группы.</tr>
<tr><td>00020<td>Запись для группы.</tr>
<tr><td>00004<td>Чтение для остальных.</tr>
<tr><td>00002<td>Запись для остальных.</tr>
</table><p align=justify>
Процессу предоставляется право на чтение или  запись  в
разделяемый  сегмент  памяти, если истинно хотя бы одно
из следующих условий:
<oL>
<li>Действующий  идентификатор  пользователя  процесса
есть идентификатор суперпользователя.
<li>Действующий  идентификатор  пользователя  процесса
совпадает  со  значением  компонента shm_perm.cuid
или shm_perm.uid структуры данных, ассоциированной
с идентификатором разделяемого сегмента,  и  соответствующие  биты  для  владельца  в shm_perm.mode
(0600) равны 1.
<li>Действующий идентификатор группы процесса совпадает  со  значением  компонента  shm_perm.cgid   или
shm_perm.gid  структуры  данных, ассоциированной с
идентификатором  разделяемого  сегмента,  и  соответствующие биты для группы в shm_perm.mode (0060)
равны 1.
<li>Соответствующие  биты  для  прочих пользователей в
shm_perm.mode (0006) равны 1.
</ol><p align=justify>
Если  все  перечисленные  условия  ложны, прав на соответствующую операцию с разделяемым  сегментом  памяти у
процесса нет.
<p align=justify>
<i>Псевдоустройства</i>.  Набор  механизмов  ядра операционной
системы UNIX, поддерживающих развитие сетевых  услуг  и
коммуникационных драйверов, называется механизмом псевдоустройств.  Он определяет стандарт интерфейса для посимвольного ввода/вывода внутри ядра и  между  ядром  и
пользовательскими  процессами. Механизм псевдоустройств
состоит из утилит, средств ядра и набора структур  данных.
<p align=justify>
<i>Поток</i>.  Поток - это полнодуплексный канал данных внутри
ядра, связывающий пользовательский процесс с драйвером.
Основными компонентами потока являются исток, драйвер и
ноль или более модулей между истоком и драйвером. Поток
аналогичен каналу в shell'е, за исключением  того,  что
данные  в  потоке перемещаются и обрабатываются в обоих
направлениях.
<p align=justify>
<i>Исток</i>. Исток - это компонент потока, который  обеспечивает интерфейс между потоком и пользовательским процессом.  Основная  функция истока состоит в обработке системных вызовов, относящихся к  псевдоустройствам,  и  в
передаче  данных между пользовательским процессом и потоком.
<p align=justify>
<i>Драйвер</i>. В потоке драйвер обеспечивает интерфейс  между
периферийным  оборудованием  и  потоком.  Драйвер может
быть и псевдодрайвером,  таким  как  мультиплексор  или
драйвер  ошибок [см. <a href=LOG.htm>log(7)</a>], которые не связаны с реальным устройством.
<p align=justify>
<i>Модуль</i>. Модуль - это компонент потока, содержащий программы  обработки  входных  и выходных данных. Он всегда
располагается в середине потока, между истоком и  драйвером.  Для  псевдоустройств  модули играют ту же роль,
что и команды в конвейере shell'а, с  тем  существенным
отличием, что модуль содержит пару функций, позволяющих
независимо  передавать  (и  обрабатывать) данные в двух
направлениях - вниз и вверх.
<p align=justify>
<i>Вниз</i>. В потоке - направление от истока к драйверу.
<p align=justify>
<i>Вверх</i>. В потоке - направление от драйвера к истоку.
<p align=justify>
<i>Сообщение</i>. В потоке сообщение - это один или более блоков данных вместе с управляющими структурами псевдоустройства.  Определено  несколько  типов  сообщений;  тип
идентифицирует содержание сообщения. Механизм сообщений
- единственный способ передачи данных в потоке.
<p align=justify>
<i>Очередь сообщений</i>. В потоке  очередь  сообщений  -  это
список сообщений, ожидающих обработки модулем или драйвером.
<p align=justify>
<i>Очередь  чтения</i>.  В потоке очередь чтения - это очередь
сообщений, направленных вверх.
<p align=justify>
<i>Очередь записи</i>. В потоке очередь записи -  это  очередь
сообщений, направленных вниз.
<p align=justify>
<i>Мультиплексор</i>. Мультиплексор - это драйвер, позволяющий
потокам, ассоциированным с несколькими пользовательскими процессами, подсоединиться к одному драйверу или  же
нескольким  драйверам подсоединиться к одному пользовательскому процессу. Механизм псевдоустройств не предоставляет универсальный мультиплексор,  но  содержит  все
необходимые  средства  для  создания  мультиплексоров и
связывания мультиплексированных потоков.
<p align=justify><b>ПРИМЕЧАНИЯ</b><br>
Информацию, относящуюся к системе разделения  удаленных
файлов (РУФ), следует принимать во внимание, только если на Вашей установке есть соответствующее аппаратное и
программное обеспечение; в стандартную конфигурацию оно
не входит.
<p><b>СМ. ТАКЖЕ</b><br>
<a href=INTRO~~7.htm>intro(3)</a>.
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/footer0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table>
</body>
</html>
