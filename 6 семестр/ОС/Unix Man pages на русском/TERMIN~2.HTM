<html>
<head>
<title>TERMINFO(5)</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/header0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="_pic_/logo.gif" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>

<h3 align=center>TERMINFO(5)</h3>
<p><b>НАЗВАНИЕ</b><br>
terminfo - База данных средств терминала
<p><b>СИНТАКСИС</b>
<pre>
     /usr/lib/terminfo/*/*
</pre>
<p align=justify><b>ОПИСАНИЕ</b><br>
terminfo - база данных, описывающая терминалы, используемая с помощью с помощью terminfo(2).  Терминалы описываются  в
terminfo множеством средств,  которыми они располагают, и описанием, как выполняется операция. Требования заполнения и последовательности инициализации включаются в terminfo.
<p align=justify>
Входы в terminfo состоят из множества полей,  разделенных
запятой ','.  Пробелы после каждой ','  игнорируются.   Первый
вход для  каждого  терминала  дает различные имена,  известные
терминалу. Каждый из этих входов разделяется "|".  Первое  заданное имя - наиболее общая аббревиатура для терминала, (называемая "корневым именем"),  последнее заданное имя должно быть
длинным именем,   полностью  идентифицирующем терминал,  и все
другие воспринимаются как синонимы имени терминала. Все имена,
кроме последнего,  должны состоять из больших букв и не содержать пробелов; последнее имя может содержать большие  буквы  и
пробелы для читабельности.
<p align=justify>
Имена терминалов  (кроме  последнего входа)  должны выбираться при  использовании  следующих  обозначений.   Отдельная
аппаратная часть,   выполняющая  роль терминала,  должна иметь
выбранное корневое имя,  например,  "h2621". Это имя не должно
содержать черточки,  за исключением тех синонимов, которые могут быть выбраны,  и не конфликтующих с другими именами. Режимы, в которых может находиться аппартура, или которые не предпочитает пользователь,    должны   указываться,    присоединив
черточку к указателю режима.  Так,  vt-100 в режиме со 132 колонками должен быть vt100-w. Когда возможно, следует использовать следующие суффиксы:
<table>
<tr><th>Суффикс<th>Значение<th>Пример</tr>
<tr><td>-w<td>Широкий режим (более чем 80 колонок)<td>vt100-w</tr>
<tr><td>-am<td>С автоматическими краями (обычно по умолчанию)<td>vt100-am</tr>
<tr><td>-nam<td>Без автоматических краев<td>vt100-nam</tr>
<tr><td>-n<td>Число строк на экране<td>aaa-60</tr>
<tr><td>-na<td>Нет ключей-стрелок (оставляет их на месте)<td>c100-na</tr>
<tr><td>-np<td>Число страниц в памяти<td>c100-4p</tr>
<tr><td>-rv<td>Инверсионный видео<td>c100-rv</tr>
</table>
<p align=justify>
В следующей таблице "variable" - имя,  с помощью которого
программист (использующий библиотеку terminfo) обозначает возможность. "capname" - короткое имя, используемое в тексте базы
данных и с помощью персонального модернизирования базы данных.
"i.code" - внутренний код из двух букв,  используемый при составлении базы данных, и всегда соответствует имени возможности
termcap(5).
<p align=justify>
Имя возможности не имеет жесткого предела длины,  но формальный предел из 5 символов позаимствован для  сохранения  их
краткости. Всякий раз,  когда возможно,  имена выбираются так,
чтобы быть такими же или подобными ANSI X3.64-1979  стандарту.
Семантики, также,  предназначаются для сопоставления их спецификаций.
<ul>
<li><b>(P)</b> указывает, что наполнение может быть определено.
<li><b>(G)</b> указывает, что строка, заданная (#i), пропускается через tparm с parms.
<li><b>(*)</b> указывает, что наполнение может базироваться на  количестве взаимодействующих строк.
<li><b>(#i)</b> указывает i-ый параметр
<li><b>(+)</b> Не представлена во всех версиях termcap.
</ul>
<table>
<tr><th>Variable<th>Capname<th>I. Code<th>Description</tr>
<tr valign=top><th colspan=4>Booleans:</tr>
<tr valign=top><td>аuto_left_margin<td>bw<td>bw<td>cub1 заворачивается от столбца 0 до последнего столбца.</tr>
<tr valign=top><td>auto_right_margin<td>am<td>am<td>Терминал имеет автоматические границы.</tr>
<tr valign=top><td>beehive_glitch<td>xsb<td>xb<td>"Улей" (f1-Escape; f2 - Ctrl C)</tr>
<tr valign=top><td>ceol_standout_glitch<td>xhp<td>xs<td>Впереди стоящие символы не перезаписываются (hp)</tr>
<tr valign=top><td>eat_newline_glitch<td>xenl<td>xn<td>Символы новой строки игнорируются после 80-го столобца (Concept)</tr>
<tr valign=top><td>erase_overstrike<td>eo<td>eo<td>Можно забивать лишние символы пробелом</tr>
<tr valign=top><td>generic_type<td>gn<td>gn<td>Родовой тип строки (напр., dialup, switch)</tr>
<tr valign=top><td>hard_copy<td>hc<td>hc<td>Терминал твердой копии</tr>
<tr valign=top><td>has_meta_key<td>km<td>km<td>Имеется мета-клавиша (верх. регистр, устанавливает бит контроля)</tr>
<tr valign=top><td>has_status_line<td>hs<td>hs<td>Имеется дополнительная "строка состояния"</tr>
<tr valign=top><td>insert_null_glitch<td>in<td>in<td>Режим вставки отличается символами "пусто"</tr>
<tr valign=top><td>memory_above<td>da<td>da<td>Изображение может быть сохранено перед экраном</tr>
<tr valign=top><td>memory_below<td>db<td>db<td>Изображение может быть сохранено под экрананом</tr>
<tr valign=top><td>move_insert_mode<td>mir<td>mi<td>Предохранять от перемещения в режиме вставки</tr>
<tr valign=top><td>move_standout_mode<td>msgr<td>ms<td>Предохранять от перемещения режимах standout</tr>
<tr valign=top><td>over_strike<td>os<td>os<td>Лишние набранные символы терминала</tr>
<tr valign=top><td>status_line_esc_ok<td>eslok<td>es<td>В строке состояния может быть использован Escape</tr>
<tr valign=top><td>teleray_glitch<td>xt<td>xt<td>"Разрушенные" табуляции, символ magic so</tr>
<tr valign=top><td>tilde_glitch<td>hz<td>hz<td>Hazeltine; невозможна печать символов ~</tr>
<tr valign=top><td>transparent_underline<td>ul<td>ul<td>Лишние вводы символа подчеркивания</tr>
<tr valign=top><td>xon_xoff<td>xon<td>xo<td>Терминал использует хэншейкинг XON/XOFF</tr>
<tr valign=top><th colspan=4>Числовые:</tr>
<tr valign=top><td>columns<td>cols<td>co<td>Количество столбцов в строке</tr>
<tr valign=top><td>init_tabs<td>it<td>it<td>Изначально заместить табуляциями каждые # пробелов</tr>
<tr valign=top><td>lines<td>lines<td>li<td>Количество строк на экране или странице</tr>
<tr valign=top><td>lines_of_memory<td>lm<td>lm<td>Строк в памяти (если больше, чем lines). Значение 0 указывает, что величина переменна</tr>
<tr valign=top><td>magic_cookie_glitch<td>xmc<td>sg<td>Количество пробелов, оставляемых smso и rmso.</tr>
<tr valign=top><td>padding_baud_rate<td>pb<td>pb<td>Нижнее значение бод, при котором требуется заполнение символами cr/nl.</tr>
<tr valign=top><td>virtual_terminal<td>vt<td>vt<td>Виртуальный номер терминала (система UNIX)</tr>
<tr valign=top><td>width_status_line<td>wsl<td>ws<td>Кол-во столбцов в строке состояния</tr>
<tr valign=top><th colspan=4>Строковые:</tr>
<tr valign=top><td>back_tab<td>cbt<td>bt<td>Обратная табуляция (Р)</tr>
<tr valign=top><td>bell<td>bel<td>bl<td>Звуковой сигнал (Р)</tr>
<tr valign=top><td>carriage_return<td>cr<td>cr<td>Возврат каретки (Р*)</tr>
<tr valign=top><td>change_scroll_region<td>csr<td>cs<td>Изменение на строки от #1 до #2 (vt-100) (PG)</tr>
<tr valign=top><td>clear_all_tabs<td>tbc<td>ct<td>Прочистить все позиции табуляции (Р)</tr>
<tr valign=top><td>clear_screen<td>clear<td>cl<td>Очистка экрана и установка курсора в начальное положение</tr>
<tr valign=top><td>clr_eol<td>el<td>ce<td>Очистка до конца строки</tr>
<tr valign=top><td>clr_eos<td>ed<td>cd<td>Очистка до конца изображения (Р*)</tr>
<tr valign=top><td>column_address<td>hpa<td>ch<td>Установка столбца курсора</tr>
<tr valign=top><td>command_character<td>cmdch<td>CC<td>Установливаемый символ cmd в прототипе</tr>
<tr valign=top><td>cursor_address<td>cup<td>cm<td>Относительное перемещение курсора на экране: строка #1, столбец #2 (PG)</tr>
<tr valign=top><td>cursor_down<td>cud1<td>do<td>Вниз на одну строку</tr>
<tr valign=top><td>cursor_home<td>home<td>ho<td>Курсор в начальное положение (если не cup)</tr>
<tr valign=top><td>cursor_invisible<td>civis<td>vi<td>Сделать курсор невидимым</tr>
<tr valign=top><td>cursor_left<td>cub1<td>le<td>Передвинуть курсор влево на одну позицию</tr>
<tr valign=top><td>cursor_mem_address<td>mrcup<td>CM(+)<td>Относительная адресация курсора в памяти</tr>
<tr valign=top><td>cursor_normal<td>cnorm<td>ve<td>Сделать курсор обычным (переделать vs/vi)</tr>
<tr valign=top><td>cursor_right<td>cuf1<td>nd<td>Неразрушительное перемещение курсора (курсор вправо)</tr>
<tr valign=top><td>cursor_to_ll<td>ll<td>ll<td>Последняя строка, первый столбец (если не сup)</tr>
<tr valign=top><td>cursor_up<td>cuul<td>up<td>Вверх на строку (курсор вверх)</tr>
<tr valign=top><td>cursor_visible<td>cvvis<td>vs<td>Сделать курсор видимым</tr>
<tr valign=top><td>delete_character<td>dch1<td>dc<td>Удаление символа (Р*)</tr>
<tr valign=top><td>delete_line<td>dll<td>dl<td>Удаление сторки (Р*)</tr>
<tr valign=top><td>dis_status_line<td>dsl<td>ds<td>Сделать небоступной строку состояния</tr>
<tr valign=top><td>down_half_line<td>hd<td>hd<td>Вниз на половину строки (вперед на 1/2 перевода строки)</tr>
<tr valign=top><td>enter_alt_charset_mode<td>smacs<td>as<td>Начать альтернативный набор символов (Р)</tr>
<tr valign=top><td>enter_blink_mode<td>blink<td>mb<td>Включить режим мерцания</tr>
<tr valign=top><td>enter_bold_mode<td>bold<td>md<td>Включить режим повышеной яркости</tr>
<tr valign=top><td>enter_ca_mode<td>smcup<td>ti<td>Цепочка для начала программ, которые используют cups</tr>
<tr valign=top><td>enter_delete_mode<td>smdc<td>dm<td>Режим удачения (ввод)</tr>
<tr valign=top><td>enter_dim_mode<td>dim<td>mh<td>Включить режим половинной яркости</tr>
<tr valign=top><td>enter_insert_mode<td>smir<td>im<td>Режим вставки (ввод)</tr>
<tr valign=top><td>enter_protected_mode<td>prot<td>mp<td>Включить режим защиты</tr>
<tr valign=top><td>enter_reverse_mode<td>rev<td>mr<td>Включить обратный видеорежим</tr>
<tr valign=top><td>enter_secure_mode<td>invis<td>mk<td>Включить режим пробелов (символы невидимы)</tr>
<tr valign=top><td>enter_standout_mode<td>smso<td>so<td>Начать режим standout</tr>
<tr valign=top><td>enter_underline_mode<td>smul<td>us<td>Начать режим подчеркивания</tr>
<tr valign=top><td>erase_chars<td>ech<td>ec<td>Стереть #1 символов (PG)</tr>
<tr valign=top><td>exit_alt_charset_mode<td>rmacs<td>ae<td>Завершить альтернативный набор символов</tr>
<tr valign=top><td>exit_attribute_mode<td>sgr0<td>me<td>Выключить все атрибуты</tr>
<tr valign=top><td>exit_ca_mode<td>rmcup<td>te<td>Цепочка для завершения программ, которые используют cups</tr>
<tr valign=top><td>exit_delete_mode<td>rmdc<td>ed<td>Завершить режим удаления</tr>
<tr valign=top><td>exit_insert_mode<td>rmir<td>ei<td>Завершить режим вставки</tr>
<tr valign=top><td>exit_standout_mode<td>rmso<td>se<td>Завершить режим standout</tr>
<tr valign=top><td>exit_underline_mode<td>rmul<td>ue<td>Завершить режим подчеркивания</tr>
<tr valign=top><td>flash_screen<td>flash<td>vb<td>Символ звукового сигнала видим (может не переместить курсор)</tr>
<tr valign=top><td>form_feed<td>ff<td>ff<td>Прогон страницы твердой копии (Р*)</tr>
<tr valign=top><td>from_status_line<td>fsl<td>fs<td>Возврат из строки состояния</tr>
<tr valign=top><td>init_1string<td>is1<td>i1<td>Строка инициализации терминала</tr>
<tr valign=top><td>init_2string<td>is2<td>i2<td>Строка инициализации терминала</tr>
<tr valign=top><td>init_3string<td>is3<td>i3<td>Строка инициализации терминала</tr>
<tr valign=top><td>init_file<td>if<td>if<td>Имя файла, содержащего is</tr>
<tr valign=top><td>insert_characters<td>ich1<td>ic<td>Вставка символа (Р)</tr>
<tr valign=top><td>insert_line<td>il1<td>al<td>Добавление пустой строки (Р*)</tr>
<tr valign=top><td>insert_padding<td>ip<td>ip<td>После вставленного символа вставить символ-заполнитель</tr>
<tr valign=top><td>key_backspace<td>kbs<td>kb<td>Посылается клавишей "шаг назад"</tr>
<tr valign=top><td>key_catab<td>ktbc<td>ka<td>Посылается клавишей очистки всех табуляций</tr>
<tr valign=top><td>key_clear<td>kclr<td>kC(+)<td>Посылается клавишами очистки экрана или стирания</tr>
<tr valign=top><td>key_ctab<td>kctab<td>kt<td>Посылается клавишей очистки табуляции</tr>
<tr valign=top><td>key_dc<td>kdchl<td>kD(+)<td>Посылается клавишей удаления</tr>
<tr valign=top><td>key_dl<td>kdll<td>kL(+)<td>Посылается клавишей удаления строки</tr>
<tr valign=top><td>key_down<td>kcud1<td>kd<td>Посылается клавишей "стрелка вниз" терминала</tr>
<tr valign=top><td>key_eic<td>krmir<td>kM(+)<td>Посылается rmir или smir в режиме вставки</tr>
<tr valign=top><td>key_eol<td>kel<td>kE(+)<td>Посылается клавишей очистки до конца строки</tr>
<tr valign=top><td>key_eos<td>ked<td>kS(+)<td>Посылается клавишей очистки до конца экрана</tr>
<tr valign=top><td>key_f0<td>kf0<td>k0<td>Посылается функциональной клавишей f0</tr>
<tr valign=top><td>key_f1<td>kf1<td>k1<td>Посылается функциональной клавишей f1</tr>
<tr valign=top><td>key_f10<td>kf10<td>k<td>Посылается функциональной клавишей f10</tr>
<tr valign=top><td>key_f2<td>kf2<td>k2<td>Посылается функциональной клавишей f2</tr>
<tr valign=top><td>key_f3<td>kf3<td>k3<td>Посылается функциональной клавишей f3</tr>
<tr valign=top><td>key_f4<td>kf4<td>k4<td>Посылается функциональной клавишей f4</tr>
<tr valign=top><td>key_f5<td>kf5<td>k5<td>Посылается функциональной клавишей f5</tr>
<tr valign=top><td>key_f6<td>kf6<td>k6<td>Посылается функциональной клавишей f6</tr>
<tr valign=top><td>key_f7<td>kf7<td>k7<td>Посылается функциональной клавишей f7</tr>
<tr valign=top><td>key_f8<td>kf8<td>k8<td>Посылается функциональной клавишей f8</tr>
<tr valign=top><td>key_f9<td>kf9<td>k9<td>Посылается функциональной клавишей f9</tr>
<tr valign=top><td>key_home<td>khome<td>kh<td>Посылается клавишей home</tr>
<tr valign=top><td>key_ic<td>kich1<td>kl<td>Посылается клавишами вставки/ ввода в режиме вставки</tr>
<tr valign=top><td>key_il<td>kill<td>kA(+)<td>Посылается вставкой строки</tr>
<tr valign=top><td>key_left<td>kcub1<td>kl<td>Посылается клавишей "стрелка влево"</tr>
<tr valign=top><td>key_ll<td>kll<td>kH(+)<td>Посылается клавишей home-down</tr>
<tr valign=top><td>key_npage<td>knp<td>kN(+)<td>Посылается клавишей следующей страницы</tr>
<tr valign=top><td>key_ppage<td>kpp<td>kP(+)<td>Посылается клавишей предыдущей страницы</tr>
<tr valign=top><td>key_right<td>kcuf1<td>kr<td>Посылается клавишей "стрелка вправо"</tr>
<tr valign=top><td>key_sf<td>kind<td>kF(+)<td>Посылается клавишей прокрутки вперед/вниз</tr>
<tr valign=top><td>key_sr<td>kri<td>kR(+)<td>Посылается клавишей прокрутки назад/вверх</tr>
<tr valign=top><td>key_stab<td>khts<td>kT(+)<td>Посылается клавишей установки табуляции</tr>
<tr valign=top><td>key_up<td>kcuu1<td>ku<td>Посылается клавишей "стрелка вверх"</tr>
<tr valign=top><td>keypad_local<td>rmkx<td>ke<td>Вне режима "keypad transmit"</tr>
<tr valign=top><td>keypad_xmit<td>smkx<td>ks<td>Перевести терминал в режим "keypad transmit"</tr>
<tr valign=top><td>lab_f0<td>lf0<td>l0<td>Метки на функциональной клавише f0, если не f0</tr>
<tr valign=top><td>lab_f1<td>lf1<td>l1<td>Метки на функциональной клавише f1, если не f1</tr>
<tr valign=top><td>lab_f10<td>lf10<td>la<td>Метки на функциональной клавише f10, если не f10</tr>
<tr valign=top><td>lab_f2<td>lf2<td>l2<td>Метки на функциональной клавише f2, если не f2</tr>
<tr valign=top><td>lab_f3<td>lf3<td>l3<td>Метки на функциональной клавише f3, если не f3</tr>
<tr valign=top><td>lab_f4<td>lf4<td>l4<td>Мeтки на функциональной клавише f4, если не f4</tr>
<tr valign=top><td>lab_f5<td>lf5<td>l5<td>Метки на функциональной клавише f5, если не f5</tr>
<tr valign=top><td>lab_f6<td>lf6<td>l6<td>Метки на функциональной клавише f6, если не f6</tr>
<tr valign=top><td>lab_f7<td>lf7<td>l7<td>Метки на функциональной клавише f7, если не f7</tr>
<tr valign=top><td>lab_f8<td>lf8<td>l8<td>Метки на функциональной клавише f8, если не f8</tr>
<tr valign=top><td>lab_f9<td>lf9<td>l9<td>Метки на функциональной клавише f9, если не f9</tr>
<tr valign=top><td>meta_on<td>smm<td>mm<td>Включение режима "meta mode"</tr>
<tr valign=top><td>meta_off<td>rmm<td>mo<td>Выключение режима "meta mode"</tr>
<tr valign=top><td>newline<td>nel<td>nw<td>Новая строка (ведет себя как cr, за которым следует lf)</tr>
<tr valign=top><td>pad_char<td>pad<td>pc<td>Символ-заполнитель (вместо пустого символа)</tr>
<tr valign=top><td>parm_dch<td>dch<td>DC(+)<td>Удалить #1 символов (PG*)</tr>
<tr valign=top><td>parm_delete_line<td>dl<td>DL(+)<td>Удалить #1 строк (PG*)</tr>
<tr valign=top><td>parm_down_cursor<td>cud<td>DO(+)<td>Переместить курсор вниз на #1 строк (PG*)</tr>
<tr valign=top><td>parm_ich<td>ich<td>IC(+)<td>Вставить #1 пробелов (PG*)</tr>
<tr valign=top><td>parm_index<td>indn<td>SF(+)<td>Прокрутка вперед на #1 строк (PG)</tr>
<tr valign=top><td>parm_insert_line<td>il<td>AL(+)<td>Добавить #1 пустых строк (PG*)</tr>
<tr valign=top><td>parm_left_cursor<td>cub<td>LE(+)<td>Переместить курсор влево на #1 позиций (PG*)</tr>
<tr valign=top><td>parm_right_cursor<td>cuf<td>RI(+)<td>Переместить курсор вправо на #1 позиций (PG*)</tr>
<tr valign=top><td>parm_rindex<td>rin<td>SR(+)<td>Прокрутка назад на #1 строк (PG)</tr>
<tr valign=top><td>parm_up_cursor<td>cuu<td>UP(+)<td>Переместить курсор вверх на #1 строк (PG*)</tr>
<tr valign=top><td>pkey_key<td>pfkey<td>pk<td>Программная функциональная клавиша #1 для печати строки #2</tr>
<tr valign=top><td>pkey_local<td>pfloc<td>pl<td>Программная функциональная клавиша #1 для выполнения строки #2</tr>
<tr valign=top><td>pkey_xmit<td>pfx<td>px<td>Программная функциональная клавиша #1 для передачи строки #2</tr>
<tr valign=top><td>print_screen<td>mc0<td>ps<td>Печать сожержимого экрана</tr>
<tr valign=top><td>prtr_off<td>mc4<td>pf<td>Включение принтера</tr>
<tr valign=top><td>repeat_char<td>rep<td>rp<td>Выключение принтера</tr>
<tr valign=top><td>reset1_string<td>rs1<td>r1<td>Полный сброс терминала в обычные режимы</tr>
<tr valign=top><td>reset2_string<td>rs2<td>r2<td>Полный сброс терминала в обычные режимы</tr>
<tr valign=top><td>reset3_string<td>rs3<td>r3<td>Полный сброс терминала в обычные режимы</tr>
<tr valign=top><td>reset_file<td>rf<td>rf<td>Имя файла, содержащего строку сброса</tr>
<tr valign=top><td>restore_cursor<td>rc<td>rc<td>Установка курсора в позицию последнего sc</tr>
<tr valign=top><td>row_address<td>vpa<td>cv<td>Абсолютная позиция по вертикали (строка установки) (PG)</tr>
<tr valign=top><td>save_cursor<td>sc<td>sc<td>Сохранение позиции курсора (Р)</tr>
<tr valign=top><td>scroll_forward<td>ind<td>sf<td>Прокрутка текста вверх (Р)</tr>
<tr valign=top><td>scroll_reverse<td>ri<td>sr<td>Прокрутка текста вниз (Р)</tr>
<tr valign=top><td>set_attributes<td>sgr<td>sa<td>Определить видеоатрибуты (PG9)</tr>
<tr valign=top><td>set_tab<td>hts<td>st<td>Проставить табуляции во все столбцы текущей строки</tr>
<tr valign=top><td>set_window<td>wind<td>wi<td>Текущим окном являются строки #1-#2, столбцы #3-#4</tr>
<tr valign=top><td>tab<td>ht<td>ta<td>Табулировать до следующего места табуляции оборудования через 8 позиций</tr>
<tr valign=top><td>to_status_line<td>tsl<td>ts<td>Переход в строку состояния, первый столбец</tr>
<tr valign=top><td>underline_char<td>uc<td>uc<td>Подчеркнуть один символ и встать за ним</tr>
<tr valign=top><td>up_half_line<td>hu<td>hu<td>Вверх на пол-строки (назад на 1/2 прогона строки)</tr>
<tr valign=top><td>init_prog<td>iprog<td>iP<td>Полное имя программы инициализации</tr>
<tr valign=top><td>key_a1<td>ka1<td>K1(+)<td>Верхний левый угол клавиатуры</tr>
<tr valign=top><td>key_a3<td>ka3<td>K3(+)<td>Верхний правый угол клавиатуры</tr>
<tr valign=top><td>key_b2<td>kb2<td>K2(+)<td>Центр клавиатуры</tr>
<tr valign=top><td>key_c1<td>kc1<td>K4(+)<td>Нижний левый угол клавиатуры</tr>
<tr valign=top><td>key_c3<td>kc3<td>K5(+)<td>Нижний правый угол клавиатуры</tr>
<tr valign=top><td>prtr_on<td>mc5p<td>pO(+)<td>Включить принтер для #1 байтов</tr>
</table>
<p align=justify><i>Простой вход</i><br>
Следующий вход,  описывающий Concept-100, находится среди
более сложных в файле terminfo.
<pre>
     concept100 |c100| concept| c104| c100-4p| concept 100,
        am, bel=^G, blank=\EH, blink=\EC, clear=^L$&lt;2*&gt;, cnorm=\Ew,
        cols#80, cr=^M$&lt;9&gt;, cub1=^H, cud1=^J, cuf1=\E=,
        cup=\Ea&p1&' '&+&c&p2&' '&+&c'
        cuu1=\E;, cvvis=\EW, db, dch1=\E^A$&lt;16*&gt;, dim=\EE, d11=\E^B$&lt;3*&gt;,
        ed=\E^C$&lt;16*&gt;, el=\E^U$&lt;16&gt;, eo, flash=\Ek$&lt;20&gt;\Ek, ht=\t$&lt;8&gt;,
        il1=\E^R$&lt;3*&gt;, in, ind=^J, .ind=^J$&lt;9&gt;, ip=$&lt;16*&gt;,
        is2=\EU\Ef\E7\E5\E8\El\ENH\EK\E\200\Eo&\200\Eo\47\E,
        kbs=^h, kcub1=\E&lt;, kcud1=\E&lt;, kcuf1=\E=, kcuu1=\E;,
        kf1=\E5, kf2=\E6, Kf3=\E7, khome=\E?,
        lines#24, mir, pb#9600, prot=\EI, rep=\Er&p1&c&p&2&' '&+&c$&lt;.2*),
        rev=\ED, rmcup=\Ev  $&lt;6&gt;\Ep\r\n, rmir=\E\200, rmkx=\Ex,
        rmso=\Ed\Ee, rmul=\Eg, rmul=\Tg, sgr0=\EN\200,
        smcup=\EU\Ev8p\Ep\r, smir=\E^P, smkx=\EX, smso=\EE\ED,
        smull=\EG, tabs, ul, vt#8, xenl.
</pre>
<p align=justify>Входы могут продолжаться в размноженные строки путем помещения пробелов в начале каждой строки, кроме первой. Строкикомментарии начинаются с '#'. Средства в terminfo - 3-х типов:
булевские средства,  которые указывают, что терминал имеет характерные особенности, числовые средства, задающие размер терминала, и величины конкретных задержек,  строчные средства,задающие последовательности, которые могут быть использованы для
выполнения конкретных операций терминала.
<p align=justify><i>Виды средств</i><br>
Все средства   имеют   имена  .   Например,   факт,   что
Concept-100 имеет automatic margins ( то есть,  автоматический
возврат и продвижение на строку, когда достигается конец строки), отмечается средством am.  Отсюда следует,   что  описание
Concept включает   am.  За числовыми средствами следует символ
"#", и  затем значение. Таким образом, cols, который указывает
количество колонок терминала,  дает значение '80' для Concept.
<p align=justify>Наконец, строкоые  средства,   такие  как el (очистить до
конца последовательность строк),  задаются двухсимвольным  кодом, '=',  затем следует строка, заканчивающаяся ','. Задержка
в миллисекундах может появляться где угодно в  этом  средстве,
заключается в $&lt;..&gt;, как el=\EK$&lt;3&gt;, и символы наполнения поддерживаются tputs для обеспечения этой задержки.  Задержка может быть либо числом,например,  '20',  либо числом, за которым
следует '*', например, '3*'. '*' показывает, что требуемое заполнение пропорционально   числу  строк,  на которые действует
операция, а задаваемое количество является требуемым заполнением
per-affected-unit. (В случае символа вставки  этот  коэффициент
является  числом,  равным количеству задействованных строк. Это
всегда 1, за исключением  тех  случаев,  когда  терминал  имеет
xenl,  и  аппаратура  использует  его.) Когда определяется '*',
иногда полезно задавать задержку в виде '3.5', чтобы определить
задержку на устройство  в  десятках  миллисекунд.  (Допускается
только одно десятичное значение.)
<p align=justify>Количество управляющих последовательностей обеспечивается
строковыми средствами для облегчения раскодирования  символов.
Обе \E  и  \e преобразуются в символ ESCAPE,  ^x преобразует в
ctrl-x для любого соответственного x,  и последовательности \n
\l \r \t\ \b \f \s задают новую строку, linefeed, возврат, табуляцию, backspace, formfeed и пробел. Другие управляющие символы включают \^ для ^, \\ для \, \, для запятой, \: для :, \0
для 0.  (\0 будет вырабатывать \200, который не звершает строку, но  ведет  себя как нулевой символ на большинстве терминалов). Наконец,  символ может задаваться как  три  восьмеричные
цифры после \a.
<p align=justify>Иногда отдельные  средства  могут быть раскомментированы.
Для выполнения этого, помещается период перед названием средства. Например, смотри второй ind в примере, приведенном выше.
<p align=justify><i>Подготовительное описание</i><br>
Наиболее эффективный способ подготовить описание терминала
-  это  имитировать  описание  подобного терминала в terminfo и
постепенно построить описание, используя частичное описание  vi
для проверки правильности. Помните, что наиболее необычные терминалы  могут предъявлять нехватку возможностей файла terminfo,
чтобы описывать их или дефекты в vi.  Для  облегчения  проверки
описания   терминала   вы  можете  поместить  переменную  среды
TERMINFO в составное имя каталога, содержащего полное описание,
с которым вы работаете, и программы будут просматриваться здесь
быстрее, чем в /usr/lib/terminfo. Чтобы получить заполнения для
вставленной строки справа ( если изготовитель терминала не  документировал  это),  серьезный  тест должен редактировать копию
/etc/passwd до 9600 бод, удалить около 16 или 16 строк с  середины экрана и затем много раз быстро нажать 'u'  клавишу.   Если
терминальный дисплей беспорядочен, обычно необходимо большое заполнение. Подобный  тест может использоваться для символа вставки.
<p align=justify><i>Основные средства</i><br>
Числовые средства  cols  описывают число колонок в каждой
строке терминала. Если терминал - CRT, то число строк на экране задается  посредством lines.  Если терминал перескакивает в
начало следующей строки,  когда он достигает правого края,  то
он должен обладать средством am. Если терминал должен очистить
свой экран, оставив свой кусрор в начальной позиции, это задается средством clear. Если терминал делает лишние удары (быстрее чем стирается позиция, когда символ набивается заново), то
используется средство os. Если терминал представляет собой печатающее устройство без мягкой копии, задаются оба средства os
и hc.  (os поддерживается для сохранения терминалов, таких как
TEKTRONIX 4010 серии,  также как твердые копии и APL  терминалы). Если  существует код для продвижения курсора в левый угол
текущего ряда, это задается как cr. (Обычно бывает возврат каретки, ctrl-M).   Если  существует код для выработки звукового
сигнала, то он определяется как bel.
<p align=justify>Существует код для продвижения курсора  на  одну  позицию
влево (такую  как  backspace),   средство следует задавать как
cub1. Аналогично,  коды для продвижения вправо,  вверх и  вниз
определяются как  cuf1,   cuu1 и cud1.  Эти локальные движения
курсора не должны изменять текста,  который они проходят, например, вы обычно не сможете использовать 'cuf1=',  так как область, которую он проходит, будет стираться.
<p align=justify>Важно, что  локальное движения курсора,  закодированное в
terminfo, не  определены в левой и верхней границах  терминала
CRT. Программы    никогда  не должны пытаться делать backspace
влево, если  не задано bw,  и переходить через верх.  По  мере
просмотра текста  назад программа будет идти к левому углу экрана и посылать строку ind.
<p align=justify>По мере просмотра текста вперед программа идет в  верхний
левый угол  экрана  и  посылает  строку  ri (обратный индекс).
Строки ind и ri не определяются, когда они не на соответствующих углах экрана.
<p align=justify>Параметризованными версиями   просматривающих  последовательностей являются indn и rin, имеющие ту же самую семантику,
что и  ind и ri,  кроме тех случаев,  когда они принимают один
параметр и просматривают таким образом много строк.  Они также
не определяются, кроме как, на соответствующих углах экрана.
<p align=justify>Средство am говорит,  был ли курсор нажат справа от экрана,когда выводился текст,  но это не обязательно  поддерживать
средством cuf1  из  последней колонки.  Локальное перемещение,
которое определяется из левого края при заданном bw, существует, при этом cub1 из левого угла будет двигаться в правый угол
предшествующей строки. Если bw не задано, эффект не предсказуем. Это полезно для вычерчивания рамки угла экрана.  Если терминал имеет преключатель,  способный  выбирать  автоматические
края, то файл terminfo обычно потверждает,  что он присутствует; например, am. Если терминал имеют команду, которая перемещает к первой колонки следующей строки, то команда может задаваться как nel (новая строка). Не имеет значения, если команда
очищает остаток текущей строки, поэтому, если терминал не имеет cr и lf, то все же возможно обойтись рабочим nel без  одной
или обоих.
<p align=justify>Этих средств  достаточно  для  описания  твердых  копий и
glass-tty терминалов.  Таким образом, модель 33 телетайпа описывается следующим образом:
<pre>
     33|tty33|ty|model 33 teletype,
     bel=^G, cols#72, cr=^M, cud1=^J, hc,ind=^j, os
</pre>
где Lear Siegler ADM-3 описывается следующим образом:
<pre>
     adm3|3|lsi adm3,
     am, bel=^G, clear=^Z, cols#80, cr=^M, cub1=^H, cud1=^J,
     ind=^J, lines#24
</pre>
<p align=justify><i>Параметризованные строки</i><br>
Адресация  курсора и другие строки, запрашивающе параметры
в терминале, описываются средствами параметризованных строк,  с
помощью  printf(2),  подобно  управвляющему в нем %x. Например,
для адресации курсора используется средство  cup,  использующее
два параметра: строка и колонка для адресации. (Строки и колонки  пронумерованы то 0 и относятся к физическому экрану, за которым наблюдает пользователем, а не к какой-либо невидимой  памяти).  Если терминал имеет относительную адресацию курсора, то
это может быть задано mrcup.
<p align=justify>Механизм параметризации использует стек и специальный код
% для манимулирования. Обычно последовательность помещает один
из параметров в стек и потом печатает его в некотором формате.
Часто необходимы более сложные операции.
<p>% кодирование имеет следующие значения:
<ul>
<li><b>%%</b> выводит '%'
<li><b>%d</b> print pop() как in printf
<li><b>%2d</b> print pop() аналогично %2d
<li><b>%3d</b> print pop() аналогично %3d
<li><b>%02d</b>
<li><b>%03d</b> как in printf
<li><b>%c</b> print pop() дает %с
<li><b>%s</b> print pop() дает %s
<li><b>%p[1-9]</b> проталкивает i-ую переменную
<li><b>%P[a-z]</b> устанавливает переменную [a-z] в pop()
<li><b>%g[a-z]</b> вычисляет переменную [a-z] и протолкивает ее
<li><b>%'c'</b> символ константа с
<li><b>%[nn]</b> целая котстанта nn
<li><b>% + % - %*% /%m</b> арифметика (%m является mod): push(pop() op pop())
<li><b>%& %| %^</b> битовые операции: push(pop() op pop())
<li><b>%= %&gt; %&lt;</b> логические операции: push(pop() op pop())
<li><b>% ! %~ </b> унарные операции: push(op pop())
<li><b>%i</b> прибавить 1 к первым двум параметрам (для терминалов ANSI)
<li><b>% ? expr %t thenpart %e elsepart %;</b> if-then-else, %e elsepart - необязательно.
<li><b>else-if</b> возможны для Algol 68:
<li><b>%?c1 %t b1 %e c2 %t b2 %e c3 %t b3 %e c4 %t b4 %e %;</b> ci - условия, bi - тела.
</ul>
<p align=justify>Операции в  двоичном коде - в виде postfix c операциями в
обычном порядке.  То есть, для того чтобы получить x-5 следует
использовать "%gx%{5}%-".
<p align=justify>Расмотрим HP2645,   которому  для получения 3 строки и 12
колонки требуется послать \E&a12c03Y, происходящее за 6 миллисекунд. Отметим,  что порядок строк и колонок здесь инвертируется, и эти ряд и колонка  печатаются  как  две  цифры.   Так,
средство  2cup 0 означает cup=\E&%p2%dc%p1%2dY$&lt;6&gt;.
<p align=justify>Для Microterm  ACT-IV перед посылкой текущей строки и колонки нужно выполнить ^T,  где строка и колонка закодированы в
двоичном исчислении, cup=^T%p1%c%p2%c. Терминалы, использующие
%, должны обладать свойством backspace курсора (cub1) и передвижением курсора вверх на одну строку (cuu1).  Это необходимо,
так как это не всегда сохраняет передачу \n ^D  и  \r,   когда
система может изменить или убрать их.  (Библиотечные программы
имеют дело с режимами tty набора terminfo, так что таблицы никогда не расширяются,  поэтому \t сохраняется для посылки. Это
существенно для Ann Arbor 4080.)
<p align=justify>И наконец,  пример LSI ADM-IV,  использующий смещение  по
строке и  колонке с помощью символа пробела,  так
cup=\E=%p1%' '%+%c.  После посылки '\E=' помещает первый параметр, значение ASCII для области (32),  складывает их (помещая
сумму в стек на место двух предыдущих значений)  и выводит это
значение в качестве символа.  Затем делает то же самое со вторым параметром.  Возможна более сложная арифметика, использующая стек.
<p align=justify>Если терминал имеет абсолютную адресацию курсора в строке
или колонке,  она может задаваться единственным параметром hpa
(абсолютная горизонтальная  позиция)  и vpa (абсолютная вертикальная позиция).  Иногда они короче, чем более общая последовательность двух  параметров (как в HP2645),  и могут быть использованы в  предпочтении  к cup.   Если  имеются  локальные
параметризованные перемещения  (например,   переместиться на n
позиций вправо),  то они могут быть заданы cud, cub, cuf и cuu
с единстенным  параметром,   показывающим,  на сколько позиций
двигаться. Преимущественно они используются в терминалах,   не
имеющих cup, таких как TEKTRONIX 4025.
<p align=justify><i>Перемещения курсора</i><br>
Если терминал имеет быстрый способ поместить курсор в верхний угол экрана (самый верхний левый угол экрана), то мы задаем это как home; аналогично, быстрый способ достичь левого нижнего угла - использовать ll; это можно получить, поднимаясь
вверх с помощью cuu1 из начальной позиции, но программа никогда
не может выполнить это сама ( до тех пор, пока не сделает ll),
потому что нельзя сделать никаких допущений относительно результата движения вверх из начальной позиции. Отметим, что начальная позиция - то же самое, что и адресация к (0,0): к верхнему левому углу экрана, а не памяти. (Так, последовательность
\EH терминалов HP не может использоваться для  2home 0.)
<p align=justify><i>Очищение области</i><br>
Если терминал  может  очищать остаток строки,  начиная от
текущей позиции,  оставляя курсор на то же месте,  надо задать
el. Если  терминал  может  очищать до конца дисплея от текущей
позиции, то следует задавать ed.  ed  определяется  только  из
первой колонки строки.  (Так,  он может воспроизводиться с помощью запроса об уничтожении большего количества строк,   если
истинное ed не присутствует).
<p align=justify><i>Вставка/уничтожение строки</i><br>
Если терминал может открыть несколько пустых  строк  там,
где расположен курсор,  то это может задавться il1; это выполнимо только в первой позиции строки.  Курсор должен  появиться
на новой пустой строке. Если терминал должен уничтожать строку,
на которой расположен курсор,  то это задается dl1; это выполнимо только в первой позиции строки, которая должна быть уничтожена. Версии il1 и dl1, использующие один параметр и помещающие или уничтожающие несколько строк, могут задаваться как il
и dl.  Если терминал имеет устанавливаемую область  просмотра
(подобную vt-100),  команды,  которые не используют это, могут
быть описаны средством csr,  которое использует два параметра:
начальную и конечную строки просмотра области.  Позиция курсора, однако,  не определена после выполнения этой команды. Возможно получить  результат вставки или вычеркивания строк,  используя команды  sc  и  rc  (  сохранения   и   восстановления
курсора). Вставление  строк  сверху  и снизу экрана может быть
выполнено с помощью ri и ind на многих терминалах без истинной
вставки или вычеркивания строк, и это часто происходит на терминалах, использующих это свойство.
<p align=justify>Если терминал имеет возможность определять окно как часть
памяти, на которую воздействуют все команды,  то это  задается
параметризованной сторкой  wind.  В этом случае используется 4
параметра: начальная и конечная строки в памяти и начальная  и
конечная колонки в памяти, в таком порядке.
<p align=justify>Если терминал  может сохранять дисплейную память над,  то
следует задавать средство da; если дисплейная память  задается
ниже, то db.  Это указывает, что уничтожение строки и просмотр
может доставлять пустые строки вверх снизу,  или  же  просмотр
назад с помощью ri может опускать их сверху.
<p align=justify><i>Вставка/стирание символа</i><br>
Имеется два основных вида разумных терминалов,  что касается вставки/стирания   символа,  которые могут быть описаны с
помощью terminfo.  Наиболее  общие  операции  вставки/стирания
символов затрагивают   символ в такой строке и сдвигают символ
строго с конца строки. Другие терминалы, такие как Concept 100
и Perkin Elmer Owl, делают различие между напечатыванием и ненапечатыванием пробелов на экране,  помещая на место вставляемого или уничтожаемого символа ненапечатанный пробел,  который
также высвечивается или расширяет их их до двух пробелов.   Вы
можете отличать тип терминала, который вы имеете, путем чистки
экрана, затем  печатая текст,  разделенный движением  курсора.
Печатание abc def использует локальные перемещения курсора (не
позиции) между abc и def. Тогда курсор помещается перед abc, и
терминал устанавливается в режим вставки.  Если печатание символов вызывает остаток строки к жесткому сдвигу, и символы отпадают, тогда  ваш терминал не делает различия между пробелами
и ненапечатанными пробелами порциями.  Если "abc" сдвигается к
def, которые   потом вместе начинают двигаться к концу и затем
на следующую вставленную строку, вы имеете второй тип терминала и   должны использовать средство in,  которое устанавливает
для вставки нуль.  Если существуют два  логически  разделенных
аттрибута (одна  строка vs,  режим ввода множественных строк и
специальное обращение с ненапечатанными позициями),  то мы  не
находим терминалов, у которых режим вставки не может быть описан одним аттрибутом.
<p align=justify>terminfo может описывать как терминалы, которые имеют режим
вставки, так и терминалы, посылающие простую последовательность,
чтобы открыть пустую позицию в текущей строке. Чтобы войти в режим вставки,  используется последовательность smir.  Чтобы выйти
из режима встаки используется последовательность  rmir.   Теперь
зададим в   качестве ich1 любую последовательность,  необходимую
для посылки сразу перед тем,  как символ,  который следует вставить. Большинство терминалов с истинным режимом вставки не выдают ich1; терминалы,  посылающие последовательность для  открытия
экрана, должны    его здесь содержать.  (Если терминал имеет оба
средства, то  режим вставки предпочитается ich1.  Не используйте
ни одного,    пока  терминал не потребует их для использования в
комбинации). Если  необходимо последующее (после вставки) заполнение, то    задавайте  его как число миллисекунд в ip (параметр
строки). Любая другая последовательность, которая может потребоваться для посылки после вставки одного символа, также может задаваться в ip.  Если вашему терминалу нужны и режим вставки,   и
специальный код,    который  предшевствует специальному символу,
тогда могут быть заданы smir/rmir и ich1,  и оба могут использоваться. Средства    ich  с одним параметром n повторяют действия
ich1 n раз.
<p align=justify>Иногда бывает  необходимо  повторить  режим  вставки  для
уничтожения символов  в той же строке (например,  если имеется
таблица после вставляемой позиции). Если ваш терминал позволяет перемещение  в процессе режима вставки,  вы можете задавать
средство mir для ускорения вставки в этом  случае.   Избежание
mir будет влиять только на скорость.  Некоторые терминалы (как
Datamedia) не должны  использовать  mir  из-за  работы  режима
вставки.
<p align=justify>И наконец,  вы можете определить dch1 для уничтожения работы одного символа,  dch с одним параметром n для уничтожения
n символов  и режим уничтожения,  задаваемый smdc и rmdc,  для
входа и выхода в него ( любой режим терминала допускается  для
работы в 2 dch1 0).
<p align=justify>Команда для  стирания  символов  (эквивалентная  выводу n
пробелов без перемещения курсора)  может задаваться как ech  c
одним параметром.
<p align=justify><i>Выделение, подчеркивание и видимые сигналы</i><br>
Если ваш терминал имеет один или более  аттрибутов  дисплея, то они будут представлены в ряде  различных способов. Вам
следует выбрать один вид дисплея в режиме standout,  представляющим хороший,   высококонтрастный,  хорошо различимый формат
для яркого высвечивания сообщений об ошибках и других, имеющих
значение выходов. (Если вы имеете выбор, подходит инверсионный
видео полуяркого изображения  или  один  инверсионный  видео).
Последовательности для  входа и выхода в режиме standout задаются соответственно,  как smso и rmso.  Если код для изменения
режима standout оставляет один или два пробела на экране,  как
в TVI 912 и Teleray 1061, то следует задать xmc, для того чтобы сообщить количество оставленных пробелов.
<p align=justify>Коды для начала подчеркивания и конца подчеркивания могут
задаваться соответственно, как smul и rmul. Если терминал имеет код для подчеркивания текущего символа и сдвигает курсор на
позицию вправо, как Microterm Mime, то следует задать uc.
<p align=justify>Другие средства для входа в  различные  режимы  выделения
включают blink   (мерцание),   bold (повышенная яркость),  dim
(средняя яркость),  invis ( пробел или невидимый текст),  prot
(защищенный), rev  (инверсионный видео), sgr0 (выключение аттрибутных режимов all),  smacs (режим ввода  набора  изменяемых
символов). Включение  одного  из  этих режимов может выключать
или не выключать эти режимы.
<p align=justify>Если есть последовательность,  устанавливающая произвольные комбинации режимов,  она должна задаваться, как sgr (признак установки), используя 9 параметров. Каждый параметр, 0 или
1, означает, присутствует или нет соответствующий признак. Эти
9 параметров идут в порядке:  standout,  подчеркивание, инверсия, мерцание,  низкая яркость, высокая яркость, пробел, защита, изменение набора символов.  Не все режимы нуждаются в поддержке с  помощью  sgr  только  те,   для  которых  существуют
соответствующие аттрибуты команд.
<p align=justify>Терминал с глитчем "magic cookie"  (xmc)   приготавливает
специальные "cookies", когда они принимают устанавливающие режимы последовательности,  которые задействуют дисплейный алгоритм ранее, чем принимают дополнительные биты для каждого символа. Некоторые терминалы,  такие как HP 2621,   автоматически
выходят из  режима standout,  когда они передвигаются на новую
строку, или когда адресуется курсор.  Программы,  использующие
режим standout,  должны выйти из этого режима прежде, чем двикать курсор или посылать новую строку,  если  не  присутствует
msrg, допускающее   для   возможности   перемещения  в  режиме
standout.
<p align=justify>Если терминал имеет возможность мерцания экрана для  указания ошибки  (замещающее  звуковой  сигнал),   то  она дается
flash; не должно перемещать курсор.
<p align=justify>Если курсор необходимо сделать более ярким,  когда он  не
на последней строке (выполнить,  например, немерцающее подчеркивание для более легкого поиска блока или мерцающее подчеркивание), то  последовательность  задается  как cviis.  Средство
cnorm должно быть задано, когда допускается влияние на оба эти
режима.
<p align=justify>Если терминал  должен  находится  в специальном режиме во
время выполнения программы,  используя эти средства,  коды для
входа и выхода в этот режим могут задаваться как smcup и rmcup.
<p align=justify>Это увеличивает для терминала, как Сoncept, на более, чем
одну страницу.  Если терминал имеет только относительную адресацию в памяти курсора,  а не относительную адресацию  курсора
на экране, окно размером в экран должно фиксироваться в терминале для аресации курсора для работы надлежащим образом. Также
ээто используется для TEKTRONIX 4025,  где smcup устанавливает
управляющий символ для того,  чтобы использовать его с помощью
terminfo.
<p align=justify>Если ваш терминал правильно генерирует подчеркнутые символы (без требования специальных кодов), даже если они не перебиваются,  то  вам  следует  использовать средство ul.Если лишние
клавиши затираются пробелами, то следует  отметить  этот  факт,
используя eo.
<p align=justify><i>Клавиатура</i><br>
Если терминал имеет клавиауру,   которая  передает  коды,
когда нажимается  клавиша,  и может выдаваться эта информация.
Отметим, что невозможно управлять терминалами, когда клавиатура работает локально (это применяется,  например,  на клавишах
HP 2621).  Если клавиатуры могут устанавливаться для  передачи
или непередачи,  даются коды smkx и rmkx.  В противном случае,
предполагается, что клавиатура всегда передает. Коды, посылаемые с помощью левой стрелки,  правой стрелки,  стрелки вверх,
стрелки вниз и начальной клавиши, могут быть заданы как kcub1,
kcuf1, kcuu1,  kcud1 и khome соответсвенно. Если имеются функциональные клавиши,  такие как f0, f1, ..., f10, то посылаемые
коды могут задаваться как kf0, kf1, ..., kf10. Если эти клавиши имеют метки,  отличные от f0 до f1, то метки  2lf0, lf1, ...,
lf10 могут присваиваться.  Коды, передаваемые другими пециальными функциональными клавишами,  могут задаваться:  kll  (вернуться в начальное положение), kbs (backspace), ktbc (очистить
все клавиши табуляции),  kctab (очистить stop в этой колонке),
kclr (очистить экран и стереть клавиши),  kdch1  (убрать  символ), kdl1  (убрать  строку),  kmir (выйти из режима вставки),
kel (очистить до конца строки),  ked (очистить до конца  экрана), kich1 ( вставить символ или включить режим встаки),  kil1
(вставить строку),  knp (следующая страница),  kpp (предыдущая
страница), kind  (просмотр  вперед/вниз),   kri  (просмотр назад/вниз), khts (установить stop в этой колонке).  В  добавление, если  клавиатура  имеет массив клавиш 3 на 3 ,  включая 4
клавиши-стрелки, могут задаваться как ka1,  ka3,  kb2,  kc1  и
kc3. Эти клавиши могут использоваться, когда необходимо заполнение 3 на 3.
<p align=justify><i>Табуляция и инициализация</i><br>
Если терминал имеет аппаратные символы табуляции, команда
для продвижения к следующему символу табуляции stop будет задаваться как  ht  (обычно  ctrl-I).  Команда "backtab",  которая
продвигает до следующего символа табуляции stop.  При преобразовании, если режим телетайпа указывает, что символы табуляции
расширяются с помощью компьютера прежде,   чем  посылаются  на
терминал, в программах не следует использовать ht и cbt,  даже
если они присутствуют,  так как пользователь не имеет установленных надлежащим  образом  символов табуляции.  Если терминал
имеет аппаратные символы табуляции,  которые изначально  установлены через каждые n позиций при включении терминала,задается параметр it, показывающий количество позиций, через которые
должны быть установлены символы табуляции.  Это обычно используется командой <a href=TSET.htm>tset(1)</a>  для определения,  установлен ли режим
расширения для  символов  табуляции,  и установлены ли символы
stop. Если терминал имеет символы stop,  сохраняющиеся в памяти, то  описание terminfo допускает,  что они установлены правильно.
<p align=justify>Другие средства включают is1, is2 и is3, строки инициализации для терминала,  iprog,  составное имя программы, которое
следует выполнить для инициализации терминала и if, имя файла,
содержащего строки длинной инициализации. Эти строки ожидаются
для установки терминала в режим,  связанный с остаттком описания файла  terminfo.   Они обычно посылаются на терминал с помощью программы tset, каждый раз, пока пользователь загружается. Оним  будут  печататься  в  следующем порядке:  is1,  is2,
устанавливая символы табуляции, использующие tbc и hts; выполняемую программу iprog; и, наконец, is3. Большая часть инициализации выполняется с помощью is2.  Определенные режимы терминала могут   устанавливаться   без  дублирования  строк  путем
помещения общей последовательности в is2 и определенных букв в
is1 и is3. Пара последовательностей, которая выполняет жесткую
замену из неизвестного состояния, может быть задана rs1,rs2,rf
и rs3,   аналогично для is2 и if.  Команды обычно помещаются в
rs2 и rf,  если они дают неприятный эффект на экране и не обязательны при  загрузке.   Например,  команды,  устанавливающие
vt-100 в 80-колонный режим,  обычно бывают частью is2,  но они
вызывают мерцание  экрана  и не нужны,  пока они не перейдут в
этот режим.
<p align=justify>Если есть команды, которые помещают и очищают символы табуляции stop,   они могут задаваться tbc ( стереть все символы
stop) и hts ( установить символ табуляции stop в  текущую  колонку текущей строки). Если требуется более сложная последовательность для установки символов табуляции,  которые были описаны выше, последовательность может заменяться в is2 или if.
<p align=justify><i>Задержки</i><br>
Некоторые средства управляют заполнениями в драйвере  телетайпа. Они в первую очередь необходимы для тврдых копий терминала и используются программой tset при соответствующей  установке режима телетайпа.  Задержки, включенные в средства cr,
ind, cub1,  ff и tab, вызывают установку битов задержки, которые помещаются в драйвер телетайпа. Если задается pb (цена заполнения), это значение может опускаться после значения pb.
<p align=justify><i>Разное</i><br>
Если в терминале требуются другие символы заполнения, отличные от нуля,  это может задать с помощью pad.  Используется
только первый символ строки pad.
<p align=justify>Если в терминале имеется дополнительное "состояние  строки", которое,  как правило,  не используется программами, этот
факт может быть отмечен.  Если состояние строки показано,  как
дополнительная строка  под  нижней строкой,  на которую курсор
может адресоваться (такие как HEATHKIT h'19's  25ти  строковая
или 24х  строковая vt-100,  в которой установлена 24х строковая
область просмотра), следует испоьзовать средство hs. Специальные строки,   позволяющие  попасть в начало строки состояния и
вернуться из нее,  могут задаваться с помощью tsl и fsl.  (fsl
должна оставлять курсор в той же позиции, где он находился перед выполнением tsl.  Если необходимо,  то в tsl и  fsl  можно
включать строки sc и rc для достижения этого результата.)  Параметр tsl берет один параметр,  который является номером  колонки состояния строки, к которой должен двигаться курсор. Если управляющие   последовательности   и   другие   специальные
команды, такие как tab,  работает, если в состоянии строки задан флаг eslok.  Строка,  которая выключает  состояние  строки
(или в другом случае стирает его содержимое), это можно задать
с помощью dsl.  Если терминал имеет команды сохранения и восстановления позиции  курсора,   это можно задать с помощью sc и
rc. Состояние строки обычно допускается такой же ширины,   как
остаток экрана, то есть cols  Если состояние строки другой ширины ( возможно потому,  что терминал не  позволяет  загрузить
целую линию),   ширина в колонках может быть указана с помощью
числового параметра wsl.
<p align=justify>Если терминал  может свдигать на полстроки вверх или вниз,
это задается как hu (полстроки вверх)  и hd (полстроки  вниз).
Это, главным  образом,   полезно для подстрочных и надстрочных
индексов в терминалах с жесткими копиями.   Если  терминал  с
жесткой копией  может  переходить  на следующую страницу (form
feed), то это задается как ff (обычно ctrl-L).
<p align=justify>Если существует команда повторения заданного символа  заданное количество раз (чтобы сохранить время передачи большого
количества идентичных символов), то это задается с помощью параметризованной строки rep.  Первый параметр - это символ, который должен быть повторен,  второй - число повторений.  Таким
образом, tparm(repeat_char,   'x',   10)   то  же  самое,  что
'xxxxxxxxxx'.
<p align=justify>Если терминал имеет устанавливаемый командный символ, так
как в TEKTRONIX 4025,  он может указываться как cmdch. Командный символ прототипа выбран таким,  какой используется во всех
средствах. Этот  символ  задается  в  средствах  cmdch для его
идентификации. В некоторых XENIX системах поддерживаются  следующие преобразования:  Среда, которая должна быть найдена для
переменной СС,  и если найдена, то все символы прототипа заменяются символом в переменной среды.
<p align=justify>Описания терминала, которые не представлены в специальных
видах отдельных терминалов, такие как switch, dialup, patch,
network, должны включать средство gn (generic), так что бы
программа не могла пожаловаться на то, что она не знает, как
общаться с терминалом.
<p align=justify>Если терминал использует XON/XOFF квитирование установления связи для управления  потоком,   дается  xon.   Информацию
заполнения следует  включать,   для того чтобы программы могли
принять выгодное решение о затратах,   но  в  действительности
символы заполнения не передаются.
<p align=justify>Если терминал имеет "метаклавишу",  которая действует наподобие клавиши shift, устанавливая восьмой бит в каждый передаваемый символ, это задается как km. В другом случае, программы могут допускать,  что восьмой бит  -  бит  четности,   и
обычно он убирается. Если строки выходят на включение и выключения этого "мета режима", они могут быть заданы как smm и rmm.
<p align=justify>Если терминал имеет больше строк памяти, чем может поместиться на экране в один прием, число строк в памяти указывается в  lm.   Значение  lm#0  указывает,   что  число  строк  не
фиксированно, но что памяти остается больше, чем помещается на
экране.
<p align=justify>Если терминал - один из тех,  которые поддерживаются протоколом виртуального терминала UNIX,  номер терминала задается
как vt.
<p align=justify>Строки средней копии, которые управляют внешним принтером,
связанным с терминалом, задаются как mc0:  печатать содержимое
экрана, mc4: выключить принтер, и mc5:  включить принтер. Если
принтер включен, весь текст, посылаемый на терминал, будет посылаться на принтер.  То есть,  не определено,  будет ли текст
высвечиваться на дисплее,  если принтер включен.  Вариант mc5p
берет один параметр и оставляет принтер включенным для  стольких символов, каково значение параметра, потом выключает принтер. Параметр не должен превышать 255.  Весь  текст,   включая
mc4, без изменения передается на принтер, пока работает mc5p.
<p align=justify>Строки для программирования функциональных клавиш задаются как pfkey,  pfloc и pfx. Каждая из этих строк имеет два параметра: номер функциональной клавиши, которая программируется
(от 0 до 10)  и строка, с помощью которой она программируется.
Номера функциональных клавиш из этого множества могут программировать неопределенные клавиши способом,  зависящим от терминала. Различие между средствами в том,  что pfkey вызывает нажатием на заданные клавиши тот же самый эффект,  как  если  бы
пользователь печатал  заданную строку; pfloc вызывает выполнение строки на терминале  локально;  а  pfx  вызывает  передачу
строки в компьютер.
<p align=justify><i>Глитчи и нестандартные средства</i><br>
Hazeltine терминалы, которые не допускают '~'символов для
высвечивания, должны обозначаться как hz.
<p align=justify>Терминалы, игнорирующие немедленную подачу  строки  после
am перехода,   такие  как Concept и vt-100,  должны отмечаться
xenl.
<p align=justify>Если требуется  el,   для  того  чтобы  выйти  из  режима
standout (вместо простой надписи обычного текста наверху экрана), следует задавать xhp.
<p align=justify>Teleray терминалы, где символы табуляции заставляют игнорировать пробелы  перед  символами,   задаются xt (разрушающие
символы). Этот глитч указывает также, что невозможно поместить
позицию курсора  в начало "magic cookie",  и что вместо выхода
из режима standout необходимо использовать уничтожение и  ввод
строки.
<p align=justify>Beehive Superbee,  который не в состоянии правильно передать символы escape и ctrl-C ,  имеют xtb, который задает, что
клавиша f1 используется в качестве escape и f2 в качестве ctrl
-C. ( Только некоторые Superbee имеют эти проблемы,  зависящие
от ROM.)
<p align=justify>Разные специфические проблемы  терминала могут быть исправлены добавлением дополнительных средств в виде xx.
<p align=justify><i>Подобные терминалы</i><br>
Если есть два похожих терминала,  один из них может определяться также,  как и другой,  с определенными  исключениями.
Средство строки  use может быть задано с именем подобного терминала. Средство, задаваемое перед use, передает их в тип терминала, задействованного  с  помощью use.  Cредство может быть
завершено путем помещения xx@ слева определения средства, где
хх обозначает это средство. Например, ввод
<pre>
     262-nl, smkx@, rmkx@, use=2621,
</pre>
<p align=justify>определяет 262-nl,  который не имеет средств  2smkx и rmkx,
и следовательно не включает метки функциональных клавиш, когда
режим visual.  Это полезно для различных режимов терминала или
для различных предпочтений пользователя.
<p align=justify><b>ФАЙЛЫ</b><br>
<tt>/usr/lib/terminfo/?/*</tt> файлы, содержащие описания терминала, компилируются с помощью <a href=TIC.htm>tic(1)</a>
<p align=justify><b>ПРИМЕЧАНИЯ</b><br>
Ни vi,  tset,  ни какие-либо другие команды XENIX не  используются terminfo. Вместо этого полное объединение termcap и
terminfo будут обеспечиваться будущей версией XENIX.
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/footer0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table>
</body>
</html>
