<html>
<head>
<title>CSH(1)</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/header0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="_pic_/logo.gif" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>

<h3 align=center>CSH(1)</h3>
<p align=justify><b>НАЗВАНИЕ</b><br>
csh -  Активизирует  командный интерпретатор shell с синтаксисом, аналогичным синтаксису языка С.
<p><b>СИНТАКСИС</b>
<pre>
	csh [ -cefinstvVxX ] [ arg ... ]
</pre>
<p align=justify><b>ОПИСАНИЕ</b><br>
Команда csh является интерпретатором языка команд. Она начинается с выполнения команд из файла .cshrc во входном (home) каталоге вызвавшего  ее  пользователя.  Если  это  интерпретатор
shell вхождения в систему,  то, кроме того, он выполняет здесь
команды из файла .login.  В случае нормального  функционирования, интерпретатор shell начинает cчитывание команд с терминала,  выводя в качестве приглашения знак %.  Процесс  обработки
аргументов  и использование интерпретатора shell для обработки
файлов, содержащих командные сценарии, будут описаны позже.
<p align=justify>Затем интерпретатор  shell  неоднократно  выполняет  следующие
действия: считывается  строка  командного  ввода и заносится в
words (слова). Полученная из слов последовательность помещается в список предыстории команд, а затем подвергается синтаксическому анализу.  После этого, наконец, каждая команда текущей
строки выполняется.
<p align=justify>Когда завершает  свое выполнение интерпретатор shell вхождения
в систему,  он выполняет команды из файла .logout  во  входном
(home) каталоге пользователя.
<p align=justify><b>Лексическая структура</b><br>
Интерпретатор shell разделяет входные строки на слова, считая,
что они отделяются друг от друга пробелам и знакам  табуляции,
и учитывая следующие исключения.  Символы &,  |, ;, &lt;, &gt;, (, )
формируют отдельные слова. Отдельные слова формируют такие пары сдвоенных символов,  как &&, ||, &lt;&lt; или &gt;&gt;. Эти метасимволы
синтаксического анализатора могут быть частью других  слов;или
их  специальное  назначение может быть отменено предшествующим
им символом \. Признак новой строки, с предшествующим ему символом \, эквивалентен пробелу.
<p align=justify>Кроме того,  строки,  заключенные в пары соответствующих кавычек: `,  ' или ",  формируют части слова;  метасимволы в таких
строках,  включающих  пробелы и знаки табуляции,  не формируют
отдельных слов.  Семантика таких кавычек впоследствии описывается. Внутри пар, состоящих из символов \ или ", признак новой
строки с предшествующим знаком \ представляет  собой  действительно символ новой строки.
<p align=justify>Когда входные  данные  для  интерпретатора shell вводятся не с
терминала, символ # указывает,  что в строке находятся комментарии, которые продолжаются до конца входной строки. Этот символ не имеет этого специального значения, если ему предшествует знак \, и если он находится внутри кавычек `, ' или ".
<p align=justify><b>Команды</b><br>
Простая команда представляет собой последовательность из слов,
первое из которых определяет команду,  которая должна быть выполнена. Простая команда или последовательность из простых команд, разделенных символом |, формирует конвейер. Выход каждой
команды  в  конвейере связывается со входом следующей команды.
Последовательности конвейеров могут быть  разделены  точкой  с
запятой,  и затем выполняются последовательно.  Последовательность конвейеров может быть выполнена, не дожидаясь завершения
выполнения последовательности, если за ней следует знак &. Завершение такой последовательности по сигналу разъединения  автоматически запрещается; использование команды nohup не требуется.
<p align=justify>Любые последовательности из описанных выше могут быть заключены  в круглые скобки для того,  чтобы сформировать простую команду (которая,  в свою очередь, может быть составляющей некоторого конвейера,  и т.д.). Кроме того, как и в языке С, можно
разделять конвейеры, указав знаки && или ||, которые означают,
что второй конвейер будет выполняться только в случае успешного  или неуспешного завершения первого,  соответственно.  (См.
раздел "Выражения".)
<p align=justify><b>Подстановки</b><br>
Следующие разделы описывают различные  преобразования  входных
данных,  выполняемые интерпретатором shell,  в том порядке,  в
каком они встречаются.
<p align=justify><b>Подстановки Предыстории</b><br>
Подстановки предыстории могут быть использованы для повторного
ввода последовательностей слов из предыдущих команд, возможно,
модифицированных. Таким образом, подстановки предыстории обеспечивают обобщение функции redo.
<p align=justify>Подстановки предыстории начинаются с символа ! и могут начаться в любом месте входного потока, если они уже не выполняются.
Символу !  может предшествовать символ \ для отмены его специального назначения;  символ !  проходит неизмененным,  если за
ним следует пробел, знак табуляции, признак новой строки, знак
= или знак (.  Также, подстановки предыстории могут встречаться,  когда входная строка начинается со знака ^. Эта специальная аббревиатура будет описана позже.
<p align=justify>Любая входная  строка,  содержащая  подстановку   предыстории,
отображается  перед ее выполнением на терминале так,  как если
бы она была введена без подстановки предыстории.
<p align=justify>Команды, вводимые с терминала,  которые состоят из одного  или
более слов, сохраняются в списке предыстории, размером которого  управляет значение переменной history.  Предыдущая команда
сохраняется всегда.  Нумерация команд производится  последовательно от 1.
<p align=justify>Например, введите команду:
<pre>
	history
</pre>
<p align=justify>Теперь просмотрите  следующий  вывод,  производимый   командой
history:
<pre>
	9 write michael
	10 ex write.c
	11 cat oldwrite.c
	12 diff *write.c
</pre>
<p align=justify>Показаны команды с их пособытийными номерами.  Обычно, использование пособытийных номеров не является обязательным,  но текущий событийный номер может быть сделан  частью  приглашения,
выводимого на экран,  при введении в  эту  строку  приглашения
знака !.
<p align=justify>Если текущим событием является событие с номером 13, то мы можем сослаться на предыдущие события при помощи событийного номера следующим образом: !11, или же при помощи записи !-2 (относящейся к тому же событию), а также с использованием префикса (первой буквы) командного слова: !d для события 12 или префикса !w для события 9, или при помощи строки символов, содержащихся в слове из команды,  как например,  строка !?mic? тоже
отсылает к событию 9. Такие формы вводимых записей, без последующей модификации,  просто осуществляют повторный  ввод  слов
определенных событий, отделяемых друг от друга одним пробелом.
Отдельным случаем является запись вида !!, которая осуществляет ссылку на предыдущую команду;  таким образом, запись !! является по  существу  функцией redo.  Запись вида !# производит
ссылку на текущую (вводимую в данный момент)  команду.  Например,  как в записи !#:1, эта ссылка позволяет выбрать слово из
находящегося слева текста текущей  строки,  что  предотвращает
повторный ввод длинного имени.
<p align=justify>Чтобы выделить слова из  некоторого  события,  следует  ввести
спецификацию события,  затем двоеточие и указатель на желаемые
слова.  Слова во входной строке нумеруются от 0,  первое слово
(обычно,  команда)  имеет номер 0,  второе слово (первый аргумент) имеет номер 1, и т.д. Основными указателями на слова являются следующие значения:
<table>
<tr valign=top><th>0    <td>    Первое слово (команда)
<tr valign=top><th>n   <td>     n - аргумент
<tr valign=top><th>^   <td>     Первый аргумент, т.е. 1
<tr valign=top><th>$   <td>     Последний аргумент
<tr valign=top><th>%    <td>    Слово, соответствующее строке поиска ?s?  (непосредственно предшествующей в записи спецификации события)
<tr valign=top><th>x-y  <td>    Диапазон слов
<tr valign=top><th>-y   <td>    Аббревиатура для записи диапазона 0-y
<tr valign=top><th>*    <td>    Аббревиатура для записи диапазона ^-$, которая задает  пустое множество, если в событии только 1 слово.
<tr valign=top><th>x*   <td>    Аббревиатура для записи диапазона x-$
<tr valign=top><th>x-  <td>     Аналогично x*, но не включая слово $.
</table>
<p align=justify>Двоеточие, отделяющее  спецификацию  события  от  указателя на
слова, может быть опущено в случае,  если аргументный селектор
начинается с символа ^, $, *, - или %. После указателя на слова,  который может и отсутствовать, может быть помещена последовательность модификаторов так, что каждому предшествует двоеточие. Определяются следующие модификаторы:
<table>
<tr valign=top><th>h   <td>     Удаляет последнюю составляющую обозначения пути
<tr valign=top><th>r    <td>    Удаляет последнюю составляющую .XXX
<tr valign=top><th>s/l/r  <td>  Производит подстановку l вместо r
<tr valign=top><th>t    <td>    Удаляет все  предшествующие  составляющие обозначения пути
<tr valign=top><th>&    <td>    Повторяет предыдущую подстановку
<tr valign=top><th>g   <td>     Выполняет глобальную замену, с учетом указанных ранее подстановок
<tr valign=top><th>p    <td>    Печатает новую команду, но не выполняет ее
<tr valign=top><th>q    <td>    Заключает в кавычки подставленные слова, предотвращая выполнение подстановок
<tr valign=top><th>x    <td>    Аналогично q,  но прерывает слова на пробелах, знаках табуляции и признаках новой строки.
</table>
<p align=justify>Если не предшествует модификатор g, то модификация применяется
только к первому доступному для изменения слову.  В случае любой модификации  ошибочной ситуацией является отсутствие соответствующего слова.
<p align=justify>Левые части подстановок являются не регулярными,  в смысле редакторов,  выражениями,  а скорее строками. Любой символ может
быть использован в качестве разделителя вместо знака /; знак \
заключает в кавычки разделитель внутри строк l и r. Символ & в
правой части подстановки заменяется на текст из  левой  части.
Знак \  также  заключает в кавычки символ &.  Пустое  значение
строки l использует предыдущую строку,  взятую из  предыдущего
значения  l,  или  из  контекстуально сканированной строки s в
подстановке !?s?.  Последний разделитель в  подстановке  может
быть опущен,  если в контекстуальном сканировании за последним
знаком вопроса ? сразу же следует признак новой строки.
<p align=justify>Ссылка предыстории может быть задана без спецификации события,
например, !$. В этом случае ссылка относится либо к предыдущей
команде,  если в той же самой  строке  отсутствует  предыдущая
ссылка предыстории,  либо, в противном случае, эта форма подстановки повторяет предыдущую ссылку. Таким образом запись вида
!?foo?^!$ задает первый и последний аргумент из команды, соответствующей подстановке ?foo?.
<p align=justify>Существует специальная аббревиатура ссылки предыстории, представляемая знаком ^,  который является первым непустым символом
входной строки. Она эквивалентна подстановке вида !:s^ и обеспечивает удобное сокращение для замещений на текст из предыдущей строки. Таким образом, запись ^lb^lib проверяет орфографию
lib в предыдущей команде. Наконец, подстановка предыстории может быть заключена в фигурные скобки { и  },  если  необходимо
изолировать ее от последующих символов.  Таким образом,  после
команды ls -ld ~paul Вы можете сделать подстановку !{l}a, чтобы  в  результате выполнить команду ls -ld ~paula,  в то время
как запись вида !la будет просматривать  команды, начинающиеся
с la.
<p align=justify><b>Заключение В Кавычки При Помощи Знаков ' и "</b><br>
Заключение в кавычки строк при помощи знаков ' и " может  быть
использовано для  предупреждения  всех или некоторых из оставшихся подстановок.  Строки, заключенные в кавычки вида ', предупреждают любую последующую интерпретацию.  Строки, заключенные в кавычки вида ",являются доступными и может быть произведено их командное раскрытие.
<p align=justify>В обоих  случаях результирующий текст становится (весь или его
часть) отдельным словом;  только в  одном  специальном  случае
(см. раздел Подстановка Команд) заключенная в кавычки  вида  "
строка производит части более чем одного слова; строка, заключенная в кавычки вида ', этого не делает.
<p align=justify><b>Подстановка Псевдонимов</b><br>
Интерпретатор shell поддерживает перечень псевдонимов, которые
могут быть установлены, выведены на экран и модифицированы при
помощи команд alias и unaliase. По завершению сканирования командной  строки,  она подвергается синтаксическому анализу,  в
результате чего разбивается на отдельные команды, и после этого проверяется  первое  слово  каждой команды,  слева направо,
<p align=justify>
имеет ли оно псевдоним. Если имеет, то текст, который является
псевдонимом для этой команды, при помощи механизма предыстории
считывается повторно таким образом,  как если бы  эта  команда
была предыдущей входной строкой. Полученные в результате слова
заменяют эту команду и список аргументов. Если не было сделано
ни одной ссылки к списку предыстории, то список аргументов остается без изменений.
<p align=justify>Таким образом, если псевдонимом для команды ls является ls -l,
то команда  "ls  /usr"  будет  преобразована  в команду "ls -l
/usr". Аналогично, если псевдоним для команды lookup был "grep
\!^ /etc /passwd", то команда "lookup bill" будет преобразована к виду "grep bill /etc/passwd".
<p align=justify>Если псевдоним найден,  то выполняется пословная трансформация
входного  текста,  и  процесс выявления псевдонимов начинается
сначала уже над переформатированной входной строкой. Если первое  слово  нового  текста  является таким же,  что и в старом
тексте, то во избежание зацикливания это слово отмечается флагом,  чтобы  препятствовать  следующей подстановке псевдонима.
Прочие циклы обнаруживаются и приводят к ошибочной ситуации.
<p align=justify>Отметим, что такой механизм допускает псевдонимы для представления метасинтаксиса синтаксического анализатора.  Таким образом, мы можем назначить псевдоним печати "'pr\!* | lpr'", чтобы  сформировать  команду,  которая разбивает на страницы свои
аргументы для построчного принтера.
<p align=justify>Существует четыре  псевдонима команды csh,  поставляемые с командой csh системы XENIX System V.  Это pushd,  popd,  swapd и
flipd. Эти псевдонимы поддерживают стек каталогов.
<dl>
<dt>pushd dir<dd>
Текущий каталог помещает в вершину стека каталогов, изменяет текущий каталог на каталог dir.
<p><dt>
popd<dd>
Изменяет текущий каталог на каталог из вершины стека, затем
удаляет (выталкивает) верхний каталог из стека, и объявляет
его текущим.
<p><dt>
swapd<dd>
Переставляет два верхних каталога в стеке.  Верхний каталог
становится вторым от вершины стека,  а  второй  от  вершины
каталог становится верхним каталогом.
<p><dt>
flipd<dd>
Производит переключения между двумя каталогами, текущим каталогом и верхним каталогом из стека.  Если в данный момент
Вы находитесь в каталоге dir1, а каталог dir2 располагается
в вершине стека,  то при выполнении команды flipd Вашим каталогом  становится dir2,  а dir1 помещается на его место в
вершине стека.  При повторном вызове flipd Вашим  каталогом
станет dir1, а dir2 снова станет верхним каталогом в стеке.
</dl>
<p align=justify><b>Подстановка Переменных</b><br>
Интерпретатор shell поддерживает набор переменных,  каждая  из
которых имеет  в качестве ее значений список из нуля или более
слов. Некоторые из этих переменных устанавливаются интерпретатором shell или на них можно ссылаться при помощи  интерпретатора shell.  Например,  переменная  argv является отображением
списка аргументов интерпретатора shell,  и на слова, указанные
в значении этой переменной, можно ссылаться только специальными способами.
<p align=justify>Значения переменных могут быть выведены на  экран  и  изменены
при помощи команд set и unset.  Некоторое число переменных, на
которые производятся ссылки при помощи  интерпретатора  shell,
являются двоичными  переключателями;  интерпретатор  shell  не
проверяет, какие значения имеют эти переменные, а только установлены  они  или нет.  Например,  переменная verbose является
двоичным переключателем,  который  назначает  вывод  на  экран
отображения вводимой команды. Эта переменная устанавливается в
результате применения в командной строке опции -v.
<p align=justify>Некоторые другие операции трактуют переменные в числовом  значении. Команда  со  знаком @ допускает выполнение числовых вычислений и назначение результата переменным. С другой стороны,
значения переменных всегда представляются в виде (нуля или более) символьных строк.  В целях проведения  числовых  операций
нулевая символьная строка рассматривается,  как ноль, а второе
и последующие слова значения переменной,  состоящего  из  нескольких слов, игнорируются.
<p align=justify>После того, как для входной строки выявлены псевдонимы, и проведен синтаксический анализ,  и перед тем,  как каждая команда
будет выполнена, выполняется подстановка переменных, подключаемая при помощи символов знака доллара  ($).  Такое  раскрытие
может  быть  отменено указанием обратной косой черты (\) перед
знаком доллара,  но не в двойных кавычках ("),  где оно всегда
появляется,  и не в одинарных кавычках ('), где оно никогда не
появляется.  Строки,  заключенные в обратные кавычки (`),  интерпретируются   позже  (См.  раздел  Подстановка  Команд  ниже), так что подстановка знака доллара не  возникает  в  таких
строках  до  последнего момента,  если вообще возникает.  Знак
доллар проходит без изменений,  если за  ним  следуют  пробел,
знак табуляции или признак новой строки.
<p align=justify>Переадресации ввода  и  вывода  распознаются  перед раскрытием
переменных, и представляют собой переменные, раскрываемые особо.  С другой стороны,  имя команды и полный список аргументов
раскрываются вместе.  Таким образом, для первого слова (команды) возможна генерация более,  чем одного слова, первое из которых становиться именем команды, а остальные - аргументами.
<p align=justify>Если отсутствует заключение в двойные кавычки или не задан модификатор :q,  результатами подстановки переменной могут в конечном счете оказаться подставленные команда и имя файла. Заключенная  в  двойные кавычки (") переменная,  значение которой
состоит из нескольких слов,  раскрывается в часть одного слова
со  словами,  указанными  в значении переменной и разделенными
пробелами. Когда для подстановки употребляется модификатор :q,
переменная раскрывается в несколько слов,  где каждое отделено
пробелом и заключено в кавычки,  чтобы воспрепятствовать дальнейшей подстановке команды или имени файла.
<p align=justify>Ниже приведены последовательности для введения значений  переменных на вход интерпретатора shell.  Кроме  выше  указанного,
ссылка на неустановленную переменную считается ошибкой.
<dl><dt>
$name
<br>${name}<dd>
Заменяются словами из значения переменной name (имя), при
этом каждое слово отделяется  пробелом.  Фигурные  скобки
отделяют  параметр name от последующих символов,  которые
в противном случае воспринимались бы как его часть. Переменные интерпретатора shell имеют имена, содержащие до 20
букв, цифр и символов подчеркивания.
<p align=justify>Если параметр  name  не  является  переменной   интерпретатора
shell, но устанавливается в среде,  то возвращается именно это
значение (но :  модификаторы и другие формы записей,  заданные
ниже, в этом случае становятся недоступными).
<p><dt>
$name[selector]
<br>${name[selector]}<dd>
Может использоваться  для выбора только некоторых слов из
значения параметра name. Селектор (selector) подвергается
подстановке $ и может содержать один или два номера, разделенных знаком -. Первое слово в значении переменных нумеруется 1.  Если  первый  номер интервала опущен,  то по
умолчанию он устанавливается в значение  1.  Если  опущен
последний член   интервала,  его  значение  по  умолчанию
$#name. При задании параметра selector символом *,  выбираются  все слова.  Если интервал задает пустое множество
или опущен второй аргумент в интервале,  это не  является
ошибкой.
<p><dt>
$#name
<br>${#name}<dd>
Задает число слов в переменной.  Это удобно для последующего использования в определении параметра [selector].
<p><dt>
$0<dd>
Подставляет имя файла,  из которого производится считывание командного ввода.  В случае неизвестного имени  файла
происходит ошибка.
<p><dt>
$number
<br>${number}<dd>
Эквивалентно записи $argv[number].
<p><dt>
$*<dd>
Эквивалентно записи $argv[*].
<p align=justify>Модификаторы :h,  :t, :r, :g и :x могут быть применены к подстановкам, описанным выше,  как и модификаторы :gh,  :gt и :gr.
Если в командной форме появляется пара скобок { },  то модификаторы  должны  быть внутри этих скобок.  В каждом раскрытии $
допускается только один модификатор :.
</dl>
<p align=justify>При помощи модификаторов : не могут быть модифицированы следующие подстановки:
<dl><dt>
$?name
<br>${?name}<dd>
Подставляет символ 1,  если name установлено, и 0, в противном случае.
<p><dt>
$?0<dd>
Подставляет 1, если известно имя текущего входного файла,
и 0, в противном случае.
<p><dt>
$$<dd>
Подставляет номер (десятичный) процесса, породившего процесс интерпретатора shell.
</dl>
<p align=justify><b>Подстановка Команд и Имен Файлов</b><br>
Подстановка команд и имен файлов применяется выборочно к аргументам встроенных команд.  Это означает,  что части выражений,
которые не являются оцениваемыми, не подвергаются этим раскрытиям. Для команд, которые не являются внутренними по отношению
к интерпретатору shell,  имя команды подлежит подстановке  отдельно от списка аргументов. Это происходит много позже, после
выполнения переадресации ввода-вывода, и в процессе, порожденном главным процессом интерпретатора shell.
<p align=justify><b>Подстановка Команд</b><br>
Подстановка команд  указывается  включением команды в обратные
кавычки. Вывод,  производимый такой командой, как правило, помещается в отдельные слова, разделенные пробелами, знаками табуляции и признаками новой строки,  где нулевые слова отбрасываются, после  чего этот текст помещается в оригинальную строку. Внутри двойных кавычек только признаки новой строки приводят к образованию новых слов; пробелы и знаки табуляции сохраняются.
<p align=justify>В любом случае, находящийся в конце единственный признак новой
строки не образует нового слова.  Заметим,  существует вероятность того,  что в результате подстановки команды будет произведена  только часть слова,  даже если выходные данные команды
составляют полную строку.
<p align=justify><b>Подстановка Имен Файлов</b><br>
Если некоторое слово содержит любой из символов:  *,  ?, [ или
{, или начинается с символа ~,  то это слово является кандидатом на выполнение подстановки имен  файлов,  также  известной,
как глобальная подстановка.  Это слово,  затем, принимается за
образец и заменяется на перечень имен файлов,  отсортированных
в алфавитном порядке,  которые соответствуют этому образцу.  В
некотором списке слов, задающем подстановку имен файлов, ошибкой является отсутствие образца для сопоставления с существующим именем файла, но при этом не требуется, чтобы каждый образец сопоставлялся.  Только метасимволы *,  ? и [ подразумевают
сопоставление образцу, символы ~ и { скорее сродни аббревиатурам.
<p align=justify>В именах файлов,  сопоставляемых с образцом,  символ .  либо в
начале имени файла, либо следующий непосредственно за символом
/, так же как и сам символ /, должны быть в точности совпадающими.  Символ * соответствует любой символьной строке, включая
пустую.  Символ ?  соответствует одному любому символу. Последовательность в квадратных скобках [] задает соответствие  одному (любому) из символов,  заключенных в скобки.  Пара символов,  разделенных знаком -,  и заключенная в квадратные скобки
[], задает соответствие любому символу, лексически расположенному между этой парой символов.
<p align=justify>Символ ~ в начале имени файла используется для ссылки на собственные (home) каталоги. Будучи единственным, он раскрывается,
как  входной  (home) каталог вызывающего пользователя, отображенный в значении переменной home. Когда за этим символом следует имя, содержащее буквы, цифры и символы  -,  интерпретатор
shell  осуществляет  поиск пользователя с таким именем и подставляет его входной (home) каталог.  Так,  запись  ~ken  может
быть  раскрыта  как  /usr/ken,  а  запись ~ken/chmach - в виде
/usr/ken/chmach. Если за символом ~ следует  символ,  отличный
от  буквы  или  символа /, или символ ~ появляется не в начале
слова, то он остается без изменений.
<p align=justify>Метаназначение a{b,c,d}e является сокращением для abe ace ade.
Порядок следования слева направо сохраняется, при этом результаты сопоставления сортируются  отдельно,  начиная  с  нижнего
уровня,  чтобы  сохранить этот порядок.  Эта конструкция может
быть вложенной.  Так,  запись вида  ~source/sl/{oldls,ls}.c  в
предположении, что собственным каталогом для sourse является /
usr/source, раскрывается в следующие имена файлов: /usr/source
/sl/oldls.c и /usr/source/sl/ls.c, независимо от того, существуют или нет эти файлы.  Аналогично, форма вида ../{memo,*box}
может быть раскрыта как ../memo ../box ../mbox.  (Заметим, что
имя memo не будет упорядочено наряду с результатами  сопоставления по  образцу  *box.) В виде исключения символы {,  } и {}
проходят без изменений.
<p align=justify><B>Средство Контроля Орфографии</b><br>
Также, как и в интерпретаторе shell Баурна,  при использовании
команды cd(C) данный интерпретатор shell осуществляет проверку
орфографии.  Например,  если Вы производите смену каталога при
помощи команды cd и сделали орфографическую ошибку в имени каталога,  интерпретатором shell будет предложен  альтернативный
вариант  орфографии  для  существующего каталога.  Введите "y"
(да) и нажмите клавишу RETURN (или сразу же  нажмите  RETURN),
чтобы  произвести  изменение  на представленный каталог.  Если
предложенная орфография некорректна,  введите "n" (нет), затем
снова наберите  командную строку.  В приведенном примере ответ
команды csh(C) выделен жирным шрифтом:
<pre>
	% cd /usr/spool/uucp
	2/usr/spool/uucp?0y
	2ok
</pre>
<p align=justify><b>Ввод/Вывод</b><br>
Стандартный ввод и стандартный вывод могут быть переадресованы
с использованием следующего синтаксиса:
<dl><dt>
&lt; name<dd>
Открывает файл, заданный параметром name (который сначала
раскрывает переменных, команд и имен файлов), в  качестве
стандартного ввода.
<p><dt>
&lt;&lt; word<dd>
Считывает ввод  интерпретатора  shell до строки,  которая
указана параметром word.  Параметр word не подлежит подстановкам переменных,  имен файлов или  команд,  и  каждая
входная  строка сравнивается с параметром word перед проведением подстановок в этой входной строке.  Если в параметре  word  отсутствуют выделяющая обратная косая черта,
двойные и одинарные кавычки,  или  обратные  кавычки,  то
производится подстановка переменных и команд на имеющихся
строках,  допуская использование знака  \  для  выделения
знаков $, \ и `. В замещаемых командах все пробелы, знаки
табуляции и признаки новой строки сохраняются,  за исключением последнего признака новой строки, который отбрасывается. Результирующий  текст помещается в анонимный временный файл,  который задается команде в  качестве  стандартного ввода.
<p><dt>
&gt; name
<br>&gt;! name
<br>&gt;& name
<br>&gt;&! name<dd>
Файл, задаваемый параметром name, используется в качестве
стандартного вывода.  Если этот файл не существует, то он
создается; если  файл  существует,  то он усекается и его
предыдущее содержимое теряется.
<p align=justify>Если установлена переменная noclobber (не разрушать),  то
этот файл  либо не должен до этого существовать,  либо он
должен быть специальным символьным файлом (например, терминалом или  /dev/null),  в  противном случае результатом
будет ошибка. Это помогать предотвратить случайное разрушение файлов. В таком случае, для подавления этой проверки могут быть использованы записи, включающие знак !.
<p align=justify>Формы записей,  включающие знак &,  направляют диагностический  вывод в определенный файл, так же как и стандартный вывод. Параметр name раскрывается так  же,  как  и  в
случае записи вида &lt; для имен файлов ввода.
<p><dt>
&gt;&gt; name
<br>&gt;&gt;& name
<br>&gt;&gt;! name
<br>&gt;&gt;&! name<dd>
Использует файл,  задаваемый параметром name,  в качестве
стандартного вывода, как и в формах записей с символом &gt;,
но помещает  вывод в конец этого файла.  Если установлена
переменная noclobber, то будет возникать ошибка, если при
отсутствии в форме записи знака !  заданный файл не будет
существовать.  Во всем остальном эти формы записи  аналогичны формам со знаком &gt;.
</dl>
<p align=justify>Если выполняется  неприсоединенная команда (с последующим знаком &),  то стандартным вводом для этой команды  по  умолчанию
будет пустой файл /dev/null.  В противном случае,  эта команда
присутствует в конвейере и воспринимает среду,  в которой  был
вызван интерпретатор shell,  как уже измененную при помощи параметров ввода-вывода.  Таким образом, как и для некоторых более ранних интерпретаторов shell, команды, выполняемые из файла команд интерпретатора shell,  не имеют доступа к тексту команд  по умолчанию;  вместо этого они принимают первоначальный
стандартный ввод интерпретатора shell. Механизм &lt;&lt; должен быть
использован для  представления  последовательных  данных.  Это
позволяет командным сценариям интерпретатора shell  функционировать  в качестве составляющих конвейеров,  а также разрешает
интерпретатору shell блокировать чтение его ввода.
<p align=justify>Диагностический вывод может быть направлен  через  программный
канал со стандартным выводом. Просто следует использовать форму записи |& вместо |.
<p align=justify><b>Выражения</b><br>
Несколько встроенных команд (должны быть  описаны  позже)  используют выражения, операторы в которых аналогичны применяемым
в языке С,  с тем же самым порядком старшинства. Такие выражения появляются в командах @,  exit, if и while. Доступными являются следующие операторы:
<pre>
	|| && | ^ & == != &lt;= &gt;= &lt; &gt; &lt;&lt; &gt;&gt;
	+ - * / % ! ~ ( )
</pre>
<p align=justify>Здесь порядок старшинства увеличивается слева направо,  операторы == и !=, &lt;=, &gt;=, &lt; и &gt;, &lt;&lt; и &gt;&gt;, + и -, * / и %, находясь
в группах, имеют тот же уровень старшинства. Операторы == и !=
сравнивают свои аргументы в виде символьных  строк,  остальные
операторы действуют на числах. Символьные строки, начинающиеся
с 0,  рассматриваются как восьмеричные числа.  Нулевые или отсутствующие аргументы рассматриваются как 0.  Результатом всех
выражений являются строки, которые представляют собой десятичные  числа. Важно отметить, что никакие две составляющие выражения не могут появляться в одном слове; исключение  представляют  смежные  составляющие выражений, которые имеют синтаксическое значение для синтаксического анализатора (& | &lt;
&gt; ( )), они должны быть окружены с двух сторон пробелами.
<p align=justify>Кроме того, в выражениях доступными, как   примитивные операнды, являются командные исполнения, заключенные в скобки вида {
и },  а также файловые запросы вида -l name,  где l имеет одно
из значений:
<table>
<tr valign=top><th>r  <td>   Доступ для чтения
<tr valign=top><th>w  <td>   Доступ для записи
<tr valign=top><th>x  <td>   Доступ для выполнения
<tr valign=top><th>e  <td>   Существование
<tr valign=top><th>o  <td>   Владение
<tr valign=top><th>z  <td>   Нулевой размер
<tr valign=top><th>f  <td>   Простой файл
<tr valign=top><th>d  <td>   Каталог
</table>
<p align=justify>Задаваемым значением name в файловых запросах является раскрытие команды и имен файлов,  которое, затем, проверяется на соответствие заданных полномочий (-l) правам реального пользователя.  Если файл не существует,  или не является доступным, то
все запросы возвращают значение false(ложь),  т.е. 0. Если выход из команды происходит со статусом 0, то командные исполнения  завершаются  успешно,  возвращая  значение true (истина),
т.е. 1; в противном случае, они завершаются неуспешно, возвращая значение false,  т.е. 0. Если требуется получить более детальную информацию о статусе, то команда должна быть выполнена
вне  выражения  и  должна  быть  проконтролирована  переменная
status.
<p align=justify><b>Управляющая Логика</b><br>
Интерпретатор shell содержит некоторое число  команд,  которые
могут быть  использованы для регулирования логики управления в
командных файлах (сценариях интерпретатора shell) и  при вводе
с терминала (ограниченный,  но удобный способ).  Под действием
таких команд интерпретатор shell осуществляет повторное считывание или пропуск своих входных данных, а также, в зависимости
от реализации, эти команды ограничивают местоположение некоторых из них.
<p align=justify>Утверждения foreach,  switch  и  while,  так  же  как  и форма
if-then-else утверждения if,  требуют,  чтобы главные ключевые
слова появлялись  в  одной  простой  команде на входной строке
так, как это показано ниже.
<p align=justify>Если ввод интерпретатора shell не доступен для поиска,  то интерпретатор shell  накапливает  входные данные в буфере всякий
раз, когда происходит считывание цикла,  и выполняет  поиск  в
этом  внутреннем  буфере для осуществления повторного считывания,  предполагаемого этим циклом.  (В той степени,  насколько
это возможно, команды возвратного перехода будут выполнены успешно для входных данных, недоступных для поиска.)
<p align=justify><b>Встроенные Команды</b><br>
Встроенные команды выполняются  внутри  интерпретатора  shell.
Если встроенная команда встречается как любая составляющая некоторого конвейера,  исключая последнюю,  то она выполняется в
интерпретаторе sub-shell.
<dl><dt>
alias
<br>alias name
<br>alias name wordlist<dd>
Запись первого вида печатает все псевдонимы. Второй вид
записи печатает псевдоним для параметра name. Последняя
запись назначает  заданный  параметр  wordlist  (список
слов) в   качестве   псевдонима   для  параметра  name;
wordlist является раскрытием команд и имен файлов. Значение  параметра name не должно быть командой alias или
unalias.
<p><dt>
break<dd>
Вызывает возобновление  выполнения  после оператора end
ближайшего объемлющего утверждения foreach  или  while.
Выполняются  оставшиеся  команды текущей строки.  Таким
образом,  возможны многоуровневые прерывания,  посредством записи их всех на одной строке.
<p><dt>
breaksw<dd>Вызывает прерывание (команда break) из  команды switch,
повторно после endsw.
<p><dt>
case label:<dd>
Метка в утверждении switch, как описано ниже.
<p><dt>
cd
<br>cd name
<br>chdir
<br>chdir name<dd>
Изменяет рабочий каталог интерпретатора shell на  каталог name. Если аргумент не задан, то производится замена на входной (home) каталог пользователя. Если каталог
name не найден в качестве подкаталога в текущем каталоге (и не начинается с /,  ./ или с ../), то проверяется
каждая составляющая переменной cdpath,  не является  ли
каталог name ее подкаталогом.  Наконец, если все предыдущие попытки завершились неуспешно,  а  аргумент  name
является переменной интерпретатора shell,  значение которой начинается с /,  то проверяется,  является ли она
каталогом.
<p><dt>
continue<dd>
Продолжает выполнение  ближайшего объемлющего утверждения while или foreach.  Выполняются  остальные  команды
текущей строки.
<p><dt>
default:<dd>
Отмечает меткой  выбор  по  умолчанию   в   утверждении
switch. Выбор по умолчанию должен находиться после всех
меток оператора case.
<p><dt>
echo wordlist<dd>
Указанные в  параметре  wordlist  слова  отображаются в
стандартный вывод интерпретатора shell.  Применение  \c
приводит к  завершению  процесса отображения без печати
признака новой строки.  Применение  \n  в  списке  слов
wordlist  приводит  к печати признака новой строки.  Во
всех остальных случаях отображаемые  слова  разделяются
пробелами.
<p><dt>
else
<br>end
<br>endif
<br>endsw<dd>
См. описание утверждений if, switch и while ниже.
<p><dt>
exec command<dd>
Указанная аргументом command команда выполняется вместо
работающего в данный момент интерпретатора shell.
<p><dt>
exit
<br>exit(expr)<dd>
Осуществляет выход из интерпретатора shell либо со значением переменной status (первая форма записи), либо со
значением, заданным выражением expr (вторая форма записи).
<p><dt>
foreach name (wordlist)
<br>  ...
<br>end<dd>
Последовательно устанавливается  переменная  name   для
каждого члена списка слов wordlist,  и выполняется последовательность команд между этой командой и  соответствующим ей оператором end.  (Оба ключевых слова foreach
и end должны находиться на отдельных строках.)
<p align=justify>Встроенная команда continue может быть использована для
того, чтобы продолжить цикл преждевременно,  а встроенная команда break для его  преждевременного завершения.
При считывании этой команды с терминала считывание цикла происходит один раз с  выдачей  приглашения  в  виде
знака ?  перед выполнением любого утверждения из цикла.
<p><dt>
glob wordlist<dd>
Действует, как и команда echo,  но  наличие  отменяющих
символов \ не распознается, а слова в выводе разделяются при помощи пустых  символов.  Удобна  для  программ,
которым  требуется использовать интерпретатор shell для
того, чтобы раскрыть список слов в имена файлов.
<p><dt>
goto word<dd>
Указанное параметром   word  слово  представляет  собой
раскрытие имен файлов и команд,  которое формирует символьную строку метки формы.  Интерпретатор shell пересматривает все свои входные данные,  насколько это  возможно, и  осуществляет  поиск  строки этой метки формы:,
возможно,  с предшествующими знаками пробелов и табуляции. Выполнение продолжается после указанной строки.
<p><dt>
history<dd>
Выводит на экран список событий предыстории.
<p><dt>
if (expr) command<dd>
Если при  вычислении значения указанного выражения expr
получено значение "истина",  то выполняется одна команда,  заданная  параметром  command,  с  ее аргументами.
До этого производится подстановка переменных  на  параметре command, и тогда же она выполняется для остальной
части команды if.  Значением параметра  command  должна
быть простая команда,  а не конвейер, список команд или
заключенный в круглые скобки список  команд. Ввод/вывод
перенаправляется даже в том случае,  если значением выражения expr является "ложь",  т.е.  когда сама команда
не выполняется.
<p><dt>
if (expr) then
<br>...
<br>else if (expr2) then
<br>...
<br>else
<br>...
<br>endif<dd>
Если указанное  выражение expr имеет значение "истина",
то выполняются команды до первого ключевого слова else;
в противном случае, если выражение expr2 имеет значение
"истина", то выполняются команды до  второго  ключевого
слова else; и т.д. Допускается любое число пар else-if;
при этом требуется только одно  ключевое  слово  endif.
Ключевое слово else и следующие за  ним  команды  также
являются необязательными.  (Слова  else  и endif должны
появляться в начале входных строк;  слово if должно появляться на своей входной строке или после слова else.)
<p><dt>
logout<dd>
Завершает интерпретатор shell вхождения в систему. Если
установлена переменная ignoreeof, то использование этой
команды является единственным способом выхода из системы.
<p><dt>
nice
<br>nice +number
<br>nice command
<br>nice +number command<dd>
Запись первого вида  устанавливает  параметр  nice  для
данного интерпретатора shell в значение 4. По умолчанию
команды,  выполняемые  под  управлением  интерпретатора
С-Shell, имеют "nice value" (значение приоритета), равное 0.  Вторая форма записи устанавливает параметр nice
в значение, заданное числом number. Две последние формы
записи  задают выполнение команды с приоритетом,  соответственно,  4 и задаваемым параметром number. Привилегированный  пользователь  может  указать  отрицательный
приоритет при помощи командs "nice  -number  ...".  Эта
команда всегда выполняется в подмножестве интерпретатора subshell,  и в простых  утверждениях  if  появляются
накладываемые на команды ограничения.
<p><dt>
nohup
<br>nohup command<dd>
Первая форма записи может быть использована в сценариях
интерпретатора shell для того,  чтобы вызвать игнорирование сигналов разъединения для оставшейся части сценария.  Вторая форма записи приводит к выполнению указанной команды с игнорированием сигналов разъединения. Команда nohup не действует,  если при этом  интерпретатор
shell не выполняется отдельно. Для всех процессов, неприсоединенных при помощи &,  автоматически  выполняется
команда nohup. (Т.е. на самом деле nohup не требуется.)
<p><dt>
onintr
<br>onintr <br>onintr label<dd>
Управляет функционированием  интерпретатора  shell  при
прерываниях. Первая форма записи восстанавливает  действия интерпретатора shell в случае  прерываний, которые
выполняются для   завершении  сценариев  интерпретатора
shell или для возврата на уровень ввода команд с терминала.  Вторая  форма  onintr - приводит к игнорированию
всех прерываний. Последняя форма записи вызывает выполнение интерпретатором shell перехода на метку при приеме прерывания или,  когда в следствие прерывания завершается порожденный процесс.
<p align=justify>Во всяком случае, если выполняется неприсоединенный интерпретатор shell и игнорируются прерывания,  все  виды
записей onintr не имеют смысла,  и интерпретатор shell,
также как и все вызванные команды, продолжают игнорировать прерывания.
<p><dt>
rehash<dd>
Приводит к пересчету внутренней таблицы хэширования содержаний каталогов в переменной path. Эта команда необходима при добавлении новых команд к каталогам из  значения переменной path, в то время, как Вы осуществляете
вхождение в систему.  Она может  потребоваться  только,
если  Вы добавляете команды к одному из своих собственных каталогов,  или если системный программист изменяет
содержимое одного из системных каталогов.
<p><dt>
repeat count command<dd>Задаваемая параметром command,  который подчиняется тем
же самым ограничениям,  что и параметр command, находящийся в строке утверждения if, описанного выше, команда
выполняется столько  раз,  сколько  указано в параметре
count. Переадресация ввода/вывода  производиться  точно
один раз даже, если значением count является 0.
<p><dt>
set
<br>set name
<br>set name=word
<br>set name[index]=word
<br>set name=(wordlist)<dd>
Первая форма записи команды  показывает  значение  всех
переменных интерпретатора  shell.  Значение переменных,
если оно представлено не одним словом,  выводится списком слов,  заключенным  в круглые скобки.  Вторая форма
записи устанавливает параметр name в  значение пустой
строки. Третья форма записи устанавливает параметр name
в значение одного слова,  задаваемого параметром  word.
Четвертый вид команды устанавливает индексированную при
помощи параметра index составляющую  имени  в  значение
слова; эта  составляющая должна уже существовать.  Последняя форма записи команды устанавливает параметр name
в значение списка слов, задаваемое аргументом wordlist.
Во всех случаях это значение является раскрытием команд и имен файлов.
<p align=justify>Эти аргументы могут быть  повторены,  чтобы  установить
несколько значений в одной команде установки.  Заметим,
тем не менее, что раскрытие переменных производится для
всех аргументов перед тем,  как  происходит  какая-либо
установка.
<p><dt>
setenv name value<dd>
Устанавливает переменную среды name в  значение  value,
представляемое одиночной строкой. Полезными переменными
среды являются TERM,  тип Вашего терминала и SHELL, тот
интерпретатор shell, который Вы используете.
<p><dt>
shift
<br>shift variable<dd>
Члены специальной переменной argv, не учитывая argv[1],
сдвигаются влево.  Если переменная argv не  установлена
или  имеет в качестве своего значения менее одного слова, то это является ошибкой. Вторая форма записи выполняет  те  же  действия на указанной параметром variable
переменной.
<p><dt>
source name<dd>
Интерпретатор shell считывает команды из источника, задаваемого параметром name.  Команды source  могут  быть
вложенными;  если уровень их вложенности слишком велик,
интерпретатор shell может выйти за границы  определения
файловых дескрипторов. Ошибка в команде source на любом
уровне  вложенности  завершает  все  вложенные  команды
source. Ввод,  производимый  во время выполнения команд
source, никогда не  помещается  в  список  предыстории.
<p><dt>
switch (string)
<br>case str1:
<br>  ...
<br> breaksw
<br>...
<br>default:
<br>  ...
<br> breaksw
<br>endsw<dd>
Каждая метка  выбора (case) последовательно сопоставляется с заданной строкой string, которая сначала делает
раскрытие  команд и имен файлов.  Файловые метасимволы
*, ?  и [...] могут быть использованы в метках  выбора,
которые являются  раскрытием переменных.  Если до метки
выбора по умолчанию  (default:)  никакого  соответствия
меткам не найдено, то выполнение начинается после метки
по умолчанию.  Каждая метка выбора и метка по умолчанию
должны  располагаться в начале строки.  Команда breaksw
приводит к продолжению выполнения после  endsw.  В  остальных случаях  управление может быть передано в соответствии с вариантными метками и метками  по умолчанию,
как  и в языке С.  Если не найдено никаких соответствий
меток и отсутствуют метки по умолчанию, выполнение продолжается после endsw.
<p><dt>
time
<br>time command<dd>
При отсутствии  аргумента,  печатается суммарное время,
использованное данным интерпретатором shell и порожденными им процессами. Если аргумент задан, то для указанной (параметр  command)  простой  команды  производится
подсчет времени  и его итоговое значение выводится также, как описано для переменной time. При необходимости,
когда  команда  завершается,  создается  дополнительный
shell для вывода статистики по времени.
<p><dt>
umask
<br>umask value<dd>
Маска создания файла выводится на экран  (первая  форма
записи)  или  устанавливается  в  указанное  параметром
value значение (вторая форма команды). Маска задается в
восьмеричном представлении.   Как  правило,  значениями
маски являются 002,  задающее все права доступа к файлу
для  группы,  а  для других пользователей разрешение на
чтение и выполнение, и 022, задающее все права доступа,
исключая разрешение на запись для пользователей в группе или других пользователей.
<p><dt>
unalias pattern<dd>
Все псевдонимы,  имена которых соответствуют указанному
в параметре pattern образцу, отбрасываются. Таким образом, команда unalias * удаляет все псевдонимы. Не будет
ошибкой,  если команда unalias  применяется  к  пустому
множеству псевдонимов.
<p><dt>
unhash<dd>
Запрещается использование внутренней таблицы  хэширования для ускорения размещения выполняемых программ.
<p><dt>
unset pattern<dd>
Все переменные,  имена которых соответствуют указанному
параметром pattern образцу,  удаляются.  Таким образом,
команда unset * удаляет все переменные.  Не будет ошибкой, если команда unset применяется к пустому множеству
переменных.
<p><dt>
wait<dd>
Все порожденные  процессы  находятся в состоянии ожидания. Если интерпретатор shell выполняется в интерактивном режиме,  то  прерывание может нарушить ожидание,  в
таком случае интерпретатор shell напечатает имена и номера всех незавершенных порожденных процессов.
<p><dt>
while (expr)
<br>  ...
<br>end<dd>
Пока указанное выражение expr принимает ненулевое  значение, выполняются  команды между while и соответствующим ему оператором end.  Команды break и continue могут
быть  использованы  для преждевременного завершения или
продолжения этого цикла.  (Ключевые слова while  и  end
должны появляться  каждое на своей входной строке.) При
первом проходе  цикла  также,  как  и  для  утверждения
foreach, в этом месте производится выдача приглашения в
случае, если устройством ввода является терминал.
<p><dt>
@
<br>@ name = expr
<br>@ name[index] = expr<dd>
Первый вид  команды  печатает  значения всех переменных
интерпретатора shell. Вторая форма команды устанавливает заданный  параметр  name  в значение выражения expr.
Если выражение содержит символы &lt;,  &gt;,  & или |,  то по
крайней  мере эта часть выражения должна быть заключена
в ().  Третья форма записи назначает значение выражения
expr индексируемому  агрументом  index  параметру name.
Как name, так и его составляющая, определяемая индексом
index, к этому моменту должны уже существовать.
</dl>
<p align=justify>Операторы *=,  +=,  и т.п. являются доступными, как и в
языке С.  Пробел,  отделяющий имя от оператора назначения, является необязательным. Наличие пробелов является
обязательным в разделяемых составляющих выражения expr,
которые в любом случае должны быть отдельными словами.
<p align=justify>Специальные постфиксные операторы ++  и  --,  соответственно,  увеличивают  на единицу и уменьшают на единицу
значение name, например, @ i++.
<p align=justify><b>Предопределенные Переменные</b><br>
Последующие переменные  имеют специальное значение для интерпретатора shell.  Из них argv, child, home, path, prompt, shell
и status всегда устанавливаются интерпретатором shell. За исключением child и status, эта установка производится только при
инициализации; эти переменные не будут модифицироваться до тех
пор, пока это определенно не будет сделано пользователем.
<p align=justify>Интерпретатор shell копирует переменную среды PATH в  переменную path, а также копирует это значение обратно в среду всякий
раз,  когда переменная path устанавливается. Следовательно, не
стоит беспокоиться о том, что ее установка будет отличаться от
той,  что присутствует в файле .cshrc, так как внутренние процессы  csh  будут импортировать определение переменной path из
среды.
<table>
<tr valign=top><th>argv      <td>      Принимается в качестве аргументов для  интерпретатора  shell,  именно  из  этой  переменной
производится подстановка позиционных  параметров,  например,  $1 заменяется на $argv[1],  и
т.д.
<tr valign=top><th>cdpath    <td>      Задает список альтернативных каталогов для поиска подкаталогов в командах cd.
<tr valign=top><th>child     <td>      Выводится номер процесса,  когда последняя команда была разветвлена при помощи &. Эта переменная  является  командой  unset,  когда этот
процесс завершается.
<tr valign=top><th>echo      <td>      Устанавливается, когда в командной строке  задана опция -x.  Вызывает отображение на экране
каждой команды и ее аргументов непосредственно
перед тем,  как команда выполняется. Для невстроенных команд все раскрытия происходят до их
отображения   на  экране.  Встроенные  команды
отображаются на экране до  выполнения  подстановки  команд  и  имен  файлов,  поскольку эти
подстановки выполняются затем выборочно.
<tr valign=top><th>histchars   <td>    Может быть назначена  двух-символьная  строка.
Первый символ  используется в качестве символа
предыстории вместо знака !,  второй символ используется  вместо  механизма  подстановки  ^.
Например,  если  произведена  установка   вида
histchars=",;", то символами предыстории будут
точка и точка с запятой.
<tr valign=top><th>history    <td>     Может быть задано числовое значение для  контролирования размера списка предыстории.  Никакая команда,  на которую производится  ссылка,
укладывающаяся  в  это количество событий,  не
будет отброшена.  Слишком большое значение переменной  history  может привести к превышению
памяти интерпретатора shell.  Последняя выполняемая  команда  всегда  сохраняется  в списке
предыстории.
<tr valign=top><th>home      <td>      Входной (home) каталог вызывающего пользователя,  эта переменная инициализируется из среды.
Раскрытие имени файла,  представленного ~, отсылает к этой переменной.
<tr valign=top><th>ignoreeof    <td>   Если эта переменная установлена,  то интерпретатор shell  игнорирует признак конца файла от
устройств ввода, которые являются терминалами.
Это предотвращает ситуацию случайного завершения интерпретатора shell по нажатию Ctrl-D.
<tr valign=top><th>mail      <td>      Файлы, которые интерпретатор  shell  проверяет
на наличие  почтовых  сообщений.  Эта проверка
выполняется после завершения  каждой  команды,
результатом  которой  будет вывод приглашения,
при условии истечения заданного временного интервала. Интерпретатор shell выводит сообщение
"You have  new  mail" (Для Вас есть новая почта"), если существует файл, для которого время
доступа  не превышает времени его модификации.
<p align=justify>Если первое слово значения переменной mail является числом, то оно задает иное значение интервала проверки почты,  а именно: в секундах,
вместо значения по умолчанию,  которое составляет 10 минут.
<p align=justify>Если указаны несколько почтовых файлов, то при
наличии почты  в  файле,  определяемом  именем
name, интерпретатор  shell отвечает сообщением
"New mail  in  name"  ("Новая  почта  в  файле
name").
<tr valign=top><th>noclobber    <td>   Как было описано в  разделе  "Ввод/Вывод",  на
переадресацию  вывода накладываются определенные ограничения для того,  чтобы  предохранить
такие файлы от случайного повреждения, а переадресации вида  &gt;&gt;  относятся  к  существующим
файлам.
<tr valign=top><th>noglob      <td>    Установка этой переменной препятствует раскрытию имен файлов. Это очень удобно для сценариев интерпретатора shell, которые не работают с
именами файлов,  или  после того,  как получен
список имен файлов, а дальнейшие раскрытия являются нежелательными.
<tr valign=top><th>nonomatch   <td>    Если эта  переменная установлена,  то не будет
ошибкой ситуация,  когда раскрытие имен файлов
не соответствует  никаким существующим файлам;
при этом просто возвращается этот первоначальный образец. Однако, ошибкой будет неправильно
сформированный образец, т.е. отображение [ дает ошибку.
<tr valign=top><th>path     <td>       Каждое слово переменной пути path задает каталог, в котором должны быть найдены команды для
выполнения. Нулевое слово указывает на текущий
каталог. Если переменная path отсутствует,  то
будут работать  только  полные обозначения путей. Обычно,  путь поиска  представляется  как
/bin, /usr/bin  и .,  но он может изменяться в
зависимости от используемой системы.  Для привилегированного  пользователя  путь поиска по
умолчанию представляется каталогами /etc, /bin
и /usr/bin.  Интерпретатор shell,  которому не
задана ни опция -c,  ни опция -t, как правило,
будет  хэшировать содержимое каталогов в переменной path после считывания файла .cshrc каждый раз,  когда переустанавливается переменная
path. Если при активизированном интерпретаторе
shell  в эти каталоги добавляются новые команды,  то имеет смысл задавать  команду  rehash,
в противном  случае  эти команды могут быть не
найдены.
<tr valign=top><th>prompt    <td>      Символьная строка,   которая  выводится  перед
каждой командой,  считываемой  с терминального
ввода в  интерактивном  режиме.  Если  в  этой
строке появляется символ !,  то он будет заменен на номер текущего  события,  если  ему  не
предшествует символ \.  Для привилегированного
пользователя эта переменная имеет  значение  %
или #.
<tr valign=top><th>shell     <td>      Файл, в котором находится интерпретатор shell.
Эта переменная используется в  разветвляющихся
процессах интерпретатора shell для интерпретации файлов,  для которых установлены биты  исполнения, но  которые не доступны для выполнения системой.  (См.  ниже  раздел  "Выполнение
невстроеннных команд".)  При инициализации заносится во  входной  (home)  каталог  (системно-зависимый) интерпретатора shell.
<tr valign=top><th>status    <td>      Возвращаемый статус   (состояние   завершения)
последней команды.  Если  она  завершилась  не
нормально, то  к  значению статуса добавляется
0200. При неуспешном завершении встроенных команд возвращается статус 1, в остальных случаях для встроенных команд статус устанавливается в значение 0.
<tr valign=top><th>time      <td>      Управляет автоматическим  отсчетом времени для
команд. Если эта  переменная  установлена,  то
при завершении некоторой команды,  которая использует больше  положенных  для  нее   секунд
центрального процессора,    будет   печататься
строка, содержащая следующую информацию: пользователя, систему, реальное значение времени и
процентное соотношение использования  времени,
которое определяется отношением суммы времени,
использованного пользователем и системой к реальному времени.
<tr valign=top><th>verbose    <td>     Устанавливается при помощи опции -v,  заданной
в командой строке;  приводит к печати слов  из
каждой  команды  после  выполнения подстановки
предыстории.
</table>
<p align=justify><b>Выполнение Невстроенных Команд</b><br>
При обнаружении команды,  которая не является  встроенной,  но
должна быть выполнена,  интерпретатор shell пытается выполнить
эту команду через команду <a href=EXEC~1.htm>exec(3)</a>.  Каждое слово в  переменной
path задает имя каталога,  из которого интерпретатор shell будет пытаться выполнить эту команду.  Если не заданы  ни  опция
-c,  ни опция -t, то интерпретатор shell будет выполнять хэширование таких имен в этих каталогах во внутреннюю таблицу  таким образом, что он будет пытаться применить exec только в каталоге,  в котором, возможно, находится эта команда. Это повышает скорость обнаружения команды в случае, когда в пути поиска представлено большое количество каталогов.  Если этот механизм будет выключен (посредством команды unhash), или если интерпретатору shell будет задан с аргументами -c или -t,  и, во
всяком случае,  для  каждого каталога,  являющего составляющей
переменной path,  которая не начинается с символа /, интерпретатор  shell выполняет конкатенацию с именем заданной команды,
чтобы сформировать полное обозначение пути к файлу, который он
затем пытается выполнить.
<p align=justify>Команды, заключенные  в  круглые скобки,  всегда выполняются в
подмножестве интерпретатора subshell. Так, команда (cd; pwd) ;
pwd печатает каталог home;  оставляя при этом Вас там,  где Вы
были (отображая это место после каталога home), в то время как
команда  cd ;  pwd оставляет Вас в этом входном каталоге home.
Заключенные в круглые скобки команды довольно часто  используются  для  предотвращения  воздействие текущего интерпретатора
shell на команду cd.
<p align=justify>Если файл имеет разрешения на выполнение,  но не является двоичным выполняемым файлом в данной системе,  то считается,  что
этот файл содержит команды интерпретатора shell,  и для  того,
чтобы считать его, подгружается новый интерпретатор shell.
<p align=justify>Если для  shell существует псевдоним,  то,  чтобы сформировать
команду интерпретатора shell,  для списка аргументов подготавливаются слова псевдонима. Первое слово псевдонима должно быть
полным  обозначением  пути  интерпретатора  shell   (например,
$shell). Заметим,  что  это  специальный,  встречающийся позже
случай подстановки псевдонима, и допускает только слова, которые должны быть подготовлены для списка аргументов,  без модификации.
<p align=justify><b>Обработка Списка Аргументов</b><br>
Если нулевым аргументом для интерпретатора shell является знак
-, то это интерпретатор shell вхождения в систему. Аргументы в
виде флагов интерпретируются следующим образом:
<table>
<tr valign=top><th>-c  <td>  Команды считываются  из (отдельного) следующего аргумента, который должен быть представлен. Все остальные аргументы помещаются в переменную argv.
<tr valign=top><th>-e  <td>  Интерпретатор shell  завершается,  если  любая вызванная
команда заканчивается не нормально,  или получен ненулевой статус выхода.
<tr valign=top><th>-f  <td>  Интерпретатор shell будет запускаться быстрее, поскольку
ни для одной выполняемой команды из файла .cshrc не  будет  производиться поиск во входном (home) каталоге вызвавшего пользователя.
<tr valign=top><th>-i  <td>  Интерпретатор shell выполняется в интерактивном режиме и
выводит приглашение для своего ввода верхнего уровня даже, если ввод производится не с терминала.  Все процессы
shell выполняются  в  интерактивном режиме без установки
этой опции, если устройствами их ввода и вывода являются
терминалы.
<tr valign=top><th>-n  <td>  Команды подвергаются синтаксическому анализу,  но не выполняются. Эта опция может быть полезна при синтаксической проверке сценариев интерпретатора shell.
<tr valign=top><th>-s  <td>  Входные команды поступают с устройства стандартного ввода.
<tr valign=top><th>-t  <td>  Считывается и выполняется одна строка  ввода.  Символ  \
может быть  использован для отмены признака новой строки
в конце данной строки и продолжения ее текста на  другой
строке.
<tr valign=top><th>-v  <td>  Вызывает установку переменной verbose, действием которой
является отображение на экране ввода команд после выполнения подстановки предыстории.
<tr valign=top><th>-x  <td>  Вызывает установку  переменной  echo,  действием которой
является отображение на  экране  команд  непосредственно
перед их выполнением.
<tr valign=top><th>-V  <td>  Вызывает установку  переменной  verbose  непосредственно
перед выполнением файла .cshrc.
<tr valign=top><th>-X  <td>  Вызывает установку переменной echo непосредственно перед
выполнением файла .cshrc.
</table>
<p align=justify>После обработки аргументов в виде флагов,  и если остались аргументы arg...,  но не были заданы опции -c, -i, -s или -t, то
выбирается первый аргумент из списка arg ...  в качестве имени
файла  команд,  предназначенных для выполнения.  Интерпретатор
shell открывает этот файл и сохраняет его имя  для  возможного
выполнения повторной  подстановки  по  $0.  В типичной системе
большинство сценариев интерпретатора shell пишется  для  стандартного интерпретатора shell (см. команду <a href=SH.htm>sh(1)</a>), интерпретатор shell в синтаксисе языка С будет  выполнять  каждый  стандартный интерпретатор shell,  если первым символом сценария не
будет символ # (т.е.  если сценарий не начинается с  комментария). Оставшиеся аргументы инициализируют переменную argv.
<p align=justify><b>Обработка Сигналов</b><br>
Интерпретатор shell обычно игнорирует  сигналы  quit.  Сигналы
interrupt и quit игнорируются для вызываемой команды,  если за
этой командой следует символ &;  во всех остальных случаях эти
сигналы имеют те значения, которые наследуются интерпретатором
shell от породившего его процесса.  Обработка прерываний  процессами shell может быть управляемой при  помощи  onintr.  Интерпретаторы  shell  вхождения  в систему перехватывают сигнал
terminate;  в остальных случаях этот сигнал поступает к порожденному процессу из того состояния, в котором он был в процессе, породившем интерпретатор shell. Ни в коем случае не разрешаются прерывания,  когда  интерпретатор  shell считывает файл
.logout.
<p align=justify><b>ФАЙЛЫ</b>
<table>
<tr valign=top><td><tt>
~/.cshrc     </tt><td>   Считывается каждым интерпретатором shell в начале выполнения
<tr valign=top><td><tt>
/etc/cshrc   </tt><td>   Системно-расширенный файл cshrc по  умолчанию,
если никакой не представлен
<tr valign=top><td><tt>
~/.login    </tt><td>    Считывается интерпретатором  shell вхождения в
систему после файла .cshrc во время выполнения
вхождения в систему
<tr valign=top><td><tt>
~/.logout  </tt><td>     Считывается интерпретатором  shell вхождения в
систему во время выполнения выхода из системы
<tr valign=top><td><tt>
/bin/sh    </tt><td>     Интерпретатор shell для сценариев, не начинающихся с символа #
<tr valign=top><td><tt>
/tmp/sh*    </tt><td>    Временный файл для ввода при помощи &lt;&lt;
<tr valign=top><td><tt>
/dev/null   </tt><td>    Источник пустого файла
<tr valign=top><td><tt>
/etc/passwd   </tt><td>  Источник входных (home) каталогов для ~name
</table>
<p align=justify><b>ОГРАНИЧЕНИЯ</b><br>
Длина слов не может быть больше 512 символов. Число аргументов
для команды, которая вызывает раскрытие имен файлов, ограничивается 1/6 от числа символов, разрешенных в списке аргументов,
которое составляет 5120,  меньше,  чем символов в среде. Кроме
того, подстановки  команд не могут подставить символов больше,
чем разрешено в аргументном списке.
<p align=justify>В целях обнаружения зацикливаний интерпретатор shell ограничивает количество подстановок псевдонимов на одной строке до 20.
<p align=justify><b>СМОТРИТЕ ТАКЖЕ</b><br>
<a href=ACCESS~1.htm>access(3)</a>, <a href=EXEC~1.htm>exec(3)</a>,  fork(3),  pipe(3),  signal(3),  umask(3),
wait(3), <a href=ENVIRON.htm>environ(5)</a>.
<p align=justify><b>РАЗРЕШЕНИЕ</b><br>
Эта утилита  была  разработана  в Калифорнийском Университете,
г.Беркли, и разрешена к использованию.
<p align=justify><b>ЗАМЕЧАНИЕ</b><br>
Встроенные команды структуры  управления,  такие  как
foreach и while,  не могут быть использованы с символами |,  &
или ; .
<p align=justify>Команды внутри циклов, приглашения которых имеют символ ?, не помещаются в список предыстории команды history.
<p align=justify>Нельзя использовать модификаторы двоеточия (:) на выходе подстановок команд.
<p align=justify>Интерпретатор С-shell имеет много встроенных команд с теми  же
именами и функциями, что и у команд интерпретатора shell Баурна. Тем не менее, синтаксис таких команд зачастую различается.
Одним из таких примеров является команда nice, другим - команда echo.  Следует использовать соответствующий корректный синтаксис при работе с этими встроенными командами интерпретатора
С-shell.
<p align=justify>Когда пользователь С-shell входит в систему, система считывает
и выполняет команды из файла /etc/cshrc перед тем,  как выполнить команды из пользовательского файла $HOME/.schrc. Следовательно, Вы можете модифицировать среду интерпретатора  С-shell
для всех пользователей системы, отредактировав файл /etc/cshrc.
<p align=justify>Во время выполнения аппаратной загрузки системы,  нажатие клавиши delete,  как только интерпретатор С-shell выведет приглашение (%),  может  вызвать  завершение  работы  интерпретатора
shell. Если  при  этом  команда  csh  является интерпретатором
shell вхождения в систему, то будет произведен выход пользователя из системы.
<p align=justify>Команда csh пытается импортировать и экспортировать переменную
PATH для ее использования вместе со обычными сценариями интерпретатора shell. Это работает только для простых случаев, когда переменная PATH не содержит командных символов.
<p align=justify>Данная версия команды csh не поддерживает  или  не  использует
тех средств управления процессами, которые имеются в 4-ой версии, разработанной в Беркли.
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/footer0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table>
</body>
</html>
