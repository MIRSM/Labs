<html>
<head>
<title>SH(1) </title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/header0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="_pic_/logo.gif" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>

<h3 align=center>SH(1) </h3>
<p align=justify><b>ИМЯ</b><br>
sh - Вызывает командный интерпретатор shell.
<p><b>СИНТАКСИС</b>
<pre>
	sh [-ceiknrstuvx] [args]
</pre>
<p align=justify><b>ОПИСАНИЕ</b><br>
Shell - это cтандартный командный язык программирования, который  выполняет  чтение  команд с терминала или из файла.  Ниже
смотрите описание раздела ВЫЗОВ (INVOCATION), в котором описаны значения аргументов интерпретатора shell.
<p align=justify><b>КОМАНДЫ</b><br>
Простая команда(simple-command)   -   это   последовательность
слов(words),  не содержащих пустых символов и разделенных пробелами (пустой символ(blank) - это знак табуляции или пробел).
Первое слово определяет имя выполняемой команды. За исключением того что определено ниже,  оставшиеся слова передаются  как
аргументы в вызванную команду.  Имя команды передается как аргумент 0 (смотрите команду <a href=EXEC.htm>exec(2)</a>).  В случае нормального завершения работы простой команды значение (value) - это состояние ее выхода,  а в случае аварийного завершения (восьмеричное
значение)1000+ значение состояния (status) (т.е. если аварийно
завершилась  основная  процедура  файла).   Смотрите   команду
signal(S), где приведен список оценок состояний.
<p align=justify>Конвейер(pipeline) -  это  последовательность  одной или более
команд, разделенных символом вертикальная черта (|). (Символ ^
устаревший синоним  для  символа  вертикальная  черта и его не
следует использовать в конвейере).Стандартный вывод каждой команды,  кроме последней, связан каналом pipe(S) cо стандартным
вводом следующей команды.  Каждая команда выполняется как  отдельный процесс; интерпретатор shell ждет завершения последней
команды.
<p align=justify>Список(list) - это последовательность одного или более  конвейеров,  разделенных  символами  ;,&,&& или ||(две вертикальные
черты) и необязательно завершающихся символами  ;  или  &.  Из
этих четырех символов,  символы ; и & имеют одинаковый приоритет, который ниже чем у символов && и ||. Символы && и || также имеют равный приоритет. Точка с запятой (;) вызывает последовательное выполнение предыдущего  конвейера;  амперсанд  (&)
вызывает  асинхронное  выполнение  предыдущего конвейера (т.е.
интерпретатор shell не ждет завершения этого конвейера).  Символ &&(||) вызывает список(list) следующий за ним для выполнения,  только если состояние выхода предыдущего конвейера равно
нулю  (не ноль).  Произвольное количество символов новых строк
может появиться в списке (list) вместо точки с запятой (;) для
разделения команд.
<p align=justify>Команда (а cоmmand) представляет  собой  либо простую команду,
либо одну из перечисленных ниже.  Значение,возвращаемое командой,определяется значением последней простой команды выполненной в команде, кроме значений установленных иначе.
<pre>
	for name [in word...]
	do
	list
	done
</pre>
<p align=justify>Каждый раз при выполнении команды for аргумент name устанавливается для следующего слова(word),  взятого из списка in word.
Если аргумент in word...  отсутствует, то команда for выполнит
аргумент do list один раз для каждого установленного позиционного параметра (смотрите ниже описание раздела ПОДСТАНОВКА ПАРАМЕТРА (Parameter  Substitution)).  Выполнение   завершается,
когда в списке больше нет слов(words).
<pre>
	case word in
	[ pattern [|pattern ]...)list
	 ;;]
	case
</pre>
<p align=justify>Команда case выполняет список list,  связанный с первым шаблоном(pattern), который соответствует аргументу word. Форма шаблонов совпадает с формой,  используемой  при  генерации  имени
файла (смотрите   описание   раздела   ГЕНЕРАЦИЯ  ИМЕНИ  ФАЙЛА
(Filename Generation)).
<pre>
	if list then
	list
	[ elif list then
	list ]
	[ else list ]
	fi
</pre>
<p align=justify>Аргумент list,следующий  за  командой  if выполняется и,  если
возвращаемое состояние выхода равно 0,  то выполняется  список
list  следующий за первым параметром then.  Иначе,  выполнится
список list,  следующий за elif и,  если его значение равно 0,
то выполнится  список list,  относящийся к следующему then.  В
противном случае,  выполнится else list.  Если не  выполняются
аргументы  else list или then list,  то команда if  возвращает
нулевое состояние выхода.
<pre>
	while list
	do
	list
	done
</pre>
<p align=justify>Команда while неоднократно выполняет  параметр  while  list и,
если  состояние  выхода последней команды в списке равно нулю,
то выполняет do list;  в противном случае,  цикл  завершается.
Если команды в аргументе do list не  выполняются,  то  команда
while возвращает нулевое состояние выхода; команда until может
быть использована вместо команды while для отмены проверки завершения цикла.
<dl>
<dt>(list)<dd>
Выполнять аргумент list в субинтерпретаторе sub-shell
<p><dt>{ list;}<dd>
Аргумент list просто выполняется
<p><dt>name () { list;}<dd>
Определить функцию,  на которую ссылаются с помощью  аргумента
name. Тело  функций  это  список (list) команд между фигурными
скобками {}.  Ниже описано выполнение функций (смотрите описание раздела ВЫПОЛНЕНИЕ (Execution)).
</dl>
Следующие слова  определяются только как первое слово команды,
когда не взяты в кавычки:
<pre>
	if then else elif fi case esac for while until do done { }
</pre>
<p align=justify><b>КОММЕНТАРИИ</b><br>
Слово, начинающееся с символа # означает, что слово и все последующие символы до символа новая строка будут игнорироваться.
<p align=justify><b>ПОДСТАНОВКА КОМАНДЫ</b><br>
Стандартный вывод из команды,заключенной в пару штрихов (` `),
может быть использован как для части,так и  для  всего  слова;
последующие символы новых строк удаляются.
<p align=justify><b>ПОДСТАНОВКА ПАРАМЕТРА</b><br>
Символ $  используется  для   ввода   подставляемых   параметров(parameters). Позиционные параметры  могут быть установлены
значениями команды set.  Значения переменным могут быть назначены  следующей  записью:
<pre>
	name=value[ name=value]... (имя-значение)
</pre>
Сравнение шаблона с численным значением value не производится.
<dl>
<dt>${parameter}<dd>
Параметр(parameter) -  это  последовательность  букв,цифр  или
символов подчеркивания, имя (name) это цифра или любой из символов *,@,#,?,-,$ и !. Значение параметра,если такое существует,  замещается. Фигурные скобки требуются только когда за параметром   (parameter)   следует   буква,   цифра   или   знак
подчеркивания, которые не будут интерпретированы как часть его
имени.  Имя (name) должно начинаться с буквы или символа  подчеркивания.Если параметр (parameter) это цифра, то это позиционный параметр.  Если параметр (parameter) это символ * или @,
то  все позиционные параметры,  начинающиеся с $1,  замещаются
(разделенные пробелами).  Параметр $0 устанавливается с  аргумента ноль,когда происходит вызов shell.
<p><dt>${parameter:-word}<dd>
Ecли параметр (parameter) установлен и не равен нулю,  то происходит подстановка его значения, иначе подставляется word.
<p><dt>${pаrameter:=word}<dd>
Еcли параметр (parameter) не назначен или равен нулю, то установить его в word; значение параметра затем подставляется. Позиционные параметры не могут быть назначены этим способом.
<p><dt>${parameter:?word}<dd>
Если параметр (parameter) установлен и не ноль,  то происходит
подстановка его значения,  иначе печатается  аргумент  word  и
осуществляется выход из shell. Если аргумент word отсутствует,
то печатается сообщение  "Параметр равен нулю или не  установлен".
<p><dt>${parameter:+word}<dd>
Если параметр (parameter) установлен и не равен нулю, то подставить  аргумент word;  иначе ничего не подставляется.  В выше
приведенном описании,  аргумент word не рассматривается  кроме
тех случаев,  когда он должен быть использован как подставляемая строка, так что в следующем примере команда pwd выполнится
если только аргумент d не установлен или равен нулю:
<pre>
	echo ${d:-`pwd`}
</pre>
<p align=justify>Если двоеточие (:) опушено в вышеприведенном примере, то shell
только проверит установлен параметр (parameter) или нет.
</dl>
<p align=justify>Следующие параметры автоматически устанавливаются  интерпретатором shell:
<table>
<tr valign=top><th># <td> количество позиционных параметров в десятичном виде;
<tr valign=top><th>- <td> состояние флагов,установленных при вызове shell или командой set;
<tr valign=top><th>? <td> десятичное значение кода возврата последней синхронно  выполненной команды;
<tr valign=top><th>$ <td> номер процесса текущего shell;
<tr valign=top><th>! <td> номер процесса вызвавшего последнюю фоновую команду.
</table>
Следующие параметры используются интерпретатором shell:
<dl>
<dt>CDPATH <dd> Путь поиска для команды cd.  Смотрите раздел ВСТРОЕННЫЕ КОМАНДЫ (Special Commands) команда "cd".
<p><dt>HOME <dd>   Аргумент  по умолчанию (входной каталог) для  команды
cd.
<p><dt>РATH <dd>   Путь поиска команд ( смотрите  ниже описание  раздела
ВЫПОЛНЕНИЕ (Execution)).
<p><dt>MAIL <dd>   Если эта  переменная определяет имя почтового  файла,
то  интерпретатор  shell  информирует  пользователя о
прибытии почты в указанном файле.
<p><dt>MAILCHECK<dd>
Этот параметр определяет как часто (в  секундах)  интерпретатор shell будет контролировать прибытие почты
в файлах,  определенных параметрами MAIL и  MAILPATH.
Значение по умолчанию 600 секунд(10 минут).  Если установлен ноль, то shell будет проверять прибытие почты перед каждым приглашением.
<p><dt>MAILPATH<dd>
Двоеточие разделяет список имен файлов. Если этот параметр установлен,  интерпретатор  shell  информирует
пользователя  о  прибытии  почты в любом из указанных
файлов. За каждым именем файла может следовать символ
%  и сообщение,  которое будет напечатано когда измениться время модификации. Сообщение по умолчанию "you
have mail - для вас есть почта".
<p><dt>PS1    <dd> Первичная строка подсказка по умолчанию "$".
<p><dt>PS2    <dd> Вторичная строка подсказка по умолчанию ">".
<p><dt>IFS    <dd> Внутренние разделители полей, обычно пробел, знак табуляции и символ новой строки.
<p><dt>SHACCT <dd> Если этот параметр установлен для имени файла перезаписанного пользователем, то интерпретатор shell будет
писать запись учета в  файл  для  каждой  выполненной
процедуры shell.    Программы    учета    такие   как
acctcom(8)  и  <a href=ACCTON.htm>accton(8)</a>  могут   быть   использованы
для анализа собранных данных.  Это свойство используется не во всех версиях интерпретатора shell.
<p><dt>SHELL <dd>  При своей активизации,shell просматривает среду в поисках  этого  имени (смотрите  ниже  описание раздела
СРЕДА  (Environment)).  Если  оно  найдено и содержит
'r', как часть его значения, то shell cтановится ограниченным.
</dl>
<p align=justify>Интерпретатор shell  получает  по умолчанию следующие значения
PATH, PS1, PS2 и IFS, в то время как совсем не устанавливаются
интерпретатор shell  параметры HOME и MAIL (хотя HOME устанавливается командой login(5)).
<p align=justify><b>ИНТЕРПРЕТАЦИЯ ПУСТОГО СИМВОЛА</b><br>
После подстановки параметра и команды,  результаты подстановки
просматриваются для определения символов внутренних разделителей полей  (символы  определены в параметре IFS) и разделяются
на отдельные аргументы,  если таковые символы  найдены.  Явные
нулевые  аргументы (" " или ' ') сохраняются.  Неявные нулевые
аргументы ( возникающие из параметров, которые не имеют значений) удаляются.
<p align=justify><b>ГЕНЕРАЦИЯ ИМЕНИ ФАЙЛА</b><br>
Вслед за подстановкой, каждая команда word просматривается для
обнаружения символов *,?, и [. Если один из этих символов присутствует, то  команда   word   рассматривается   как   шаблон
(pattern).  Команда word замещается именами файлов, отсортированными в алфавитном порядке,  которые соответствуют  шаблону.
Если нет имени файла соответствующего шаблону, то команда word
остается неизменной.  Символ . в начале имени файла или непосредственно  следующий за символом /,  так же как сам символ /,
должен  быть  точно  указан. Символы  и  соответствующие    им
шаблоны:
<table>
<tr valign=top><th>* <td> Соответствует любой строке, включая нулевую строку.
<tr valign=top><th>? <td> Соответствует любому одиночному символу
<tr valign=top><th>[...]<td>
Соответствует любым символам  из  заданного  набора.  Пара
символов разделенных  - (тире) соответствует любому лексическому символу,  содержащемуся между парой символов. Если
первый символ, следующий за открывающейся квадратной скобкой "[" это символ "!", то это соответствует любому символу не включенному в скобки.
</table>
<p align=justify><b>ЗАКЛЮЧЕНИЕ В КАВЫЧКИ (Quoting)</b><br>
Cледующие символы имеют специальное назначение в интерпретаторе shell и вызывают завершение команды  word  (кроме  случаев,
когда эти символы заключены в кавычки):
<pre>
	; & ( ) | ^ &lt; > символ новой строки,  пробел, символ табуляции
</pre>
<p align=justify>Символ может быть заключен в кавычки (т.е.подготовлен для  установки самого себя) предшествующим ему символом \. Комбинация
пары символов \ и знак новой строки игнорируются. Все символы,
заключенные между парой одинарных кавычек (' '), за исключением одинарной  кавычки(апостроф),  берутся  в  кавычки.  Внутри
двойных  кавычек  (" ") осуществляется подстановка параметра и
команды и символ \ заключает в кавычки символы \,`," и $. Символ "$ *" эквивалентен "$1 $2...", тогда как символ "$@" эквивалентен "$1" "$2"....
<p align=justify><b>ПОДСКАЗКА</b><br>
Когда вы  работаете  в интерактивном режиме,  то перед чтением
команды интерпретатор shell выводит подсказку,  значение параметра PS1.  Если в любой момент времени набрана новая строка и
требуется продолжение ввода текста для завершения  набора  команды, то появляется вторичная подсказка(т.е.значение параметра PS2).
<p align=justify><b>ПРОГРАММА ПРОВЕРКИ ОРФОГРАФИИ</b><br>
Когда используется команда <a href=CD.htm>cd(1)</a> интерпретатор shell проверяет
орфографию введенной команды.  Для примера, если вы переходите
в другой каталог, используя команду cd и сделали орфографическую ошибку в имени каталога, интерпретатор shell сообщает альтернативную орфографию  существующего каталога.  Введите "y" и
нажмите RETURN (или просто  нажмите  RETURN)  для  перехода  в
предложенный каталог.  Если предложенная орфография некорректна, введите "n",  затем введите корректную командную строку. В
следующем примере, реакция интерпретатора shell на ввод команды <a href=SH.htm>sh(1)</a> показана жирным шрифтом:
<pre>
	$cd/usr/spol/uucp
	cd/usr/spool/uucp?y
	ok
</pre>
<p align=justify><b>ВВОД/ВЫВОД</b><br>
Перед выполнением команды,  ее ввод и вывод может быть переадресован с помощью специальной системы обозначений  интерпретируемой  shell.  Обозначения  могут появится где-либо в простой
команде,  а также могут предшествовать или следовать за командой (сommand).  Они не переходят в вызванную команду;  подстановка располагается перед словом word или цифрой digit:
<dl>
<dt> &lt;word  <dd>    Cтандартный ввод  берется из файла word( дескриптор
файла 0).
<p><dt> >word  <dd>    Cтандартный вывод направляется в файл  word(  дескриптор  файла  1).  Если файл не существует,  то он
создается; иначе, он урезается до нулевой длины.
<p><dt> >>word  <dd>   Стандартный вывод направляется в  файл  word.  Если
файл существует, то вывод добавляется к нему (путем
установки указателя на конец  файла);  в  противном
случае, файл создается.
<p><dt> &lt;&lt;[-]word <dd> Интерпретатор shell считывает ввод до строки, имеющей то же самое значение,  что и word, или до конца
файла. Результирующий документ становится стандартным вводом. Если любой символ аргумента word заключен в кавычки,  то символы документа не интерпретируются, иначе, осуществляется подстановка параметра
и команды,  (неустраненные) символы \ и знак  новой
строки  игнорируются,  а также символ \ должен быть
использован для заключения в кавычки символов \,$,'
и  первого  символа  аргумента  word.  Если  символ
-(черта) добавлен к символам  &lt;&lt;,  то  все  впереди
стоящие  символы  табуляции отсекаются из аргумента
word и из документа.
<p><dt> &lt;&digit  <dd>  Дескриптор файла  стандартного  ввода  получается в
результате дублирования      дескриптора      файла
digit. (Смотрите описание команды  dup(S)). Подобно
этому  для  стандартного  вывода используется конструкция >&digit.
<p><dt> &lt;&-    <dd>    Стандартный ввод закрыть.  Подобно этому, для стандартного вывода используется комбинация >&-.
</dl>
<p align=justify>Если любой,  из выше перечисленных,  конструкций  предшествует
цифра,  то  файл будет иметь дескриптор,  задаваемый этой цифрой (вместо используемых по умолчанию  дескрипторов  0  и  1).
Например,
<pre>
	...2>&1
</pre>
команда создает дескриптор файла 2,  который  является  дублем
дескриптора файла 1.
<p align=justify>Если за  командой следует символ &,  то  стандартный  ввод  по
умолчанию  для команды это пустой файл /dev/null.  Иначе,среда
для выполнения команды содержит дескрипторы файлов вызываемого
shell, измененные спецификациями ввода/вывода.
<p align=justify><b>СРЕДА</b><br>
Среда (environment)(смотрите  описание команды <a href=ENVIRON.htm>environ(5)</a>) это
список пар "имя-значение",  который передается  в  выполняемую
программу точно также как и обычный список аргументов. Интерпретатор shell взаимодействует со средой несколькими способами.
При  вызове,  shell просматривает среду и создает параметр для
каждого найденного имени,  назначая ему соответствующее значение.  Выполненные  команды  наследуют ту же самую среду.  Если
пользователь изменяет значения этих параметров или создает новые, то  никакие из этих параметров не влияют на среду,  кроме
команды export,  которая  используется  для  связи  параметров
shell со средой.  Среда просмотренная любой выполненной командой состоит из любых неизмененных пар "имя-значение"  первоначально унаследованных интерпретатором shell,  минус любые пары
удаленные с помощью команды unset,  плюс любые  изменения  или
дополнения,  каждые из которых должны быть записаны в командах
export.
<p align=justify>Среда для любой простой  команды  (simple-command) может  быть
увеличена  c  помощью использования перед ней одного или более
назначений параметров. Таким образом:
<pre>
	TERM=450cmd args
	и
	(export TERM; TERM=450; cmd args)
</pre>
эквивалентны (что касается выполнения выше приведенной команды
сmd).
<p align=justify>Если флаг -k установлен, то все ключевые аргументы размещаются
в среде,  даже если они указаны после имени  команды.
<p align=justify><b>CИГНАЛЫ</b><br>
Сигналы INTERRUPT(прерывание)  и QUIT(выход) для вызванной команды игнорируются,  если за командой следует символ &; иначе,
сигналы имеют значения унаследованные интерпретатором shell от
его родительского процесса, с ожиданием сигнала 11. Ниже смотрите описание команды trap).
<p align=justify><b>ВЫПОЛНЕНИЕ</b><br>
Каждый раз когда выполняется команда осуществляются вышеприведенные подстановки. Если имя команды не соответствует одной из
ВСТРОЕННЫХ  КОМАНД,  но соответствует имени определенной функции,  то функция выполняется в процессе shell (заметим как это
отличается от выполнения процедур shell). Позиционные параметры $1,$2...  устанавливаются для аргументов функции.  Если имя
команды не соответствует ни встроенной команде, ни имени определенной функции,  то создается новый процесс и осуществляется
попытка выполнить команду с помощью команды <a href=EXEC.htm>exec(2)</a>.
<p align=justify>Параметр shell PATH определяет путь поиска каталога,  содержащего команду. Имена альтернативных каталогов разделяются двоеточием(:). Путь по умолчанию это :/bin:/usr/bin (определяя текущий каталог в таком порядке /bin и /usr/bin).  Заметим,  что
текущий каталог определяется именем нулевого пути, которое может появиться сразу после знака равенства или  между символами
двоеточие(:) в любом месте в списке пути. Если имя команды содержит символ /, то путь поиска не используется. Иначе, каждый
каталог указанный в пути поиска просматривается для поиска выполняемого файла. Если файл выполняемый, но не является файлом
a.out, то он будет представлять собой файл, содержащий команды
shell. Субинтерпретатор sub-shell (т.е.отдельный процесс) создается для его чтения.  Заключенная в скобки команда также выполняется в субинтерпретаторе sub-shell.
<p align=justify>Местоположение в пути поиска,  где была найдена команда, запоминается shell  (чтобы избежать лишних действий позднее). Если
команда была найдена в  связном  каталоге,  ее  местоположение
должно быть переопределено всякий раз,  когда изменяется текущий каталог. Интерпретатор shell забывает все сохраненные местоположения,  всякий раз, когда переменная PATH изменяется или
выполняется команда hash-r (описание ее смотрите ниже).
<p align=justify><b>ВСТРОЕННЫЕ КОМАНДЫ</b><br>
Для этих команд разрешена переадресация ввода/вывода.
<dl>
<dt>: <dd> Пустая команда. Это команда ничего не делает.Возвращает нулевое состояние выхода.
<p><dt>.file<dd>
Cчитать и выполнить команду из указанного файла(file), после чего вернуться назад.  Для поиска каталога,  содержащего
файл(file), используется путь поиска определенный  параметром PATH.
<p><dt>break[ n ]<dd>
Выход из объемлющего цикла for или while,  если таковой существует. Если задано n, то выполняется выход из уровня n.
<p><dt>continue[ n ]<dd>
Начать следующую  итерацию объемлющего цикла for или while.
Если задано n, то возобновляется выполнение с n-го объемлющего цикла.
<p><dt>cd[ arg ]<dd>
Команда  изменяет  текущий каталог на указанную в аргументе
arg.  Параметр  shell  HOME  это аргумент arg по умолчанию.
Параметр shell CDPATH определяет путь поиска каталога,  содержащего  arg.  Альтернативные имена каталогов разделяются
двоеточием. Путь по умолчанию это нулевой <null> (определяющий текущий каталог). Заметим, что текущий каталог определяется именем нулевого пути,  которое может появиться сразу
после  знака равенства или между символами двоеточие(:),  в
любом месте в списке пути.  Если аргумент arg начинается  с
символа /,  то путь поиска не используется.  Иначе,  каждый
каталог из пути просматривается для поиска arg.
<p align=justify>Если shell прочитал его команды с терминала и указанного каталога не существует (или не найдены некоторые компоненты),  используется  исправление  орфографии каждой компоненты каталога
(directory) для поиска "корректного" имени, затем shell запрашивает  надо ли изменять каталог на исправленное имя каталога,
ответ "n" подразумевает "нет",  любой  другой  ответ  означает
"да".
<p><dt>echo[arg...]<dd>
Записывает аргументы, разделенные пробелами и заканчивающиеся символом новой строки,  в стандартный вывод.  Аргументы
могут быть заключены в кавычки.  Кавычки требуются для того
чтобы  интерпретатор  shell  корректно  интерпретировал эти
специальные escape последовательности:
<table>
<tr valign=top><th>\b <td> возврат на одну позицию
<tr valign=top><th>\c <td> печатает строку без символа новой строки
<tr valign=top><th>\f <td> прогон страницы
<tr valign=top><th>\n <td> символ новой строки
<tr valign=top><th>\r <td> возврат каретки
<tr valign=top><th>\t <td> табуляция
<tr valign=top><th>\v <td> вертикальная табуляция
<tr valign=top><th>\\ <td> символ backslash
<tr valign=top><th>\n <td> 8-битовый символ,  чей  код  ASCII  представляет собой
1,2,3-х разрядное число в восьмеричной  форме, число n
должно начинаться с нуля
</table>
<p><dt>eval[ arg...]<dd>
Аргументы arg читаются  интерпретатором  shell  в  качестве
ввода, и полученная в результате команда (команды) выполняется.
<p><dt>exec[ arg...]<dd>
Вместо интерпретатора shell выполняется команда, задаваемая
аргументами,  новый процесс не создается.  В команде  могут
присутствовать аргументы ввода/вывода, если кроме них в команде exec нет других аргументы,  происходит переназначение
ввода/вывода shell.
<p><dt>exit[ n ]<dd>
Вызывает завершение работы shell с состоянием выхода n. Если параметр n опущен,  состояние выхода будет состояние выхода последней выполненной  команды.  Признак  конца  файла
также приведет к выходу из интерпретатора shell.
<p><dt>export[ name...]<dd>
Указанные переменные names помечаются  для  автоматического
экспорта  в  среду  (environment) выполняемых далее команд.
Если аргументы не заданы,  печатается список всех имен экспортируемых в этот shell.
<p><dt>hash[ -r ][ name...]<dd>
Для каждого имени (name), местоположение в пути поиска  команды указанной параметром name определяется и запоминается
интерпретатором shell. Опция -r вызывает shell для устранения всех запомненных местоположений.  Если параметры не заданы, то предоставляется информация о запомненных командах.
Hits (справки) это  количество  вызовов  команды  процессом
shell. Cost (затраты) это мера работы, требуемая чтобы разместить команду в пути поиска.  Существуют определенные ситуации,  в которых требуется,  чтобы сохраненные размещения
команды  были пересчитаны.  Команды,  для которых это будет
сделано помечаются звездочкой(*),  стоящей рядом с информацией hits.  Сost будет наращена, после того как сделают пересчет.
<p><dt>newgrp[ arg...]<dd>
Эквивалентна команде exec newgrp arg...
<p><dt>pwd
Печатает текущий работающий каталог.Смотрите <a href=PWD.htm>pwd(1)</a> для ознакомления с описанием и использованием команды.
<p><dt>read[ name...]<dd>
Из стандартного ввода считывается одна строка и первое слово присваивается первой переменной name,  второе слово второй переменной name и т.д.,  оставшиеся слова присваиваются
последней переменной name. Ненулевое состояние выхода возвращается только при достижении конца файла.
<p><dt>readonly[ name...]<dd>
Полученные переменные names помечаются как доступные только
для  чтения  (readonly),  значения этих переменных не могут
быть изменены с помощью последующего назначения. Если параметры не заданы, печатается список всех переменных, доступных только для чтения (readonly).
<p><dt>return[ n ]<dd>
Вызывает функцию для выхода с  значением  возврата, указанным в n. Если n опущено, то состояние возврата соответствует состоянию последней выполненной команды.
<p><dt>set[ -eknuvx[ arg...]]<dd>
<table>
<tr valign=top><th>-е <td> Если интерпретатор shell неинтерактивный,то осуществляется  немедленный выход, в случае если команда завершилась с ненулевым кодом завершения работы.
<tr valign=top><th>-f <td> Запрет формирования имени файла.
<tr valign=top><th>-h <td> Разместить и запомнить функциональные команды как функции,которые определены (функциональные  команды  обычно
размещаются, когда функция выполнена).
<tr valign=top><th>-k <td> Поместить в среду все ключевые параметры для команды, а
не только те, которые предшествуют имени команды.
<tr valign=top><th>-n <td> Считать команды, но не выполнять их.
<tr valign=top><th>-u <td> Считать ошибкой подстановку неустановленных переменных.
<tr valign=top><th>-v <td> Печатать входные строки shell по мере их считывания.
<tr valign=top><th>-x <td> Печатать команды и их параметры по мере их  выполнения.
Хотя    этот   флаг   передается   в   субинтепретатор
(sub-shell),  он не может быть отслежен в этих  субинтерпретаторах.
<tr valign=top><th>-- <td> Не изменять любые флаги; полезен в установке $1 в -.
</table>
<p align=justify>Для отмены назначений флагов лучше  использовать  символ  +
вместо символа -.  Эти флаги также могут задаваться при вызове интерпретатора shell.  Текущую установку флагов  можно
найти в параметре $-.  Оставшиеся аргументы это позиционные
параметры и присваиваются по порядку  переменным  $1,$2,...
Если  не  задано ни одного параметра,  то будут распечатаны
значения всех переменных.
<p><dt>shift[n]<dd>
Позиционные параметры с $2...  переименовываются в $1...
<p><dt>test
Вычисляет условные выражения. Смотрите <a href=TEST.htm>test(1)</a> для ознакомления с описанием и использованием  команды.
<p><dt>times<dd>
Выдать суммарные  времена  - время пользователя и системное
время,  затраченные на выполнение процессов,  запущенных из
интепретатора shell.
<p><dt>trap[ arg ][ n ]...<dd>
Параметр arg представляет собой  команду,  которую  следует
считать и выполнить при получении сигнала (сигналов) n.(Заметим,что параметр вычисляется дважды: сначала при установке прерывания на сигнал, а потом при его обработке). Команды прерывания trap выполняются в  порядке  номера  сигнала.
Максимальный номер сигнала - 16.  Любые попытки к установке
прерывания на сигнал,  который был игнорирован на  входе  в
текущий shell не эффективны.  Попытка установить прерывание
на сигнал 11(дефект памяти) приведет к ошибке.  Если  параметр arg отсутствует, то все прерывания n восстанавливаются
в их исходные значения.  Если параметр arg является  пустой
строкой,  то  указанный сигнал игнорируется интерпретатором
shell и вызываемыми из него командами.  Если n равно  нулю,
то параметр arg команды выполнится при выходе из shell. Команда trap без параметров печатает список  команд связанных
с каждым номером сигнала.
<p><dt>type[ name...]<dd>
Каждое имя (name) помечается как  оно  будет  интерпретироваться, если использовано как имя команды.
<p><dt>ulimit[[ -f ]n ]<dd>
Налагает ограничение размера блоков n в файлах.
<table>
<tr valign=top><th>-f  <td>  налагает ограничение размера блоков n в файлах,  созданных процессами-потомками (могут быть прочитаны файлы любого размера).  Любой пользователь может уменьшить ограничение размера файла,  но увеличить  ограничение  может только  привилегированный  пользователь,  находящийся  в
корневом каталоге. Если команда без аргументов, то будет
напечатано текущее ограничение. Если опции не заданы, то
назначается опция -f.
</table>
<p><dt>unset[ name...]<dd>
Для каждого имени (name),  команда удаляет  соответствующую
переменную или функцию.  Не могут быть использованы следующие переменные PATH,PS1,PS2,MAILCHECK и  IFS,  так  как  их
нельзя сбрасывать.
<p><dt>umask[ ооо ]<dd>
Маска пользователя при  создании  файла  устанавливается  в
восьмеричный номер ооо, где о - восьмеричная цифра (смотрите <a href=UMASK~1.htm>umask(1)</a>). Если ооо опущено, то будет напечатано текущее
значение маски.
<p><dt>wait[ n ]<dd>
Эта команда  ждет окончания работы заданного процесса и сообщает его состояние завершения.  Если n не задано,  то команда wait ждет завершения всех процессов-потомков,  активных в данный момент. Код возврата этой команды всегда равен
нулю.
</dl>
<p align=justify><b>ВЫЗОВ</b><br>
Если shell  вызван через команду <a href=EXEC.htm>exec(2)</a> и первый символ нулевого параметра это -,  то команды  первоначально  читаются  из
входного файла /etc/profile,  а затем из файла $HOME/.profile,
если такие файлы существует.  После этого, команды считываются
как описано ниже,  что происходит также в случае,  когда shell
вызван как /bin/sh.  Приведенные ниже  флаги  интерпретируются
shell только при вызове.  Отметим, что кроме того что указывается флаг -с или -s,  первому аргументу назначается имя  файла
содержащего команды, и оставшиеся аргументы передаются как позиционные параметры в этот командный файл:
<table>
<tr valign=top><th>-с string <td> Если задан флаг -с, то команда считывается из строки string.
<tr valign=top><th>-s   <td>      Если задан флаг -s или если аргументы не сохраняются,  то команды считываются из стандартного  ввода.
Любые  оставшиеся  аргументы определяют позиционные
параметры. Вывод интерпретатора shell  записывается
в файл с дескриптором 2.
<tr valign=top><th>-t    <td>     Если задан флаг -t,  то читается и выполняется одиночная команда и интерпретатор  shell  завершается.
Этот флаг  предназначается для использования только
программами написанными на языке С и  бесполезен  в
интерактивном режиме.
<tr valign=top><th>-i    <td>     если задан флаг -i или если ввод и вывод shell связаны с терминалом,  то этот shell является интерактивным.  В этом случае, сигнал завершения TERMINATE
игнорируется  (  так  что команда kill 0 не вызовет
прекращение работы интерактивного shell)  и  сигнал
прерывания  INTERRUPT перехватывается и игнорируется( так что команда wait прерываема).  Во всех случаях, сигнал выхода QUIT игнорируется shell.
<tr valign=top><th>-r   <td>      если задан флаг -r, то работает ограниченный shell.
(смотрите описание команды <a href=RSH.htm>rsh(1)</a>).
</table>
<p align=justify>Оставшиеся флаги  и аргументы приведены в описании команды set
приведенной выше.
<p align=justify><b>СОСТОЯНИЕ ВЫХОДА</b><br>
При обнаружении  ошибок интерпретатором shell,  таких как синтаксические ошибки,  он возвращает ненулевое состояние выхода.
Если shell  используется в неинтерактивном режиме,  выполнение
файла shell прекращается.  Иначе,  shell возвращает  состояние
выхода последней выполненной команды. Смотрите описание команды exit приведенное выше.
<p><b>ФАЙЛЫ</b>
<pre>
	/etc/profile    системный файл по умолчанию profile,если ника- 
	                кие другие не присутствуют
	$HOME/.profile  читается логическим интерпретатором shell  при
	                подключении
	/tmp/sh*        временный файл для символов >>
	/dev/null       источник пустого файла
</pre>
<p><b>СМ. ТАКЖЕ</b><br>
<a href=CD.htm>cd(1)</a>, <a href=ENV.htm>env(1)</a>,   login(5),   newgrp   (1),   <a href=RSH.htm>rsh(1)</a>,  <a href=TEST.htm>test(1)</a>,
<a href=UMASK~1.htm>umask(1)</a>,  <a href=DUP.htm>dup(2)</a>,  <a href=EXEC.htm>exec(2)</a>,  <a href=FORK.htm>fork(2)</a>,   <a href=PIPE.htm>pipe(2)</a>,   signal(S),
<a href=UMASK.htm>umask(2)</a>, <a href=WAIT.htm>wait(2)</a>, a.out(3), profile(5), <a href=ENVIRON.htm>environ(5)</a>.
<p align=justify><b>ЗАМЕЧАНИЯ</b><br>
Команда readonly (без параметров) осуществляет такой  же вывод
как  и команда export.
<p align=justify>Если используются символы &lt;&lt; для обеспечения стандартного ввода в асинхронном процессе,  вызванном  с  помощью  символа  &,
то shell  имеет путаную информацию о имени вводного документа;
создается файл содержащий "мусор" /tmp/sh* и shell сообщает  о
невозможности найти этот файл с помощью другого имени.
<p align=justify>Если команда  выполнена  и команда с тем же самым именем установлена в каталоге,  входящего в путь поиска, до каталога, где
была  найдена исходная команда,  shell будет продолжать выполнять (exec) исходную команду.  Для изменения этой ситуации используйте команду hash.
<p align=justify>Если вы  покинули  текущий каталог или каталог,  расположенный
выше текущего, то команда pwd не сможет выдать корректный  ответ. Используйте команду cd с полным именем пути для изменения
этой ситуации.
<p align=justify>Когда пользователь команды <a href=SH.htm>sh(1)</a> входит в систему,  то она читает и  выполняет  команды из файла /etc/profile до выполнения
команд из файла пользователя $HOME/.profile. Поэтому, вы можете изменить  среду для всех пользователей команды <a href=SH.htm>sh(1)</a> в системе, отредактировав файл /etc/profile.
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/footer0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table>
</body>
</html>
