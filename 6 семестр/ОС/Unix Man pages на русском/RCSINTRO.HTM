<html>
<head>
<title>RCSINTRO(1) </title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/header0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="_pic_/logo.gif" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>

<h3 align=center>RCSINTRO(1) <br> КОМАНДЫ ПОЛЬЗОВАТЕЛЯ </h3>
<p align=justify><b>НАЗВАНИЕ</b><br>
обзор системы RCS - введение в Систему Отслеживания Версий
<p align=justify><b>ОПИСАНИЕ</b><br>
RCS (Revision Control  System)  представляет  собой  систему
отслеживания версий  изменяющихся текстовых или состоящих из
строк двоичных файлов, как текст на русском языке ( о прочих
--  см.  флаг  -kb  команды  co) файлов.  RCS автоматизирует
архивирование  (не  путать  со   сжатием!),   востребование,
регистрацию изменений,  идентификацию и сравнение файлов,  а
также внесение изменений в документ,  измененный другими  за
время   вашей   работы.  RCS  полезна  для  работы  с  часто
изменяющимися документами,  например, программами в процессе
разработки,  технической  документацией,  научными статьями,
деловой перепиской,  сборниками  инструкций,  и  существенно
облегчает работу с большими системами,  в особенности,  если
изменения в документы вносят разные люди.
<p align=justify>Взаимодействие с пользователем чрезвычайно  просто.  Новичку
достаточно знать две команды: ci и co.
<p align=justify>ci - сокращение от "check in" = "регистрация" (в том смысле,
в  каком  понимается  регистрация  на  самолет)  -  помещает
содержимое рабочего  файла   в   архивный   файл,   хранящий
предыдущие  его версии (точнее,  изменения между версиями) и
называемый также RCS-файлом.
<p align=justify>co -  сокращение  от  "check  out"  представляют  собой   не
обратный процесс  исключения,  а  получение  копии некоторой
версии из RCS-архива.
<p align=justify><b>ФУНКЦИИ RCS</b><br>
<ul>
<li>Хранить множественные версии текстовых документов.  RCS
хранит  старые  версии файла,  используя гораздо меньше
места, чем   компрессирующие  программы,  поскольку  ей
достаточно лишь описать внесенные изменения.
<p align=justify>Изменения, внесенные  в документ,  не портят оригинала,
старые версии  остаются  доступны  для  извлечения.  Их
можно разыскивать по номерам версий,  ключевым символам
(символьным переменным), датам, авторам и т.п.
<p align=justify><li>Хранить историю    изменений.    RCS     делает     это
автоматически.  Кроме самих изменений текста,  вносятся
также дата,  имя (точнее,  login name) автора,  дата  и
время    внесения    изменений,   и,   также,   краткие
комментарии, описывающие суть внесенных изменений. Эта,
своего  рода,  летопись,  позволяет быстро понять,  что
происходило  с  документом  без  трудоемкого  сравнения
распечаток и опроса работавших с текстом сотрудников.
<p align=justify><li>Вносит ясность в проблему доступа  нескольких  людей  к
одному  и  тому  же тексту.  Когда разные люди пытаются
получить доступ ко внесению изменений одновременно, RCS
предупреждает  их  и предотвращает затирание только что
внесенных изменений.
<p align=justify><li>Поддерживает целое  дерево  версий.  Если   над   одним
документом работает одновременно несколько человек, RCS
может поддерживать  раздельные  линии  развития  одного
документа, сохраняя их в структуре отражающей отношение
"предшествовать" между версиями.  Дерево может отражать
локальные отличия   версий,   поставляемых   конкретным
заказчикам, от главной линии развития.
<p align=justify><li>Объединять параллельные    линии    развития     одного
документа,   предотвращая  конфликты.  RCS  делает  это
производя "суммарное" изменение.  Если же  внесенные  в
две  линии  изменения  затронули один и тот же фрагмент
кода,  RCS  предупреждает  пользователя   о   наложении
изменений. Тот же механизм (см.  флаг  -j  команды  co)
позволяет отменить  изменение,  внесенное  на  одном из
предыдущих этапов,  сохранив исправления,  сделанные на
последующих. Это же позволяет  автоматически  создавать
локальные версии из новой главной и старой локальной.
<li>Управлять подразделением  версий  и   конфигураций.   В
дополнение   к   тому,   что   возможно  восстановление
состояние отслеживаемой системы, существовавшее в любой
заданный  момент,  соответственные  версии  всех файлов
могут быть  помечены  одним и тем же ключевым символом.
Версии может быть придан статус,  обозначающий, что она
является экспериментальной,  стабильной,  коммерческой,
выпуском  и  др.  Это позволяет просто и недвусмысленно
описывать этапы развития большой системы,  состоящей из
многих документов.
<p align=justify><li>Автоматически отождествлять версии  по  имени,  номеру,
времени создания, автору и т.п. Идентификационные метки
с  ключевыми словами,  вставляются в определенные места
истории изменений файла.  Такая схема  позволяет  легко
выяснить, какие  версии каких модулей составляют данную
конфигурацию или выпуск.
<p align=justify><li>Минимизировать необходимое   для  хранения  место.  Для
новой версии RCS хранит только изменения  (построчные).
Удаление  промежуточных версий позволит сэкономить лишь
на строках, которые изменялись несколько раз.
</ul>
<p align=justify><b>ПЕРВЫЕ ШАГИ В РАБОТЕ С RCS</b><br>
Предположим, Вы  хотите  отслеживать с помощью RCS изменения
файла f.c .  Создайте в том каталоге, где находится файл f.c
, подкаталог RCS ,
<pre>
	mkdir  RCS
</pre>
а затем зарегистрируйте его:
<pre>
	ci  f.c
</pre>
<p align=justify>Эта команда создаст в подкаталоге  RCS  некий  архивный файл
( RCS/f.c,v , если операционная система поддерживает запятые
в имени файла, и RCS/f.c , если -- нет), поместит в него f.c
в качестве версии 1.1 и запросит у вас описание файла -- что
он из себя представляет, зачем нужен и т.п. Эта запись будет
относиться  ко  всем  версиям.  При  регистрации  (внесении)
последующих  изменений  RCS  запрашивает  сообщение  другого
сорта --   регистрационную  запись  --  описание  внесенного
изменения,  которое будет  относиться  к  данной  конкретной
версии. Эти записи и составят историю изменений файла.
<p align=justify>В подкаталоге   RCS   находятся   архивные   или  RCS-файлы,
соответствующие находящимся уровнем выше рабочим файлам. Для
того,  чтобы  восстановить  файл f.c из предыдущего примера,
используйте команду co :
<pre>
	co  f.c
</pre>
<p align=justify>Это команда востребует в рабочий файл  новейшую  из  версий,
содержащихся в архиве,  но не позволит его изменять. Если же
нужно его редактировать дальше,  восстановите его снова,  но
забронировав его т.е. закрыв другим доступ для изменения:
<pre>
	co  -l  f.c
</pre>
( -l -- "lock" = "запереть"). Теперь Вы можете редактировать
f.c .
<p align=justify>Предположим, по  окончании  редактирования Вы хотите оценить
внесенные изменения. Команда
<pre>
	rcsdiff  f.c
</pre>
<p align=justify>сообщит Вам изменения файла по  сравнению  с  его  последней
зарегистрированной версией так же,  как это  делает  команда
<a href=DIFF.htm>diff(1)</a>. Занести новую версию в архив можно командой
<pre>
	ci  f.c
</pre>
что придаст новой версии очередной порядковый номер.
<p align=justify>При регистрации возможно сообщение об ошибке:
<pre>
	ci error: no lock set by your_name
</pre>
<p align=justify>(ошибка регистрации:  файл не забронирован для имярек),  это
означает, что Вы пытаетесь зарегистрировать файл, не оформив
правильно доступ,  т.е. не закрыв другим доступ к нему. Даже
в простейшем случае, когда файл не закрыт от Вас, уже поздно
бронировать файл с  помощью  извлечения  командой  co  -l  ,
потому,   что   это  уничтожит  только  что  сделанные  Вами
исправления. В таком случае воспользуйтесь командой
<pre>
	rcs  -l  f.c
</pre>
<p align=justify>Это зарезервирует  Вам  для  внесения  изменений   последнюю
зарегистрированную версию без ее извлечения и, тем самым, не
затрет еще  не  зарегистрированный  вариант.  Если же кто-то
помимо Вас работает над файлом,  Вы  получите  сообщение  об
ошибке и,  в этом случае, Вам придется договариваться с этим
лицом (или начинать новую ветвь --  если  Вы  работаете  над
разными строками  текста,  конфликт  Ваш  может  быть  легко
разрешен позднее командой rcsmerge ).
<p align=justify>Бронирование гарантирует,  что никто,  кроме Вас  не  сможет
зарегистрировать   следующую   версию   и,   таким  способом
позволяет избежать проблем, когда изменения вносятся разными
людьми.  Если  версия  забронирована,  ее  все  равно  можно
извлекать для чтения или компиляции. Обязательно бронировать
файл, нужно только для изменения.
<p align=justify>Если Вы -- единственный человек,  работающий с файлом, то Вы
можете отключить контроль  бронирования  конкретного  файла,
тогда Вам  не потребуется каждый раз его закрывать.  Сделать
режим бронирования строгим или нестрогим, можно командой
<pre>
	rcs  -U  f.c     либо     rcs  -L  f.c
</pre>
<p align=justify>В командах,  упомянутых  выше,  можно  указывать  и  архив и
рабочий файл,  а можно,  только один  из  них.  В  последнем
случае  RCS  сначала ищет архив в подкаталоге RCS ,  затем в
том же каталоге,  что и  заданный  рабочий  файл;  поиск  же
рабочего  файла  начинается  с  текущего  каталога.  Удобнее
держать архивы в подкаталоге RCS и не загромождать каталог с
рабочими файлами.  (В версии,  скомпилированной для  MS-DOS,
это необходимо из-за невозможности добавить архивный суффикс
к имени рабочего файла.)
<p align=justify>Если Вы  хотите избежать удаления зарегистрированного файла,
(чтобы,  например, компилировать его), можно воспользоваться
флагами
<pre>
	ci  -l  f.c     или     ci  -u  f.c
</pre>
<p align=justify>Обе формы регистрируют файл,  не удаляя его и экономят,  тем
самым,  одну  операцию  восстановления.  Первый  вариант  не
открывает  файла для других,  и удобен,  если Вы продолжаете
его,  редактировать; второй удобен, если Вы закончили работу
с  файлом;  но  оба  не изменят официального рабочего файла,
если Вы регистрируете файл из третьего места (указав путь  к
обоим файлам или слинковав официальный рабочий каталог RCS в
Ваш личный,  где находится Ваша  копия  рабочего  файла),  и
потребуется  команда  co  в  каталоге  с официальным рабочим
файлом,  чтобы заменить его последней версией.  При этом все
идентификационные метки файла (см. ниже) обновляются.
<p align=justify>Можно задать  номер новой версии в качестве явного аргумента
команды ci.  Например,  старые версии имели номера 1.1, 1.2,
1.3, и т.д., а Вы объявляете выпуск 2. Команда
<pre>
	ci  -r2  f.c     или     ci  -r2.1  f.c
</pre>
<p align=justify>присвоит новой  версии  номер 2.1.  Начиная с данной версии,
версии будут нумероваться 2.2,  2.3,  и т.д. соответствующая
форма команды co
<pre>
	co  -r2  f.c     или     co  -r2.1  f.c
</pre>
<p align=justify>востребует соответственно, либо последнюю из версий вида 2.x
либо  версию  2.1.   Команда  co  со флагом  -r  без  номера
востребует    последнюю    версию   главной   ветви,    т.е.
лексикографически наибольший номер версии, состоящий из пары
чисел. Для обозначения  побочных  ветвей  и  версий  из  них
требуется набор  большей длины.  Если,  например,  вы хотите
начать побочную ветвь вариантов от версии 1.3, наберите
<pre>
	ci  -r1.3.1  f.c
</pre>
<p align=justify>Эта команда  начнет  ветвь 1 версии 1.3 и даст первой версии
новой ветви номер 1.3.1.1.  Для дополнительной информации  о
побочных ветвях см. в разделе формат файлов rcsfile(5).
<p align=justify><b>АВТОМАТИЧЕСКАЯ ИДЕНТИФИКАЦИЯ</b><br>
<p align=justify>Для распознавания  версий,  RCS  может  вставлять в исходные
тексты и  в двоичный код специальные строки.  Чтобы добиться
этого,  вставьте в ваш текст,  скажем,  внутри  комментария,
ключевое слово, например
<pre>
	$Id$
</pre>
RCS заменит этот маркер строкой вида
<pre>
	$Id:  имя-файла версия дата время автор статус $
</pre>
<p align=justify>С такой отметкой на первой  странице  каждого  модуля  легко
видеть   номер  версии  рабочего  файла.  RCS  автоматически
обновляет такие идентификационные  маркеры.  Если  требуется
включить   такой  маркер  в  объектный  код,  присвойте  его
фиктивной строковой переменной. В C это делается так:
<pre>
	static char rcsid[] = "$Id$";
</pre>
<p align=justify>Команда ident позволяет определить  такие  маркеры  в  любых
файлах, будь то исполняемый код или сброшенный на диск образ
оперативной памяти.  Это позволяет определить версии (и  др.
атрибуты) модулей, использованных в программе.
<p align=justify>Другой маркер -- $Log$.  Он  заменяется  историей  изменения
файла. О прочих маркерах см. <a href=CO.htm>co(1)</a>.
<p align=justify><b>ПРОБЛЕМЫ</b><br>
При системном  сбое,  например  вызвавшем перезапуск,  могут
оставаться сигнальные файлы (см.  <a href=CI.htm>ci(1)</a>  ВРЕМЕННЫЕ  ФАЙЛЫ  И
ЛИНКИ),  которые  содержат  информацию  о том,  что в данное
время идет  работа  с  архивным  файлом,  что  не  даст  его
изменить.   Положение  легко  исправить,  удалив  сигнальные
файлы,  имена которых обычно или начинаются с  запятой,  или
заканчиваются на символ подчеркивания.
<p><b>СМ. ТАКЖЕ</b><br>
<a href=CI.htm>ci(1)</a>, <a href=CO.htm>co(1)</a>,  <a href=IDENT.htm>ident(1)</a>,  <a href=RCS.htm>rcs(1)</a>,  <a href=RCSDIFF.htm>rcsdiff(1)</a>,  <a href=RCSINTRO.htm>rcsintro(1)</a>,
<a href=RCSMERGE.htm>rcsmerge(1)</a>, <a href=RLOG.htm>rlog(1)</a>
<p align=justify><i>Walter F.   Tichy,   RCS--A   System  for  Version  Control,
Software--Practice & Experience 15, 7 (July 1985), 637-654.
<p align=justify>Copyright (C) Walter F. Tichy, Paul Eggert.</i>
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/footer0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table>
</body>
</html>
