<html>
<head>
<title>MAKE(1)</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/header0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="_pic_/logo.gif" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>

<h3 align=center>MAKE(1)</h3>
<p align=justify><b>НАЗВАНИЕ</b><br>
make - поддержка,  обновление  и  восстановление  групп
программ
<p><b>СИНТАКСИС</b>
<pre>
   make  [-f make-файл] [-p] [-i] [-k] [-s] [-r] [-n] [-b] [-e] [-u] [-t] [
	 [целевой_файл ...]
</pre>
<p align=justify><b>ОПИСАНИЕ</b><br>
Утилита make позволяет поддерживать, изменять и регенерировать группы программ. Ниже приведено краткое описание всех опций и некоторых специальных имен:
<dl>
<dt>-f make-файл <dd>
Задание имени файла с описаниями.
<p><dt>-p  <dd> Вывести все макроопределения, а также описания зависимостей и операций для создания целевых_файлов.
<p><dt>-i  <dd> Игнорировать коды ошибок, возвращаемых запускаемыми программами. Этот режим  устанавливается  также
при появлении в файле описаний специального  целевого имени .IGNORE.
<p><dt>-k <dd>  При ошибке прекращать выполнение команд, связанных
с текущей зависимостью,  но  продолжать  обработку
других зависимостей.
<p><dt>-s  <dd> Не выводить командные строки перед их выполнением.
Этот режим устанавливается также при  появлении  в
файле   описаний   специального   целевого   имени
.SILENT.
<p><dt>-r  <dd> Не использовать встроенные правила.
<p><dt>-n <dd>  Выводить команды, но не  выполнять  их.  Выводятся
даже команды, которые начинаются с @.
<p><dt>-b  <dd> Режим  для  совместимости  со   старыми   версиями
make-файлов.
<p><dt>-e <dd> В первую очередь используются  переменные  окружения, а не одноименные макросы make-файлов.
<p><dt>-u  <dd> Вызывает безусловное обновление.
<p><dt>-t <dd>  "Массаж" целевых_файлов: время их  создания  устанавливается  равным  текущему  времени;   команды,
предназначенные для получения  целевых_файлов,  не
выполняются.
<p><dt>-q  <dd> Запрос. Команда make возвращает нулевой или  ненулевой код завершения в зависимости от того,  нужно
ли обновлять целевые_файлы (0, если не нужно). Печать команд подавляется,  даже  если  присутствует
опция -n.
<p><dt>.DEFAULT <dd>
Если должен быть сделан файл, но нет ни явных  команд, ни соответствующих встроенных правил, то используются команды, ассоциированные со специальным
целевым именем .DEFAULT, если они существуют.
<p><dt>.PRECIOUS <dd>
Файлы, которые зависят от этого специального  имени, не удаляются, если работа  команды  make  была
прервана или прекращена.
<p><dt>.SILENT <dd>
Дает тот же эффект, что и опция -s.
<p><dt>.IGNORE <dd>
Дает тот же эффект, что и опция -i.
</dl>
<p align=justify>Make выполняет команды из make-файла для обновления одного или нескольких целевых_файлов, имена которых  указаны в команде. Если отсутствует опция  -f,  то  ищутся
файлы makefile, Makefile, и  файлы  системы  управления
исходными текстами (SCCS)  s.makefile  и  s.Makefile  в
указанном порядке. Если вместо make-файла указан -,  то
это означает стандартный ввод. В командной строке может
встретиться более чем одна пара -f make-файл.
<p align=justify>Команда make обновляет целевой_файл только в  том  случае, если файлы, от которых он зависит, оказываются новее в смысле времени модификации (кроме  случая,  когда
была использована опция -u с целью вызвать  безусловное
обновление). Все файлы, от которых зависит целевой_файл
добавляются рекурсивно к  списку  целевых  файлов.  Отсутствующие файлы считаются требующими обновления.
<p align=justify>Make-файл состоит из последовательности разделов, определяющих зависимости. Первая строка раздела -  непустой
список разделенных пробелами имен целевых файлов, затем
знак :, затем (возможно пустой) список необходимых файлов  или зависимостей. Текст, следующий за ; и все последующие строки, начинающиеся с табуляции, представляет
собой команды shell'а, которые необходимо выполнить для
обновления целевого файла. Первая  строка,  которая  не
начинается  с табуляции или #, открывает новое описание
зависимости или макроопределение. Команды shell'а могут
быть продолжены в следующей строке, если последним символом текущей строки  поставить  \.  Все,  что  выводит
make,  кроме  начальных  символов табуляции, передается
shell'у в исходном виде. Например,
<pre>
	echo a\
	b
</pre>
даст
<pre>
	ab
</pre>
как если бы команда выполнялась просто shell'ом.
<p align=justify>Символы # и перевод_строки обрамляют комментарии.
<p align=justify>В приведенном ниже make-файле определяется, что pgm зависит от двух файлов: a.o и b.o, и что они в свою  очередь зависят от соответствующих исходных файлов (a.c  и
b.c) и общего файла incl.h:
<pre>
     pgm: a.o b.o
        cc a.o b.o -o pgm
     a.o: incl.h a.c
        cc -c a.c
     b.o: incl.h b.c
        cc -c b.c
</pre>
<p align=justify>Командные  строки  выполняются  по  одной, каждая своим
собственным shell'ом. Чтобы указать, каким shell'ом выполнять команду, можно использовать переменную  окружения  SHELL.  Первые  один или два символа команды могут
быть следующими: -, @, -@, @-. Если присутствует @,  то
подавляется  вывод команды. При указании символа - make
игнорирует ошибки. Команда перед ее  выполнением  выводится, если только не указана опция -s, или в make-файле  отсутствует  вход .SILENT:, или в начале команды не
стоит знак @. Опция -n специфицирует вывод  команд  без
их  выполнения;  однако, если командная строка содержит
текст $(MAKE), то она всегда выполняется (см. MAKEFLAGS
в пункте Окружение). Если указана опция -t, то  изменяется  время последней модификации файлов без выполнения
каких-либо команд. К сожалению, при этом не  изменяются
даты  сохранения файлов в библиотеках (см. Библиотеки),
а меняется только время последней модификации библиотеки.
<p align=justify>Команды, возвращающие ненулевой код завершения,  обычно
прекращают выполнение make. Если же  указана  опция  -i
или в make-файле присутствует вход  .IGNORE:,  или  командная строка начинается со знака -, то ошибки игнорируются. Если указана опция -k, то прекращается обработка текущего раздела, но продолжаются действия,  которые
не зависят от целевого файла этого раздела. В конце выводится сообщение о первоначальных  целях,  которые  не
были достигнуты.
<p align=justify>Опция -b позволяет без ошибок выполнять make-файлы, написанные для старой версии make'а.  Отличие  состоит  в
том, что в новой версии все строки зависимостей  должны
содержать (возможно пустые или задаваемые по умолчанию)
команды, связанные с ними. В предыдущей  версии  считалось, что неспецифицированная команда является пустой.
<p align=justify>Сигналы прерывания и выхода вызывают уничтожение  целевого файла, если только он не зависит  от  специального
имени .PRECIOUS.
<p align=justify><b>Окружение </b><br>
Команда make читает окружение. Все переменные окружения
обрабатываются как макроопределения. Все они читаются и
обрабатываются до обработки make-файла и после обработки  встроенных  правил;  поэтому  макроопределения   из
make-файла перекрывают макроопределения  из  окружения.
Если задана опция -e, то переменные из окружения перекрывают макроопределения из make-файла. Суффиксы и  связанные с ними правила из make-файла перекрывают  описания суффиксов во встроенных правилах.
<p align=justify>Переменная окружения MAKEFLAGS обрабатывается  как  содержащая любую из допустимых опций  (кроме  -f  и  -p),
описанных для командной строки. Далее, если такой переменной в окружении нет, то make создает ее,  помещая  в
нее все указанные в командной строке опции, и  передает
ее  всем  запускаемым  им  командам.   Таким   образом,
MAKEFLAGS всегда содержит текущие  опции.  Эта  возможность очень полезна, если возникла необходимость  отладить make-файл для проекта,  состоящего  из  подсистем,
для которых есть свои собственные make-файлы.  Как  уже
отмечалось выше (при использовании  опции  -n)  команда
$(MAKE) выполняется всегда, следовательно, можно выполнить make -n рекурсивно по всему проекту, чтобы посмотреть, что было бы выполнено при  отсутствии  опции  -n.
Это возможно, так как флаг -n помещается в MAKEFLAGS  и
передается при вызове $(MAKE).  Тем  самым  перед  нами
один из способов проверить все make-файлы  проекта,  не
выполняя их на самом деле.
<p align=justify><b>Включение файлов </b><br>
Если в make-файле строка начинается с цепочки  символов
include и после нее пробел или  табуляция,  то  остаток
строки после подстановки макросов считается именем файла и этот файл будет прочтен и включен в make-файл.
<p align=justify><b>Макросы </b><br>
Разделы, имеющие вид
<pre>
	цепочка1=цепочка2
</pre>
<p align=justify>являются макроопределениями. В цепочку2 входят все символы до начала комментария или до неэкранированного перевода строки. Последующие вхождения конструкции  $(цепочка1[:подцеп1=[подцеп2]]) заменяются  цепочкой2.  При
этом, если в цепочке2 встречаются  подцепочки  подцеп1,
за которыми следует пробел или табуляция, и подцеп1 начинается с точки, они заменяются на подцепочку подцеп2.
Если имя макроса состоит из одного символа и нет  подстановок, то круглые скобки можно опускать.  Пример  использования подстановок см. в пункте Библиотеки.
<p align=justify><b>Внутренние макросы </b><br>
Мake поддерживает пять  внутренних  макросов,  полезных
при написании правил построения целевых файлов:
<dl>
<dt>$*  <dd> Этот макрос является именем файла  без  расширения
из текущей  зависимости;  вычисляется  только  для
подразумеваемых правил (см. Суффиксы).
<p><dt>$@  <dd> Этот макрос заменяется на полное имя целевого файла; вычисляется только для явно  заданных  зависимостей.
<p><dt>$&lt;  <dd> Вычисляется  только для подразумеваемых правил или
для правила .DEFAULT. Этот  макрос  заменяется  на
имя  файла, от которого по умолчанию зависит целевой файл. Так, в правиле .c.o макрос $&lt; будет  заменен  на  имя  файла  с расширением .c. Например,
правило для изготовления оптимизированного об ектного файла из файла с расширением  .c  может  быть
таким:
<pre>
	.c.o:
               cc -c -O $*.c
</pre>
или
<pre>
	 .c.o:
	        cc -c -O $&lt;
</pre>
<p><dt>$?  <dd> Макрос $?  можно  использовать  в  явных  правилах
make-файла. Этот макрос заменяется на список  файлов-источников, которые изменялись позднее целевого файла.
<p><dt>$%  <dd> Этот  макрос применяется только тогда, когда целевой файл указан в виде библ(файл.o), что означает,
что он находится в библиотеке библ. В этом  случае
$@ заменяется на библ (имя архива), а $% заменяется на настоящее имя файла, файл.o.
</dl>
<p align=justify>Четыре из этих макросов имеют альтернативную форму. Если к любому из этих макросов добавлено F, то он заменяется на соответствующее макросу имя файла без имени каталога; если же добавлено D, то  макрос  заменяется  на
остальную часть значения  первоначального  макроса  без
последнего символа /, то есть  на  имя  каталога.  Так,
$(@D) соответствует каталогу из  $@.  Если  каталог  не
указан, то генерируется  текущий  каталог  (.).  Только
макрос $? не имеет альтернативной формы.
<p align=justify><b>Суффиксы </b><br>
Некоторые файлы (например файлы, имена которых  оканчиваются на .o) имеют подразумеваемые  источники,  например, файлы, имена которых оканчиваются на .c, .s и т.д.
Если для этих файлов не указаны команды их  модификации
в make-файле, но существуют подразумеваемые  источники,
то они (источники) компилируются для получения  требуемых файлов. В таких случаях make применяет подразумеваемые (встроенные) правила вывода, позволяющие  получить
одни файлы из других путем исследования суффиксов и определения соответствующих команд. Подразумеваемые  правила вывода таковы:
<pre>
	.c .c~ .f .f~ .sh .sh~
	.c.o .c.a .c~.o .c~.c .c~.a
	.f.o .f.a .f~.o .f~.f .f~.a
	.h~.h .s.o .s~.o .s~.s .s~.a .sh~.sh
	.l.o .l.c .l~.o .l~.l .l~.c
	.y.o .y.c .y~.o .y~.y .y~.c
</pre>
<p align=justify>Встроенные правила можно изменять. Чтобы вывести  их  в
виде, пригодном для  изменения,  нужно  воспользоваться
командой
<pre>
	make -fp - 2>/dev/null </dev/null >rules
</pre>
<p align=justify>Символ ~ (тильда)  используется  в  этих  правилах  для
SCCS-файлов  [см.  <a href=SCCSFILE.htm>sccsfile(4)</a>].  Так,  правило   .c~.o
трансформирует SCCS C-файл в об ектный файл .o. Так как
s. в SCCS-файлах является префиксом, то это несовместимо с принятым в make способом  определения  правила  по
суффиксу. Использование тильды вызывает  замену  ссылки
на файл ссылкой на SCCS-файл.
<p align=justify>Правила с одним суффиксом (например .c:) описывают, как
получить файл x из x.c (то есть второй суффикс пустой).
Это полезно для построения целевого файла только из одного  исходного   файла   (например,   для   построения
shell-процедуры или простой C-программы).
<p align=justify>Дополнительные суффиксы даются как список  зависимостей
для специального имени .SUFFIXES. При этом важен  порядок: первое возможное имя, для  которого  существуют  и
файл и правило,  используется  как  имя  источника.  По
умолчанию этот список выглядит так:
<pre>
	.SUFFIXES: .o .c .c~ .y .y~ .l .l~ .s .s~ .h~ .h .f .f~
	.sh~ .sh
</pre>
<p align=justify>Команда, указанная выше для  вывода  списка  встроенных
правил, показывает также встроенный  список  суффиксов.
Многократные указания .SUFFIXES: об единяют списки суффиксов; указание .SUFFIXES: с  пустым  списком  очищает
список суффиксов.
<p align=justify><b>Подразумеваемые правила </b><br>
Пример с целевым файлом pgm можно записать короче:
<pre>
     pgm: a.o b.o
        cc a.o b.o -o pgm
     a.o b.o: incl.h
</pre>
<p align=justify>Это возможно, так как make использует набор  внутренних
правил. Пользователь может добавить правила просто  поместив их в make-файл.
<p align=justify>Некоторые макросы используются в подразумеваемых правилах, чтобы разрешить включение опций в какую-нибудь  из
получающихся команд. Например, CFLAGS, LFLAFS, и YFLAGS
используется  для  задания  опций  компиляторам  <a href=CC.htm>cc(1)</a>,
<a href=LEX.htm>lex(1)</a>, и <a href=YACC.htm>yacc(1)</a> соответственно. Для определения  значений по умолчанию этих макросов можно снова порекомендовать описанный ранее метод для  просмотра  встроенных
правил.
<p align=justify>Подразумеваемые правила можно изменять. Правило  создания файла с суффиксом .o из файла с суффиксом .c указывается как раздел с именем .c.o: и пустым списком зависимостей. Команды shell'а, связанные с этим именем, определяют  способ  получения файла .o из файла .c. Любое
имя, в которое не входит символ /, и которое начинается
с точки, распознается как имя правила, а не  настоящего
целевого файла.
<p align=justify><b>Библиотеки </b><br>
Если целевой файл или имя из списка зависимостей содержит  скобки,  то  оно  рассматривается как имя архивной
библиотеки, а цепочка символов в скобках - как имя элемента    библиотеки.    Так,    и    библ(файл.o),    и
$(БИБЛ)(файл.o)   обозначают   библиотеку,   содержащую
файл.o (предполагается, что макрос БИБЛ  был  предварительно  определен).  Выражение $(БИБЛ)(файл1.o файл2.o)
недопустимо. Правила обработки библиотечных файлов имеют вид .XX.a, где XX - суффикс, по которому будет получен элемент библиотеки. К сожалению, в текущей реализации требуется, чтобы XX отличался от суффикса  элемента
библиотеки.  Например, нельзя, чтобы библ(файл.o) зависел от файл.o явно. Наиболее общее использование интерфейса работы с библиотеками следующее  (предполагается,
что исходными являются файлы на языке C):
<pre>
     lib: lib(file1.o) lib(file2.o) lib(file3.o)
        @echo lib is now up-to-date
     .c.a:
        $(CC) -c $(CFLAGS) $<
        $(AR) $(ARFLAGS) $@ $*.o
        rm -f $*.o
</pre>
<p align=justify>Фактически, правило .c.a, приведенное выше, встроено  в
make. Более интересный, но  более  ограниченный  пример
конструкции, поддерживающей работу с библиотеками:
<pre>
     lib: lib(file1.o) lib(file2.o) lib(file3.o)
        $(CC) -c $(CFLAGS) $(?:.o=.c)
        $(AR) $(ARFLAGS) lib $?
        rm $?  @echo lib is now up-to-date
     .c.a:;
</pre>
<p align=justify>Здесь  используется режим подстановки расширений макросов. Список $? определен как множество  имен  об ектных
файлов  (в  библиотеке  lib), чьи исходные C-файлы были
изменены. Подстановка заменяет .o на .c. (К  сожалению,
нельзя  еще  трансформировать  в .c~; однако, это может
стать возможно в будущем). Заметим также, что  запрещается  правило  .c.a:,  создающее  каждый об ектный файл
один за другим. Эта  конструкция  значительно  ускоряет
обновление  библиотек, но становится весьма громоздкой,
если библиотека содержит как программы на C, так  и  на
ассемблере.
<p><b>ФАЙЛЫ</b>
<pre>
	[Mm]akefile и s.[Mm]akefile
	/bin/sh
</pre>
<p><b>СМ. ТАКЖЕ</b><br>
<a href=SCCSFILE.htm>sccsfile(4)</a>.<br>
<a href=CC.htm>cc(1)</a>, <a href=LEX.htm>lex(1)</a>,  <a href=YACC.htm>yacc(1)</a>,  <a href=CD.htm>cd(1)</a>,  <a href=SH.htm>sh(1)</a>  в  Справочнике
пользователя.
<p align=justify><b>СЮРПРИЗЫ</b><br>
Некоторые команды возвращают ненулевой код завершения и
после успешной работы; для преодоления  этой  трудности
используйте опцию -i.
<p align=justify>Не допускаются файлы с символами =:@ в имени.
<p align=justify>Команды, непосредственно выполняемые shell'ом, например
<a href=CD.htm>cd(1)</a>, нельзя продолжать на новую строку.
<p align=justify>Если после слова include находится больше одного пробела, то make не сможет прочитать включаемый файл.
<p align=justify>Макрос $(a:.o=.c~)  не  работает.  Именованные  фильтры
поддерживаются плохо.
<p align=justify>Выражение $(LIB)(file1.o file2.o) синтаксически  неверно. Нельзя построить lib(file.o) из file.o.
<p align=justify>В текущей версии не распознается опция -u.
<p align=justify>В текущей версии целевой файл не удаляется, если  произошла ошибка. Специальное имя .PRECIOUS не работает.
<p align=justify>Специальное имя .DEFAULT не работает.
<p align=justify>Макросы $(@D), $(*D), $(&lt;D) и $(%D) не вполне правильно
работают с подстановкой: подстановка производится не  в
имя каталога, а в имя файла.
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/footer0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table>
</body>
</html>
