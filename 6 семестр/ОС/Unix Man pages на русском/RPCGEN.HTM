программы, а по команде  i
этот сигнал игнорируется.
<p><dt>переменная$m счетчик
<br>адрес:m счетчик <dd>
Аналогично s, но выполняется до тех пор,  пока  по
указанному адресу не будет занесено  новое  значение. Переменная должна быть  доступна  из  текущей
процедуры. Если счетчик не указан, его можно  считать бесконечно большим. Так  как  данная  команда
выполняется программно, она работает  крайне  медленно.
<p><dt>уровень v <dd>
Задать полноту выводимой информации при выполнении
команд s, S, m. Если уровень опущен, то  выводится
только название подпрограммы  и  исходного  файла.
Если уровень 1 или больше, то при выполнении выводится также исходная строка. Если  уровень  2  или
больше, то также выводятся все команды ассемблера,
соответствующие данной строке.
<p><dt>k <dd>   Терминировать  процесс,  выполняющий  отлаживаемую
программу.
<p><dt>процедура(арг1, арг2, ... )
<br>процедура(арг1, арг2, ... )/m <dd>
Выполнить указанную процедуру с заданными аргументами. Аргументы могут быть целыми числами,  символами,  цепочками  символов или именами переменных,
доступных из текущей процедуры. Во втором варианте
результат выполнения процедуры выводится в формате
m (по умолчанию d). Выполнить отдельную  процедуру
можно, лишь если редактирование связей осуществлялось командой cc -g.
<p><dt>номер_строки b команды_отладчика <dd>
Установить точку прерывания на  указанную  строку.
Если указано имя процедуры без номера_строки (например, proc:), точка прерывания устанавливается на
первую строку процедуры, даже если она  компилировалась без опции -g. Если номер_строки не  указан,
то точка  прерывания  устанавливается  на  текущую
строку. Если команды_отладчика не указаны, то  выполнение приостанавливается перед точкой  прерывания и управление возвращается sdb. Иначе при  достижении точки прерывания выполняются указанные команды_отладчика и работа  программы  продолжается.
Если команд несколько, они  разделяются  точкой  с
запятой. Если в качестве команды  используется  k,
то управление передается sdb.
<p><dt>B   <dd> Вывести список точек прерывания.
<p><dt>номер_строки d <dd>
Снять точку прерывания с заданной строки. Если номер_строки не указан, то запрашивается подтверждение на удаление каждой точки прерывания:  выдается
ее местоположение и читается ответ (со стандартного ввода). Если ответ начинается с  y  или  d,  то
точка прерывания снимается.
<p><dt>D  <dd>  Удалить все точки прерывания.
<p><dt>l  <dd>  Вывести последнюю выполненную строку.
<p><dt>номер_строки a <dd>
Оповещение. Если номер_строки имеет  вид  процедура:номер, то выполняется команда номер_строки b l.
Если номер_строки имеет вид процедура:, то  выполняется команда процедура: b T.
</dl>
<p align=justify><b>Прочие команды </b><br>
<dl>
<dt>!команда <dd>
Команда интерпретируется shell'ом [см. <a href=SH.htm>sh(1)</a>].
<p><dt>перевод_строки <dd>
Если предыдущая команда выводила  строку  исходной
программы, то после нажатия клавиши "перевод строки"  будет  выведена  следующая  строка  исходного
текста, которая и станет текущей. Если  предыдущая
команда выводила содержимое ячейки памяти, то  выводится содержимое следующей ячейки.
<p><dt>CTRL+D <dd>
"Прокрутить". Вывести следующие 10 строк исходного
текста, команд или данных в зависимости  от  того,
что выводилось в последний раз.
<p><dt>&lt;имя_файла <dd>
Читать команды из указанного файла; по  достижении
его конца читать команды  со  стандартного  ввода.
Эта команда не может быть вложенной.
<p><dt>M   <dd> Вывести тройки, управляющие отображениями адресов.
<p><dt>М [?/] [*] b e f <dd>
Изменить тройку, управляющую отображением адресов.
Аргументы ? и / указавают на отображения, ассоциированные с объектным_файлом и образом_памяти соответственно. Если не указана *, то изменяется  первая тройка (b1, e1, f1), иначе - вторая. Если  задано меньше трех значений, то оставшиеся  элементы
тройки остаются неизменными.
<p><dt>"строка <dd>
Вывести указанную строку. Разрешается использовать
управляющие последовательности  языка  C  \символ,
где символ не есть цифра.
<p><dt>q <dd>   Выйти из отладчика.
</dl>
<p align=justify><b>Команды отладки отладчика </b><br>
<dl>
<dt>V <dd>   Вывести версию отладчика.
<p><dt>Q  <dd>  Вывести список отлаживаемых файлов и процедур.
<p><dt>Y <dd>   Переключить режим выдачи внутренней отладочной информации.
</dl>
<p align=justify><p><b>ФАЙЛЫ</b>
<pre>
	a.out
	core
</pre>
<p><b>СМ. ТАКЖЕ</b><br>
<a href=CC.htm>cc(1)</a>, <a href=F77.htm>f77(1)</a>, <a href=SH.htm>sh(1)</a>.<br>
a.out(4), <a href=CORE.htm>core(4)</a>, <a href=SYMS.htm>syms(4)</a> в Справочнике программиста.
<p align=justify><b>ПРЕДОСТЕРЕЖЕНИЯ</b><br>
При выводе значения внешней переменной, для которой отсутствует отладочная информация, перед ее значением выводится предупреждение. Ее типом по умолчанию считается
int.
<p align=justify>Данные, хранящиеся в секции команд, недоступны из функций.
<p align=justify>Если функция была оптимизирована, то информация о номерах строк может  не  соответствовать  действительности.
Более того, часть информации может быть потеряна.
<p align=justify><b>СЮРПРИЗЫ</b><br>
Если процедура вызвана, когда программа не остановилась
на точке прерывания (например, при отладке образа памяти), то перед началом выполнения процедуры все переменные  инициализируются. Это делает невозможным использование процедур, которые  осуществляют  форматный  вывод
данных из образа памяти.
<p align=justify>Отладчик  sdb  плохо  приспособлен  для  отладки  Фортран-программ. Трудно получить доступ к элементам  общих
блоков и формальным  аргументам,  элементы  многомерных
массивов нумеруются по строкам, а не по столбцам. Кроме
того, sdb несовместим с компилятором <a href=SVS.htm>svs(1)</a>. Рекомендуем пользоваться отладчиком КРОТ.
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/footer0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottomипа идентификатор_объекта[размер]
</pre>
("размер" может быть целой или символьной константой)
<br>Пример:
<pre>
	opaque c[10];
</pre>
    По сравнению с Си,  определения в языке RPCL имеют где сокращенную, где расширенную форму. Ограничения касаются невозможности
описания многомерных  массивов  или вложенных указателей (хотя их
можно определить с помощью оператора typedef). Два расширения:
<p align=justify><li> Данные типа opaque описываются как вектор:
<pre>
	opaque идентификатор_объекта[размер]
</pre>
В соответствии  с протоколом будет создан объект указанного
размера (в байтах).  Обратите внимание на то,  что размер в
байтах не равен размеру в символах, поскольку символы в XDR
размещаются в 32 битах каждый. Определения типа opaque компилируются в  выходном файле заголовков в описания массивов
символов.
 
<li> Строки описываются особо, по типу векторного определения:
<pre>
	string идентификатор_объекта[максимальный_размер]
</pre>
Если максимальный размер не указан, длина строки практически не ограничивается.  Строковые определения  преобразуются
в:
<pre>
	char *идентификатор_объекта
</pre>
</ul>
 
<b>    Описания типов</b><br>
    Rpcgen используется для генерации процедуры XDR  и/или  файла
заголовков, описывающего типы данных из входного файла.  Для каждого описываемого zetype утилита rpcgen  создает  соответствующую
процедуру XDR,   именуемую xdr_zetype и обязательную для создания
RPC-программ.
<p align=justify>    Существуют шесть способов описания типа:
<pre>
    описание_типа:
	typedef
	перечислимый_тип-def
	структура-def
	массив_переменной_длины-def
	размеченное_объединение-def
	программа-def
</pre>
<p align=justify>    Первые три  очень похожи на своих тезок в Си.  Вместе с тем в
Си отсутствует формальный механизм описания  массивов  переменной
длины, а  XDR-объединения совершенно не похожи на соответствующие
объекты в Си.
<p align=justify>    Вложенность описаний  типов  в XDR не допускается.  Например,
следующая запись для rpcgen будет непонятна:
<pre>
	    struct dontdoit {
		 struct ididit {
		  int oops;
		 } sorry;
		 enum ididitagain { OOPS, WHOOPS } iapologize;
	    };
</pre>
<p align=justify>    Оператор typedef в XDR выглядит следующим образом:
typedef:
<pre>
	    typedef имя_типа идентификатор_объекта ;
</pre>
    "Идентификатор объекта"  является  именем  нового типа,  в то
время как "имя_типа" относится к исходному типу. Например:
<pre>
	    typedef longa;
</pre>
<p align=justify>     Синтаксис описания перечислимого типа:
<pre>
перечислимый_тип-def:
	    enum идентификатор_типа {
		   список_типов
	    };
список_типов:
	    символьный_идентификатор [=присваивание]
	    символьный_идентификатор [=присваивание], список_типов
	    (в правой части оператора, после знака равенства может распо-
	    лагаться целая или символьная константа)
</pre>
    Если явного присваивания нет, неявно будет присвоено значение
предыдущего элемента перечисления,  увеличенное на 1. Первый элемент по умолчанию имеет нулевое значение.
 
    Структуры:
<pre>
структура-def:
	    struct идентификатор_структуры {
		 список_описаний
	    };
список_описаний:
	    описание;
	    описание; список_описаний
</pre>
 
    Массивы переменной длины:
<pre>
массив_переменной_длины-def:
	    array идентификатор_массива {
		 unsigned идентификатор_длины ;
		 векторное_определение ;
	    };
</pre>
 
    Описание массива переменной длины похоже на описание структуры. Пример:
<pre>
	    array mp_int {
		 unsigned len;
		 short val[MAX_MP_LENGTH];
	    };
</pre>
    Эта запись преобразуется компилятором в:
<pre>
	    struct mp_int {
		 unsigned len;
		 short *val;
	    };
	    typedef struct mp_int mp_int;
</pre>
 
    Размеченное объединение:
<pre>
размеченное_объединение-def:
	    union идентификатор_объединения switch (описание_дискриминанта) {
		список_случаев
		[default: описание;]
	    };
список_случаев:
	    case идентификатор_случая : описание;
	    case идентификатор_случая : описание; список_случаев
описание_дискриминанта:
	    описание
</pre>
<p align=justify>    Описание объединения похоже на пересечение  Си-объединения  с
Си-переключателем. Пример:
<pre>
	    union net_object switch (net_kind kind) {
	    case MACHINE:
		 struct sockaddr_in sin;
	    case USER:
		 int uid;
		    default:
		 string whatisit;
	    };
</pre>
    Эта запись преобразуется компилятором в:
<pre>
	    struct net_object {
		 net_kind kind;
		 union {
		  struct sockaddr_in sin;
		  int uid;
		  char *whatisit;
		 } net_object;
	    };
	    typedef struct net_object net_object;
</pre>
<p align=justify>    Обратите внимание на то,  что имя объединяющей  компоненты  в
выходной структуре совпадает с именем самого типа.
 
    Описания программ:
<pre>
программа-def:
	    program идентификатор_программы {
		  список_версий
		    }=номер_программы;
список_версий:
	    версия
	    версия список_версий
версия:
	    version идентификатор_версии {
		  список_процедур
		    }=номер_версии;
список_процедур:
	    описание_процедуры
	    описание_процедуры список_процедур
описание_процедуры:
	    имя_типа идентификатор_процедуры(имя_типа)=номер_процедуры;
</pre>
<p align=justify>    Описания программ не похожи ни на что из ранее виденного  вами, поэтому нам ничего больше не остается,  как прибегнуть к примеру. Предположим, что нам нужно создать механизм (серверный) получения или установки даты.  Его описание может выглядеть следующим образом:
<pre>
	    program DATE_PROG {
		  version DATE_VERS {
		  date DATE_GET(timezone) = 1;
		  void DATE_SET(date) = 2;  /* время по Гринвичу */
		  } = 1;
	    } = 100;
</pre>
 
    В файле заголовков эта запись будет иметь следующий вид:
<pre>
	    #define DATE_PROG 100
	    #define DATE_VERS 1
	    #define DATE_GET 1
	    #define DATE_SET 2
</pre>
<p align=justify>    Если вы используете rpcgen для компиляции серверных процедур,
вам необходимо ознакомиться с некоторыми важными моментами.  Сервер взаимодействует  с  вашими   локальными   процедурами   через
Си-функцию, имя  которой совпадает с именем в описании программы,
но записывается строчными буквами и оканчивается номером  версии.
<p align=justify>Рассмотрим локальную процедуру реализации DATE_GET:
<pre>
	    date *  /* всегда возвращает указатель на результаты */
	    date_get_l(tz)
		 timezone *tz; /* всегда получает указатель на аргументы */
		    {
		 static date d;  /* должна быть статической! */
		 /*
		  * получение даты
		  * и сохранение ее в d
		  */
		 return(&d);
	    }
</pre>
<p align=justify>    Имя процедуры совпадает с именем,  объявленным в #define,  но
записывается строчными буквами и оканчивается номером версии. XDR
рекурсивно освобождает  аргумент  после  получения результатов из
локальной процедуры,  поэтому всю необходимую вам  информацию  из
аргумента следует скопировать между обращениями.  При этом XDR не
манипулирует вашими результатами.  Вам следует позаботиться об их
сохранении самим.
 
<b>    Вывод правил компиляции заголовков</b><br>
    Правила преобразования суффиксов в  <a href=MAKE.htm>make(1)</a>   при  компиляции
процедур XDR и заголовков (по условию файлы протоколов RPCL имеют
расширение .x):
<pre>
	    .SUFFIXES:.x
	    .x.c:
		 rpcgen -c $&lt; -o $@
	    .x.h:
		 rpcgen -h $&lt; -o $@
</pre>
    Пример:
 
    Рассмотрим программу example,  в которой  описываются  данные
трех типов:
<pre>
	    const NFS_PORT       = 2059;
	    enum nfsstat {
		 NFS_OK=0
		    };
		    struct gnumbers {
		 long g_assets;
		 long g_liabilities;
	    };
</pre>
    Утилита rpcgen,  вызванная без аргументов, создает файл заголовков example.h и файл XDR с именем example_xdr.c.
<pre>
	example.h
	    #define NFS_PORT 2059
	    enum nfsstat {
	 NFS_OK = 0,
	    };
	    typedef enum nfsstat nfsstat;
	    bool_t xdr_nfsstat();
	    struct gnumbers {
	 long g_assets;
	 long g_liabilities;
	    };
	    typedef struct gnumbers gnumbers;
	    bool_t xdr_gnumbers(); 
	 
	example_xdr.c
	    #include &lt;rpc/rpc.h>
	    #include "infile.h" 
	  
	    bool_t
	    xdr_nfsstat (xdrs, objp)
	 XDR *xdrs;
	 nfsstat *objp;
	    {
	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
	   return (FALSE);
	 }
	 return (TRUE);
	    } 
	  
	    bool_t
	    xdr_numbers (xdrs, objp)
	 XDR *xdrs;
	 gnumbers *objp;
	    {
	 if (!xdr_long(xdrs, &objp->g_assets)) {
	   return (FALSE);
	 }
	 if (!xdr_long(xdrs, &objp->g_liabilities)) {
	   return (FALSE);
	 }
	 return (TRUE);
	    }
</pre>
<p><b>СМ. ТАКЖЕ</b><br>
 "Руководство программиста SCO NFS"
<p align=justify><b>ЗАМЕЧАНИЯ</b><br>
     В программных определениях могут встретиться совпадающие имена, при этом сфера действия имен четко не разграничивается. Избежать подобных    ситуаций    поможет   использование   уникальных
идентификаторов для программ, версий, процедур и типов.
<p align=justify>    Вложенность также  не поддерживается.  Чтобы сымитировать эффект вложенности,  объявление структур можно производить на верхнем уровне с тем,  чтобы использовать их имена внутри других процедур.
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/footer0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table>
</body>
</html>
