<html>
<head>
<title>CURSES(3X)</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/header0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="_pic_/logo.gif" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>

<h3 align=center>CURSES(3X)</h3>
<p align=justify><b>НАЗВАНИЕ</b><br>
curses - пакет подпрограмм управления выводом на терминал
<p align=justify><b>ПРИМЕЧАНИЯ </b><br>
Описание пакета curses устроено не совсем обычно.
<p align=justify>В разделе СИНТАКСИС  дается  информация  о  компиляции,
сводка  имен  аргументов  процедур пакета и их типов, а
также алфавитный указатель процедур пакета и  их  аргументов.
<p align=justify>В разделе ОПИСАНИЕ рассказывается о том, как нужно  использовать пакет curses.
<p align=justify>В  разделе  ПРОЦЕДУРЫ приводится описание всех процедур
пакета curses, процедуры при этом сгруппированы по следующим темам:
<ul>
<li> управление всем экраном
<li> управление окнами
<li> вывод
<li> ввод
<li> установка режимов вывода
<li> установка режимов ввода
<li> запросы к оборудованию
<li> программируемые метки
<li> процедуры нижнего уровня
<li> процедуры уровня terminfo
<li> эмуляция termcap
<li> дополнительные процедуры
<li> использование curscr
</ul>
<p align=justify>Затем идут разделы  <a href=#atr>АТРИБУТЫ</a>,  <a href=#func>ФУНКЦИОНАЛЯНЫЕ  КЛАВИШИ</a>, <a href=#gr>ПСЕВДОГРАФИКА</a>.
<p><b>СИНТАКСИС</b>
<pre>
	cc  [опция ...] файл ... -lcurses [библиотека ...]
	
	#include &lt;curses.h> (автоматически включает  &lt;stdio.h>,
	                    &lt;termio.h> и &lt;unctrl.h>)
</pre>
<p align=justify>Ниже  описаны аргументы процедур пакета curses, некоторые глобальные переменные, а затем сами процедуры.  Все
процедуры  пакета, если не оговорено противное, возвращают значения ERR или OK типа int. В случае ошибки  результат  процедур, возвращающих значения-указатели, равен NULL. (Константы ERR, OK  и  NULL  определяются  во
включаемом файле &lt;curses.h>.)
<pre>
	bool bf
	char **area, *boolnames [ ], *boolcodes [ ], *boolfnames [ ], *bp
	char *cap, *capname, *codename [2], erasechar, *filename, *fmt
	char *keyname, killchar, *label, *longname
	char *name, *numnames [ ], *numcodes [ ], *numfnames [ ]
	char *slk_label, *str, *strnames [ ], *strcodes [ ], strfnames [ ]
	char *term, *tgetstr, *tigetstr, *tgoto, *tparm, *type
	chtype attrs, ch, horch, vertch
	FILE *infd, *outfd
	int begin_x, begin_y, begline, bot, c, col, count
	int dmaxcol, dmaxrow, dmincol, dminrow, *erret, fildes
	int (*init ( )), labfmt, labnum, line
	int ms, ncols, new, newcol, newrow, nlines, numlines
	int oldcol, oldrow, overlay
	int p1, p2, p3, p4, p5, p6, p7, p8, p9
	int pmincol, pminrow, (*putc ( )), row
	int smaxcol, smaxrow, smincol, sminrow, startrow
	int tenths, top, visibility, x, y
	SCREEN *new, *newterm, *set_term
	TERMINAL *cur_term, *nterm, *oterm
	va_list varglist
	WINDOW *curscr, *dstwin, *initscr, *newpad, *newwin, *orig
	WINDOW *pad, *srcwin, *stdscr, *subpad, *subwin, *win
	
	addch (ch)
	addstr (str)
	attroff (attrs)
	attron (attrs)
	attrset (attrs)
	baudrate ( )
	beep ( )
	box (win, vertch, horch)
	cbreak ( )
	clear ( )
	clearok (win, bf)
	clrtobot ( )
	clrtoeol ( )
	copywin (srcwin, dstwin, sminrow, smincol, dminrow, dmincol,
		dmaxrow, dmaxcol, overlay)
	curs_set (visibility)
	def_prg_mode ( )
	def_shell_mode ( )
	def_curterm (oterm)
	delay_output (ms)
	delch ( )
	deleteln ( )
	delwin (win)
	doupdate ( )
	draino (ms)
	echo ( )
	echochar (ch)
	endwin ( )
	erase ( )
	erasechar ( )
	filter ( )
	flash ( )
	flushinp ( )
	garbagedlines (win, begline, numlines)
	getbegyx (win, y, x)
	getch ( )
	getmaxyx (win, y, x)
	getstr (str)
	getsyx (y, x)
	getyx (win, y, x)
	halfdelay (tenths)
	has_ic ( )
	has_il ( )
	idlok (win, bf)
	inch ( )
	initscr ( )
	insch (ch)
	insertln ( )
	intrflush (win, bf)
	isendwin ( )
	keyname (c)
	keypad (win, bf)
	killchar ( )
	leaveok (win, bf)
	longname ( )
	meta (win, bf)
	move (y, x)
	mvaddch (y, x, ch)
	mvaddstr (y, x, str)
	mvcur (oldrow, oldcol, newrow, newcol)
	mvdelch (y, x)
	mvgetch (y, x)
	mvgetstr (y, x, str)
	mvinch (y, x)
	mvinsch (y, x, ch)
	mvprintw (y, x, fmt[, arg...])
	mvscanw (y, x, fmt[, arg...])
	mvwaddch (win, y, x, ch)
	mvwaddstr (win, y, x, str)
	mvwdelch (win, y, x)
	mvwgetch (win, y, x)
	mvwgetstr (win, y, x, str)
	mvwin (win, y, x)
	mvwinch (win, y, x)
	mvwinsch (win, y, x, ch)
	mvwprintw (win, y, x, fmt[, arg...])
	mvwscanw (win, y, x, fmt[, arg...])
	napms (ms)
	newpad (nlines, ncols)
	newterm (type, outfd, infd)
	newwin (nlines, ncols, begin_y, begin_x)
	nl ( )
	nocbreak ( )
	nodelay (win, bf)
	noecho ( )
	nonl ( )
	noraw ( )
	notimeout (win, bf)
	overlay (srcwin, dstwin)
	overwrite (srcwin, dstwin)
	pechochar (pad, ch)
	pnoutrefresh (pad, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol)
	prefresh (pad, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol)
	printw (fmt[, arg...])
	putp (str)
	raw ( )
	refresh ( )
	reset_prog_mode ( )
	reset_shell_mode ( )
	resetty ( )
	restartterm (term, fildes, erret)
	ripoffline (line, init)
	savetty ( )
	scanw (fmt[, arg...])
	scr_dump (filename)
	scr_init (filename)
	scr_restore (filename)
	scroll (win)
	scrollok (win, bf)
	set_curterm (nterm)
	set_term (new)
	setscrreg (top, bot)
	setsyx (y, x)
	setupterm (term, fildes, erret)
	slk_clear ( )
	slk_init (labfmt)
	slk_label (labnum)
	slk_noutrefresh ( )
	slk_refresh ( )
	slk_restore ( )
	slk_set (labnum, label, fmt)
	slk_touch ( )
	standend ( )
	standout ( )
	subpad (orig, nlines, ncols, begin_y, begin_x)
	subwin (orig, nlines, ncols, begin_y, begin_x)
	tgetent (bp, name)
	tgetflag (codename)
	tgetnum (codename)
	tgetstr (codename, area)
	tgoto (cap, col, row)
	tigetflag (capname)
	tigetnum (capname)
	tigetstr (capname)
	touchline (win, start, count)
	touchwin (win)
	tparm (str, p1, p2, p3, p4, p5, p6, p7, p8, p9)
	tputs (str, count, putc)
	traceoff ( )
	traceon ( )
	typeahead (fildes)
	unctrl (c)
	ungetch (c)
	vidattr (attrs)
	vidputs (attrs, putc)
	vwprintw (win, fmt, varglist)
	vwscanw (win, fmt, varglist)
	waddch (win, ch)
	waddstr (win, str)
	wattroff (win, attrs)
	wattron (win, attrs)
	wattrset (win, attrs)
	wclear (win)
	wclrtobot (win)
	wclrtoeol (win)
	wdelch (win)
	wdeleteln (win)
	wechochar (win, ch)
	werase (win)
	wgetch (win)
	wgetstr (win, str)
	winch (win)
	winsch (win, ch)
	winsertln (win)
	wmove (win, y, x)
	wnoutrefresh (win)
	wprintw (win, fmt[, arg...])
	wrefresh (win)
	wscanw (win, fmt[, arg...])
	wsetcrreg (win, top, bot)
	wstandend (win)
	wstandout (win)
</pre>
<p align=justify><b>ОПИСАНИЕ</b><br>
Пакет curses дает пользователю независимый от терминала
метод вывода на экран с разумной оптимизацией.
<p align=justify>Инициализирующие процедуры initscr или newterm  необходимо обязательно вызвать самыми первыми (три исключения
из  этого  правила  будут описаны ниже). При завершении
работы нужно вызвать процедуру endwin.  Чтобы  вводимые
символы не изображались на экране (большинству интерактивных экранных программ нужен именно такой режим) после вызова процедуры initscr необходимо вызвать
<pre>
	cbreak (); noecho ()
</pre>
Большинство программ дополнительно вызывают
<pre>
	nonl ();
	intrflush (stdscr, FALSE); keypad (stdscr, TRUE)
</pre>
<p align=justify>Перед запуском программы, использующей пакет curses, на
терминале  необходимо  установить  позиции табуляции и,
если требуется, вывести инициализирующие последовательности. Это обычно делается командой tput  init,  причем
переменная  окружения  TERM  должна быть предварительно
определена и помещена в окружение командой export TERM.
Подробнее см. <a href=PROFILE.htm>profile(4)</a>, <a href=TPUT.htm>tput(1)</a> и раздел Табуляции  и
инициализация в <a href=TERMINFO.htm>terminfo(4)</a>.
<p align=justify>Библиотека  curses  содержит  процедуры, манипулирующие
структурами данных, называемыми окнами,  которые  можно
мыслить  как двумерные массивы символов, представляющие
весь экран или его часть.  Всегда  имеется  стандартное
окно,  размером с экран, называемое stdscr. Другие окна
могут быть созданы процедурой newwin. В  программах  на
окна  ссылаются с помощью переменных типа WINDOW *; тип
структур   WINDOW   определен   во   включаемом   файле
&lt;curses.h>.  Этими структурами данных можно манипулировать с помощью процедур, описанных ниже, среди  которых
основными являются move и addch. (Самыми общими являются процедуры, имена которых начинаются с буквы w, в них
можно  указать  окно  в  качестве параметра. Процедуры,
имена которых не начинаются с буквы w, обычно имеют дело с stdscr.) Затем вызывается процедура refresh, которая обращается к нужным процедурам, чтобы экран пользователя выглядел как stdscr. Символы в  окне  имеют  тип
chtype,  что  позволяет для каждого символа хранить дополнительную информацию.
<p align=justify>Существуют окна специального типа  (спецокна),  которые
не ограничены размерами экрана и содержимое которых целиком на экране не изображается. Более подробно об этих
окнах  см.  ниже в разделе Управление окнами (процедура
newpad).
<p align=justify>Для каждого изображаемого на экране символа могут  быть
заданы  атрибуты  визуализации,  что позволяет выводить
подчеркнутые или инвертированные символы на терминалах,
обладающих соответствующими  возможностями.  С  помощью
пакета  curses можно вывести псевдографические символы.
При вводе процедуры пакета могут преобразовывать последовательности, посылаемые стрелками  и  функциональными
клавишами.   Атрибуты  визуализации,  псевдографические
символы и коды для функциональных клавиш описаны в файле &lt;curses.h>, например A_REVERSE, ACS_HLINE, KEY_LEFT.
<p align=justify>В пакете curses определена также переменная curscr типа
WINDOW *, которую можно использовать в  качестве  аргумента  некоторых процедур нижнего уровня, таких как перерисовка испорченного экрана. Если обратиться к процедуре clearok с аргументом curscr, то следующее  обращение к wrefresh для любого окна приведет к очистке экрана  и  затем  его полной перерисовке. Если обратиться к
процедуре wrefresh с аргументом curscr, то экран немедленно очистится и перерисуется. Именно так  большинство
программ осуществляет перерисовку экрана.
<p align=justify>Информация  о размерах экрана, заданная в terminfo, может  быть  перекрыта  переменными  окружения  LINES   и
COLUMNS, что используется, например, для терминала AT&T
5620, имеющего переменный размер экрана.
<p align=justify>Если определена переменная окружения TERMINFO, процедуры  пакета  curses сначала ищут описание терминала не в
стандартном месте, а в указанном. Например, если  переменная  окружения TERM имеет значение att4425, то скомпилированное описание характеристик по умолчанию извлекается из  файла  /usr/lib/terminfo/a/att4425.  Однако,
если   значение  переменной  окружения  TERMINFO  равно
$HOME/myterms, то curses вначале проверит  файл  $HOME/
myterms/a/att4425, и только если этот файл отсутствует,
обратится  к /usr/lib/terminfo/a/att4425. Подобное соглашение удобно для экспериментов  с описаниями, а также
тогда, когда нет прав на  запись  в  каталог  /usr/lib/
terminfo.
<p align=justify>Во  включаемом  файле  &lt;curses.h> определены глобальные
переменные LINES и COLS типа int. В  процедуре  initscr
этим переменным присваивается число строк экрана и число  символов в строке (более подробную информацию см. в
разделе Процедуры уровня terminfo).  Константы  TRUE  и
FALSE суть 1 и 0 соответственно. Процедуры обычно возвращают значения ERR или OK; таким образом можно определить, успешно ли завершилась процедура. Константы ERR и
OK также определены в файле &lt;curses.h>
<p align=justify><b>ПРОЦЕДУРЫ </b><br>
Для  многих описываемых ниже процедур имеется несколько
версий. Процедуры с префиксом  w  имеют  дополнительный
аргумент - окно. Процедуры с префиксом p имеют дополнительный аргумент - спецокно. Процедуры без префикса работают с stdscr.
<p align=justify>Процедуры с префиксом mv имеют дополнительные аргументы
- координаты  x  и y места, куда нужно поместить курсор
перед выполнением соответствующего действия. Эти процедуры вначале вызывают move (y, x), а  затем  соответствующую процедуру без префикса mv. Аргумент y всегда означает  строку  окна, а x - колонку. Левый верхний угол
окна имеет координаты (0, 0), а не (1, 1). Для процедур
с префиксом mvw в  качестве  дополнительных  аргументов
задаются и окно, и координаты курсора. Аргумент, задающий окно, всегда указывается перед координатами.
<p align=justify>Во всех процедурах параметр win задает окно, а параметр
pad - спецокно. (И win, и pad имеют тип WINDOW *.)  Для
процедур, устанавливающих режимы, аргумент bf типа bool
должен  иметь  значение TRUE или FALSE. Типы WINDOWS *,
bool  и   chtype   определены   во   включаемом   файле
&lt;curses.h>.  Описание типов всех переменных приведено в
разделе СИНТАКСИС.
<p align=justify>Все процедуры, если не оговорено противное,  возвращают
значения  ERR  или OK. В случае ошибки результат процедур, возвращающих значения-указатели, равен NULL.
<p align=justify>  <b>   Управление всем экраном </b><br>
<dl>
<dt>WINDOW *initscr ( ) <dd>
Первой вызываемой процедурой почти всегда является
initscr. Есть  только  следующие  три  исключения:
slk_init,  filter  и ripoffline. Процедура initscr
определяет тип терминала и инициализирует структуры данных пакета curses. Выполняются такие  действия, чтобы первое обращение к refresh очистило экран. Если обнаружены ошибки, initscr выводит сообщение  в стандартный протокол и завершает программу; если ошибок  не  было,  возвращается  значение
stdscr.  Если  программа  сама желает обрабатывать
ошибки инициализации, вместо initscr  следует  использовать  newterm. Процедуру initscr нужно вызывать только один раз.
<p><dt>
endwin ( ) <dd>
Процедуру endwin необходимо  обязательно  вызывать
перед  завершением  программы,  а также, например,
перед запуском порожденного процесса shell или выполнением  функции  <a href=SYSTEM.htm>system(3S)</a>.  Процедура  endwin
восстанавливает  начальные характеристики драйвера
<a href=TTY~1.htm>tty(7)</a>, помещает курсор в левый нижний угол экрана
и переводит терминал в нормальный режим визуализации. Чтобы продолжить пользование пакетом  curses,
необходимо    вызвать   процедуру   wrefresh   или
doupdate.
<p><dt>
isendwin ( ) <dd>
Возвращает значение TRUE, если перед этим был  вызов  процедуры  endwin,  но  еще  не  было  вызова
wrefresh или doupdate.
<p><dt>
SCREEN *newterm (type, outgf, infd) <dd>
Программа, осуществляющая вывод на несколько  терминалов одновременно, должна использовать для инициализации  каждого  из них не initscr, а newterm.
Программа, которая сама может обрабатывать  ошибки
инициализации,  например,  путем работы в строчном
режиме вместо экранного, также должна использовать
для инициализации процедуру newterm. В случае нескольких терминалов процедура newterm  должна  быть
вызвана для каждого терминала. Процедура возвращает  значение  типа  SCREEN  *, которое должно быть
сохранено для последующих ссылок на терминал.  Аргумент  type  задает  имя терминала, которое будет
использоваться вместо значения переменной  окружения TERM, аргумент outfd является указателем потока, открытого на вывод [см. <a href=STDIO.htm>stdio(3S)</a>], а аргумент
infd  -  это  указатель потока, открытого на ввод.
При завершении программа должна вызвать  процедуру
endwin  для  каждого терминала. Если newterm вызывался несколько раз для одного и того же  терминала,  endwin  должен вызываться в порядке, обратном
вызовам newterm.
<p><dt>
SCREEN *set_term (new) <dd>
Эта процедура используется для переключения  между
несколькими терминалами. Терминал, на который ссылается аргумент new, становится текущим. Процедура
возвращает  указатель на терминал, бывший до этого
текущим. Это единственная процедура, которая манипулирует указателями типа SCREEN *; все  остальные
процедуры относятся к текущему терминалу.
</dl>
<p align=justify><b>     Управление окнами</b><br> 
<dl>
<dt>refresh ( )
<br>wrefresh (win) <dd>
Эти    процедуры    (или    процедуры    prefresh,
pnoutrefresh, wnoutrefresh  или  doupdate)  должны
вызываться  для  реального  вывода на экран, тогда
как большинство остальных процедур только  манипулируют  структурами данных. Процедура wrefresh копирует указанное окно на экран терминала, принимая
во внимание то, что на экран уже  выведено,  чтобы
не  выводить  информацию  повторно (это называется
оптимизацией вывода). Процедура refresh делает  то
же самое для стандартного окна stdscr. Если не установлен режим leaveok, физический курсор терминала  помещается  на текущее место в окне. Процедура
возвращает количество символов, выведенных на терминал.
<p align=justify>Отметим, что refresh является макросом.
<p><dt>
wnoutrefresh (win)
<br>doupdate ( ) <dd>
Эти  две  процедуры обеспечивают более эффективное
изменение экрана, чем просто wrefresh. Это делается следующим образом.
<p align=justify>Процедуры пакета curses хранят две структуры  данных,  представляющих  экран  терминала: физический
экран, описывающий  реальное  состояние  экрана  и
виртуальный экран, описывающий то, что программист
хочет видеть на экране. Процедура wrefresh сначала
вызывает  процедуру wnoutrefresh, которая копирует
указанное окно на виртуальный экран, а затем обращается к doupdate для сравнения виртуального экрана с физическим и выполнения необходимых изменений
на физическом экране. Если программист хочет изменить сразу несколько окон,  то  несколько  вызовов
wrefresh   приведут   к  последовательным  вызовам
wnoutrefresh и  doupdate,  то  есть  к  нескольким
всплескам  на экране. Если же вначале сделать несколько вызовов wnoutrefresh, а  потом  один  вызов
doupdate, то на экране будет один всплеск, на терминал будет передано меньшее число символов и процессор будет меньше загружен.
<p><dt>
WINDOW *newwin (nlines, ncols, begin_y, begin_x) <dd>
Создать  новое  окно,  содержащее  nlines  строк и
ncols колонок, и возвратить указатель на него. Левый верхний угол окна помещается в строке begin_y,
колонке begin_x. Если nlines или  ncols  равны  0,
размер  окна  будет  LINES-begin_y  строк  и COLS 
begin_x колонок соответственно. Новое окно  размером  с целый экран создается вызовом newwin (0, 0,
0, 0).
<p><dt>
mvwin (win, y, x) <dd>
Переместить указанное окно так,  чтобы  его  левый
верхний  угол находился в позиции (y, x). Если перемещение выводит окно за пределы экрана, это считается ошибкой и перемещение окна не выполняется.
<p><dt>
WINDOW *subwin (orig, nlines, ncols, begin_y, begin_x) <dd>
Создать новое  окно,  содержащее  nlines  строк  и
ncols колонок, и возвратить указатель на него. Левый верхний угол окна помещается в строке begin_y,
колонке  begin_x  (номер  строки и колонки относительно экрана, а не относительно окна orig).  Считается, что новое окно перекрывается с окном orig,
то есть изменения в одном окне влияют на оба окна.
При  использовании этой процедуры обычно требуется
перед  обращением  к  wrefresh  вызвать  процедуры
touchwin и touchline для окна orig.
<p><dt>
delwin (win) <dd>
Удалить указанное окно, освободив всю память, связанную  с  ним.  В  случае перекрытия окон сначала
должны быть удалены окна, созданные с помощью процедур subwin или subpad.
<p><dt>
WINDOW *newpad (nlines, ncols) <dd>
Создать новое спецокно, содержащее nlines строк  и
ncols  колонок,  и  возвратить  указатель на него.
Спецокна не ограничены размерами экрана и даже  не
обязательно  связаны  с  какой-либо частью экрана.
Спецокна используются, когда требуется большое окно, из которого на экране будет изображаться только  часть.  Автоматической  перерисовки   спецокон
(например,  при  роллировании) не происходит. Спецокно нельзя указывать в качестве аргумента процедуры wrefresh, вместо этого необходимо пользоваться процедурами prefresh и  pnoutrefresh.  Отметим,
что  эти процедуры имеют дополнительные аргументы,
посредством которых задается  та  часть  спецокна,
которая должна изображаться, и та часть экрана, на
которой должно располагаться изображение.
<p><dt>
WINDOW *subpad (orig, nlines, ncols, begin_y, begin_x) <dd>
Создать  новое спецокно, содержащее nlines строк и
ncols колонок, и возвратить указатель на  него.  В
отличие  от  процедуры  subwin, левый верхний угол
нового  спецокна  задается  относительно  спецокна
orig.  Новое  окно  перекрывается с окном orig, то
есть изменения в одном окне влияют  на  оба  окна.
При  использовании этой процедуры обычно требуется
перед  обращением  к  prefresh  вызвать  процедуры
touchwin и touchline для окна orig.
<p><dt>
prefresh (pad, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol)
pnoutrefresh (pad, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol)<dd>
Эти  процедуры  аналогичны  процедурам  wrefresh и
wnoutrefresh, только работают они над  спецокнами.
Дополнительные  аргументы  задают место на экране,
куда пойдет вывод. Аргументы pminrow и pmincol задают левый верхний угол области спецокна,  которая
будет  изображаться;  sminrow,  smincol,  smaxrow,
smaxcol  задают прямоугольник на экране, в котором
будет  вестисть отображение.  Правый  нижний  угол
изображаемого прямоугольника в спецокне вычисляется по координатам на экране, так как прямоугольники имеют одинаковые размеры. Оба прямоугольника не
должны выходить за пределы спецокна и экрана.  Отрицательные  значения  pminrow, pmincol, sminrow и
smincol трактуются как нули.
</dl>
<p align=justify>   <b>  Вывод </b><br>
Следующие  процедуры  предназначены для вывода текста в
окна.
<dl><dt>
addch (ch)
<br>waddch (win, ch)
<br>mvaddch (y, x, ch)
<br>mvwaddch (win, y, x, ch) <dd>
Символ ch помещается в текущую позицию окна, текущая позиция при этом сдвигается на единицу вправо.
На правой границе окна  происходит  автоматический
перевод  строки, на нижней строке окна, если установлен режим scrollok, происходит роллирование.
<p align=justify>Если  ch  является  символом  табуляции,  перевода
строки или возврата на шаг, выполняется соответствующее  действие в окне. Для перевода строки перед
перемещением вызывается процедура clrtoeol. Считается, что позиции табуляции расположены  в  каждой
восьмой  позиции. Другие управляющие символы будут
выведены в виде ^X. (Вызов процедуры  winch  после
вывода управляющего символа вернет не сам управляющий символ, а его печатное представление.)
<p align=justify>К символу могут быть добавлены атрибуты визуализации с помощью логической операции ИЛИ, текст будет
визуализироваться  с этими атрибутами. Копирование
текста с атрибутами из одного места экрана в  другое может быть выполнено с помощью процедур inch и
addch. См. ниже описание процедуры standout.
<p align=justify>Отметим,  что  ch  имеет  тип chtype, а не char, а
addch, mvaddch и mvwaddch являются макросами.
<p><dt>
echochar (ch)
<br>wechochar (win, ch)
<br>pechochar (pad, ch) <dd>
Эти  процедуры  соответственно эквивалентны вызову
addch (ch), за которым следует refresh ( ), вызову
waddch (win,  ch),  за  которым  следует  wrefresh
(win), вызову waddch (pad, ch), за которым следует
prefresh  (pad).  При этом нужно учитывать, что на
экран выводится ровно один символ, поэтому расходы
на вывод возрастают. Для процедуры  pechochar  используется  та область экрана, в которую последний
раз выводилось указанное спецокно.
<p align=justify>Отметим, что ch имеет тип chtype,  а  не  char,  а
echochar является макросом.
<p><dt>
addstr (str)
<br>waddstr (win, str)
<br>mvaddstr (y, x, str)
<br>mvwaddstr (win, y, x, str) 
Эти  процедуры выводят цепочку символов str, ограниченную нулевым байтом, в указанное окно. Они эквивалентны вызову waddch для каждого  символа  цепочки.
<p align=justify>Отметим, что addstr, mvaddstr и mvwaddstr являются
макросами.
<p><dt>
attroff (attrs)
<br>wattroff (win, attrs)
<br>attron (attrs)
<br>wattron (win, attrs)
<br>attrset (attrs)
<br>wattrset (win, attrs)
<br>standend ( )
<br>wstandend (win)
<br>standout ( )
<br>wstandout (win) <dd>
Эти процедуры манипулируют атрибутами визуализации
в указанном окне. Атрибуты могут быть любой комбинацией  из  следующих:   A_STANDOUT   (сообщение),
A_REVERSE  (инверсия),  A_BOLD  (выделение), A_DIM
(пониженная    яркость),    A_BLINK    (мерцание),
A_UNDERLINE (подчеркивание), A_ALTCHARSET (альтернативный набор символов). Все константы определены
в  файле &lt;curses.h> и могут комбинироваться операцией логическое ИЛИ (| в языке C).
<p align=justify>Текущие атрибуты окна применяются ко  всем  символам,   которые   записываются  в  окно  процедурой
waddch. Атрибуты принадлежат  символу и  перемещаются вместе с символом при роллировании и вставке/
удалении  строк/символов.  Пакет curses изображает
все атрибуты в той степени, в какой это  позволяет
конкретный терминал.
<p align=justify>Процедура  attrset устанавливает текущий набор атрибутов окна  равным  аргументу  attrs.  Процедура
attroff  сбрасывает  указанные атрибуты, остальные
атрибуты при этом не  меняются.  Процедура  attron
устанавливает указанные атрибуты без изменения остальных.  Вызов  standout  ( ) эквивалентен attron
(A_STANDOUT), а вызов standend  (  )  эквивалентен
attrset (0), то есть сбрасывает все атрибуты.
<p align=justify>Отметим, что ch имеет тип chtype,  а  не  char,  а
attroff,  attron, attrset, standend и standout являются макросами.
<p><dt>
beep ( )
<br>flash ( ) <dd>
Эти процедуры используются для привлечения  внимания пользователя, сидящего за терминалом. Процедура beep подает звуковой сигнал, если это возможно,
а если нет, то делает вспышку на экране. Процедура
flash делает вспышку на экране, если это возможно,
а  если нет, подает звуковой сигнал. Если терминал
не умеет подавать звуковой сигнал и не  умеет  делать  вспышку  на экране, то ничего не происходит.
Почти все терминалы умеют подавать  звуковой  сигнал,  но  только некоторые умеют делать вспышку на
экране.
<p><dt>
box (win, vertch, horch) <dd>
По краю окна win рисуется рамка. Аргументы  vertch
и  horch - это символы, с помощью которых рисуются
вертикальные и горизонтальные линии. Если vertch и
horch равны 0, то используются символы по  умолчанию - ACS_VLINE и ACS_HLINE соответственно.
<p align=justify>Отметим,  что  аргументы  vertch и horch имеют тип
chtype, а не char.
<p><dt>
erase ( )
<br>werase (win) <dd>
Эти процедуры помещают пробелы во все позиции  окна.
<p align=justify>Отметим, что erase является макросом.
<p><dt>
clear ( )
<br>wclear (win) <dd>
Эти процедуры совпадают  с  erase  (  )  и  werase
(win), но они еще дополнительно вызывают процедуру
clearok.  Вследствие этого при следующем обращении
к wrefresh экран будет очищен и перерисован.
<p align=justify>Отметим, что clear является макросом.
<p><dt>
clrtobot ( )
<br>wclrtobot (win) <dd>
Все  строки  ниже позиции курсора, а также текущая
строка правее позиции курсора, включая саму  позицию, очищаются.
<p align=justify>Отметим, что clrtobot является макросом.
<p><dt>
clrtoeol ( )
<br>wclrtoeol (win) <dd>
Текущая строка правее позиции курсора, включая саму позицию, очищается.
<p align=justify>Отметим, что clrtoeol является макросом.
<p><dt>
delay_output (ms) <dd>
При выводе сделать паузу на ms миллисекунд. Не рекомендуется, однако, интенсивно применять эту процедуру.  Предпочтительнее использовать символы-заполнители, а не паузу процессора.
<p><dt>
delch ( )
<br>wdelch (win)
<br>mvdelch (y, x)
<br>mvwdelch (win, y, x) <dd>
Текущий символ в окне удаляется. Все символы справа от него сдвигаются на единицу влево, в  последнюю  позицию  записывается пробел. Позиция курсора
не изменяется (может быть  только  предварительное
перемещение  в  (y,  x)). Описываемые процедуры не
требуют использования аппаратной функции  удаления
символа.
<p align=justify>Отметим, что delch и mvdelch являются макросами.
<p><dt>
deleteln ( )
<br>wdeleteln (win) <dd>
Текущая строка окна  удаляется.  Все  строки  ниже
удаленной поднимаются вверх. Последняя строка окна
очищается.  Позиция курсора не меняется. Описываемые процедуры не требуют использования  аппаратной
функции удаления строки.
<p align=justify>Отметим, что deleteln является макросом.
<p><dt>
getyx (win, y, x) <dd>
Позиция  курсора в окне помещается в аргументы y и
x. Поскольку getyx является макросом, перед именами аргументов не требуется знак &.
<p><dt>
getbegyx (win, y, x)
<br>getmaxyx (win, y, x) <dd>
В духе getyx эти процедуры позволяют получить  координаты левого верхнего угла окна на экране и его
размеры.
<p align=justify>Отметим, что getbegyx и getmaxyx являются макросами.
<p><dt>
insch (ch)
<br>winsch (win, ch)
<br>mvinsch (y, x, ch)
<br>mvwinsch (win, y, x, ch)<dd> 
Символ  ch  вставляется перед текущим. Все символы
правее текущего, включая  и  сам  текущий  символ,
сдвигаются  вправо, при этом, возможно, самый правый символ строки пропадает.  Позиция  курсора  не
изменяется  (может быть только предварительное перемещение в (y,x)). Описываемые процедуры не  требуют использования аппаратной функции вставки символа.
<p align=justify>Отметим, что ch имеет тип chtype,  а  не  char,  а
insch, mvinsch и mvwinsch являются макросами.
<p><dt>
insertln ( )
<br>winsertln (win) <dd>
Перед  текущей  строкой  окна  вставляется пустая.
Нижняя строка окна теряется. Описываемые процедуры
не требуют использования аппаратной функции вставки строки.
<p align=justify>Отметим, что insertln является макросом.
<p><dt>
move (y, x)
<br>wmove (win, y, x) <dd>
Текущая позиция, соответствующая окну, перемещается в строку y, колонку x. Физический курсор на экране  не  перемещается  до  тех пор, пока не будет
вызвана процедура refresh. Позиция указывается относительно левого верхнего угла окна, имеющего координаты (0, 0).
<p align=justify>Отметим, что move является макросом.
<p><dt>
overlay (srcwin, dstwin)
<br>overwrite (srcwin, dstwin) <dd>
Эти процедуры помещают  окно  srcwin  поверх  окна
dstwin,  то  есть  текст  из  srcwin  копируется в
dstwin. Окна не обязаны иметь  одинаковый  размер,
копируется  только  пересекающаяся  часть. Разница
между двумя процедурами  заключается  в  том,  что
overlay не копирует пробелы, оставляя на этом месте то, что было, а overwrite производит полное копирование.
<p><dt>
copywin (srcwin, dstwin, sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol, overlay) <dd>
Эта  процедура дает существенно больше, чем процедуры  overlay  и  overwrite.  Как  и  в  процедуре
prefresh,  задается прямоугольник в окне-приемнике
(dminrow, dmincol, dmaxrow, dmaxcol) и левый верхний угол в окне-источнике (sminrow, smincol). Если
аргумент overlay не равен 0, то пробелы не копируются, как в overlay.
<p><dt>
printw (fmt[, arg...])
<br>wprintw (win, fmt[, arg...])
<br>mvprintw (y, x, fmt[, arg...])
<br>mvwprintw (win, y, x, fmt[, arg...]) <dd>
Эти процедуры аналогичны <a href=PRINTF.htm>printf(3S)</a>, только сгенерированная цепочка символов  выводится  с  помощью
waddstr в указанное окно.
<p><dt>
vwprintw (win, fmt, varglist) <dd>
Эта процедура аналогична <a href=VFPRINTF.htm>vfprintf(3S)</a>. Она вызывает wprintw с переменным списком аргументов. Третий
аргумент,  varglist, является указателем на список
аргументов, как это определено  в  <varargs.h>.  O
работе  со списком аргументов переменной длины см.
<a href=VPRINTF.htm>vprintf(3S)</a> и <a href=VARARGS.htm>varargs(5)</a>.
<p><dt>
scroll (win) <dd>
Окно  роллируется  вверх  на одну строку. При этом
изменяются строки и в структурах данных, описывающих окно. Для оптимизации,  в  окне  stdsrc,  если
роллируется окно целиком, одновременно роллируется
и физический экран.
<p><dt>
touchwin (win)
<br>touchline (win, start, count) <dd>
Забыть  информацию о том, какие части окна изменились (эта информация используется для  оптимизации
вывода).  Считать, что все окно требует перерисовки. Это часто бывает необходимо для пересекающихся
окон, так как изменение одних окон вызывает  изменение и других, но информация об этих изменениях в
структурах данных других окон не отражается. Обращение  к  touchline  говорит о том, что изменилось
count строк окна,  начиная  со  строки  с  номером
start.
</dl>
<p align=justify><b>     Ввод </b><br>
<dl><dt>
getch ( )
<br>wgetch (win)
<br>mvgetch (y, x)
<br>mvwgetch (win, y, x) <dd>
С клавиатуры терминала, связанного с окном, считывается  символ.  Если  установлен  режим NODELAY и
символ еще не введен, возвращается  значение  ERR.
Если установлен режим DELAY, программа приостанавливается  до  тех пор, пока система не передаст ей
введенный текст. В зависимости  от  режима  CBREAK
это   будет  после  ввода  одного  символа  (режим
CBREAK) или  после  ввода  строки  целиком  (режим
NOCBREAK).  В режиме HALF-DELAY программа приостанавливается до тех пор, пока не будет введен  символ  или истечет указанный период времени. Если не
установлен режим NOECHO, вводимые символы  отображаются в соответствующем окне. Между обращениями к
move и getch, вызываемыми из  процедур  mvgetch  и
mvwgetch, не делается refresh.
<p align=justify>Используя   процедуры  getch,  wgetch,  mvgetch  и
mvwgetch, нельзя устанавливать одновременно режимы
NOCBREAK и ECHO. Результаты могут  оказаться  непредсказуемыми  и  зависят  от состояния, в котором
находится драйвер <a href=TTY~1.htm>tty(7)</a>.
<p align=justify>Если  предварительно была вызвана процедура keypad
(win, TRUE) и нажата  функциональная  клавиша,  то
вместо  посланных ею кодов будет возвращено значение, соответсвующее клавише (см. keypad в Установке режимов ввода). Функциональные клавиши  определены  в &lt;curses.h>, их значения начинаются с числа
0401, а имена - с префикса  KEY_.  Если  поступает
символ,  который может быть началом функциональной
клавиши (например, ESC), curses запускает  таймер.
Если  за ожидаемое время не будет получено продолжения, то символ передается сам по себе, в противном случае  возвращается  значение  функциональной
клавиши.  Поэтому на многих терминалах после нажатия  клавиши  ESC  необходимо  немного  подождать,
прежде  чем эта клавиша попадет программе. По этой
же причине не рекомендуется программистам  использовать  клавишу  ESC  как  односимвольную  команду
программе. См. также notimeout ниже.
<p align=justify>Отметим,  что  getch,  mvgetch и mvwgetch являются
макросами.
<p><dt>
getstr (str)
<br>wgetstr (win, str)
<br>mvgetstr (y, x, str)
<br>mvwgetstr (win, y, x, str) <dd>
Процедура getch вызывается до тех пор, пока не будет  нажата  клавиша перевода строки, возврата каретки или клавиша "ввод". Результат  помещается  в
область памяти, на которую указывает аргумент str.
При вводе обрабатываются управляющие символы erase
и  kill.  Так  же как и в процедуре mvgetch, между
обращениями к move и getstr, вызываемыми из процедур mvgetstr и mvwgetstr, не делается refresh.
<p align=justify>Отметим, что getstr, mvgetstr и mvwgetstr являются
макросами.
<p><dt>
flushinp ( ) <dd>
Проигнорировать все символы, введенные пользователем к этому моменту, но еще не считанные  программой.
<p><dt>
ungetch (c)<dd> 
Положить  символ c обратно во входную очередь, так
что он будет считан следующим вызовом wgetch.
<p><dt>
chtype inch ( )
<br>chtype winch (win)
<br>chtype mvinch (y, x)
<br>chtype mvwinch (win, y, x) <dd>
Эти процедуры  возвращают  символ  (типа  chtype),
расположенный  в  текущей позиции указанного окна,
вместе с имеющимися атрибутами (как логическое ИЛИ
атрибутов и кода символа). Константы A_CHARTEXT  и
A_ATTRIBUTES,  определенные  в  файле  &lt;curses.h>,
можно использовать в операции "логическое И" (&  в
языке  C)  для выделения из возвращаемого значения
только кода символа или только атрибутов.
<p align=justify>Отметим, что inch, winch, mvinch и mvwinch являются макросами.
<p><dt>
scanw (fmt[, arg...])
<br>wscanw (win, fmt[, arg...])
<br>mvscanw (y, x, fmt[, arg...])
<br>mvwscanw (win, y, x, fmt[, arg...]) <dd>
Эти процедуры аналогичны <a href=SCANF.htm>scanf(3S)</a> и  по  аргументам, и по возвращаемым значениям. В окне вызывается  процедура wgetstr, а полученная цепочка символов сканируется в соответствии с указанным  форматом.
<p><dt>
vwscanw (win, fmt, varglist) <dd>
Эта  процедура аналогична процедуре vwprintw, описанной выше.  Она  вызывает  wscanw  с  переменным
списком аргументов. Третий аргумент, varglist, является  указателем  на  список аргументов, как это
определено в <varargs.h>. O работе со списком  аргументов   переменной   длины  см.  <a href=VPRINTF.htm>vprintf(3S)</a>  и
<a href=VARARGS.htm>varargs(5)</a>.
</dl>
<p align=justify><b>     Установка режимов вывода </b><br>
Следующие процедуры устанавливают режимы вывода для пакета curses. Все режимы при инициализации равны  FALSE.
Нет  необходимости  перед вызовом endwin возвращать все
режимы в состояние FALSE.
<dl><dt>
clearok (win, bf) <dd>
Если  значение аргумента bf равно TRUE, то следующий вызов wrefresh приведет к очистке окна и  полной  его  перерисовке. Это удобно, если содержимое
окна испортилось, кроме того, иногда полная  перерисовка  окна  дает  лучший визуальный эффект, чем
частичная.
<p><dt>
idlok (win, bf) <dd>
Если значение аргумента bf равно TRUE, то процедуры пакета curses для вставки и удаления строк  будут использовать аппаратные команды (если они имеются). Если bf равно FALSE, то curses этими командами  пользуется  редко  (команды вставки/удаления
символов используются всегда). Этот режим  следует
использовать  только  если Вам действительно нужно
вставлять и удалять строки (например, в  программе
- экранном  редакторе).  По  умолчанию  этот режим
имеет значение FALSE, так как применение  аппаратной вставки и удаления строк в программах, в которых  это реально не требуется, приводит к неприятным визуальным эффектам. Если использование  аппаратных  команд запрещено, то curses перерисовывает
изменившуюся часть всех строк.
<p><dt>
leaveok (win, bf) <dd>
Обычно аппаратный курсор находится в текущей позиции текущего окна. Если bf равно TRUE, то разрешается оставлять курсор там, где его  оставило  последнее  изменение экрана. Это удобно для программ,
не использующих позицию курсора, так как уменьшает
необходимость в его перемещениях. Если используется этот режим, то курсор делается невидимым  (если
терминал это позволяет).
<p><dt>
setscrreg (top, bot)
<br>wsetscrreg (win, top, bot) <dd>
Эти процедуры позволяют установить роллируемую область  в  окне.  Аргументы  top и bot - это номера
верхней и нижней строки задаваемой области  (номер
верхней  строки окна равен 0). Если задана область
роллирования и установлен режим  scrollok,  то  из
нижней  строки окна происходит роллирование только
заданной области. Описываемые процедуры не требуют
использования аппаратного роллирования полос,  как
это имеет место в терминале DEC vt100. Однако, если  установлен режим idlok и терминал умеет роллировать полосы или вставлять и удалять  строки,  то
эти возможности будут использованы процедурами вывода.
<p align=justify>Отметим, что обе процедуры setscrreg и  wsetscrreg
являются макросами.
<p><dt>
scrollok (win, bf) <dd>
Процедура служит для формирования режима обработки
ситуации,  когда  курсор в окне выходит за границы
роллируемой области из-за перевода строки  в  последней строке области или вывода символа в последнюю  позицию  последней строки. Если этот режим не
установлен (значение bf равно FALSE), курсор остается в последней строке на том же месте. Если  режим установлен (значение bf равно TRUE) происходит
вызов  wrefresh,  а затем окно и экран физического
терминала роллируются на одну строку вверх.  Обратите  внимание, что для того, чтобы физический экран  роллировался,  необходимо  установить   режим
idlok.
<p><dt>
nl ( )
<br>nonl ( ) <dd>
Эти  процедуры  управляют  преобразованием символа
перевода строки в возврат каретки и переход к  новой строке при выводе и символа возврата каретки в
перевод  строки при вводе. По умолчанию эти преобразования выполняются. При отмене этих  преобразований процедурой nonl пакет curses  получает  возможность  осуществлять  более  быстрые перемещения
курсора, пользуясь переходом к новой строке.
</dl>
<p align=justify>   <b>  Установка режимов ввода </b><br>
Следующие  процедуры устанавливают режимы ввода для пакета curses. Установка режимов включает в себя  обращение к системному вызову <a href=IOCTL.htm>ioctl(2)</a> и может оказывать влияние на другие режимы. Нет необходимости перед выполнением  endwin  возвращать все режимы в начальное состояние.
<dl><dt>
cbreak ( )
<br>nocbreak ( ) <dd>
Эти  две  процедуры соответственно устанавливают и
сбрасывают режим CBREAK. В режиме CBREAK  вводимые
символы сразу передаются программе, обработка символов  erase  и  kill  не  производится.  В режиме
NOCBREAK драйвер <a href=TTY~1.htm>tty(7)</a> буферизует вводимые символы до тех пор, пока не будет введен символ перевода строки или возврата каретки. Символы прерывания
и управления передачей в этом режиме не затрагиваются [см. <a href=TERMIO.htm>termio(7)</a>]. Начальное состояние терминала может быть любым, поэтому, если требуется,  необходимо   явно   вызвать   процедуру  cbreak  или
nocbreak. Большинство интерактивных программ,  использующих curses, устанавливают режим CBREAK.
<p align=justify>Отметим,  что процедура cbreak устанавливает режим
raw. См. также getch в разделе Ввод по поводу  того,  как  описываемые  процедуры взаимодействуют с
процедурами echo и noecho.
<p><dt>
echo ( )
<br>noecho ( ) <dd>
Эти  процедуры  управляют  тем, отображаются ли на
экране символы, вводимые по getch. Эхо,  выполняемое драйвером, всегда отменено, но при инициализации  для getch устанавливается режим ECHO, то есть
вводимые символы отображаются. Авторы  большинства
интерактивных программ предпочитают самостоятельно
отображать  вводимые символы в отдельной части экрана, либо не отображать их вовсе, для чего  вызывается  процедура noecho. См. getch в разделе Ввод
по поводу того, как описываемые процедуры  взаимодействуют с процедурами cbreak и nocbreak.
<p><dt>
halfdelay (tenths) <dd>
Этот режим похож на режим CBREAK тем, что вводимые
символы сразу передаются программе. Однако если ни
одна  клавиша  не была нажата на протяжении tenths
десятых долей секунды, будет  возвращено  значение
ERR.  Число  tenths  должно  быть от 1 до 255. Для
выключения  этого  режима  используется  процедура
nocbreak.
<p><dt>
intrflush (win, bf) <dd>
Если  установлен этот режим, то при нажатии одного
из символов прерывания  (interrupt,  break,  quit)
весь  ввод,  накопленный  в драйвере <a href=TTY~1.htm>tty(7)</a>, будет
проигнорирован, что позволяет быстро отреагировать
на прерывание. Правда, состояние экрана  при  этом
может   перестать  соответствовать  представлению,
имеющемуся в структурах curses. Отмена этого режима предотвращает очистку буферов в  драйвере.  Начальное значение данного режима зависит от состояния драйвера. Аргумент win игнорируется.
<p><dt>
keypad (win, bf) <dd>
Эта  процедура устанавливает режим обработки функциональных клавиш на  клавиатуре  терминала.  Если
этот  режим установлен, то при нажатии пользователем функциональной клавиши (например, стрелки влево), процедура  wgetch  возвратит  соответствующее
этой  клавише значение (KEY_LEFT). Если данный режим не установлен,  то  последовательности  кодов,
посылаемых  функциональными клавишами, не преобразуются, программа может обрабатывать их сама. Если
функциональная клавиатура  терминала  может  находиться  как  в  режиме передачи, так и в локальном
режиме, вызов процедуры keypad приводит к переводу
клавиатуры в режим передачи при первом обращении к
wgetch.
<p><dt>
meta (win, bf) <dd>
Если этот режим установлен, все  8  бит  символов,
вводимых с клавиатуры, передаются программе, иначе
процедура wgetch сбрасывает восьмой бит. Чтобы режим  META  работал  правильно, необходимо, чтобы в
базе данных <a href=TERMINFO.htm>terminfo(4)</a> для данного терминала была
задана характеристика km (клавиша МЕТА).
<p><dt>
nodelay (win, bf) <dd>
Этот режим не позволяет процедуре wgetch уходить в
ожидание. Если этот режим установлен и нет готового символа, то возвращается значение ERR. Если режим не установлен, то wgetch ожидает ввода следующего символа.
<p><dt>
notimeout (win, bf) <dd>
При интерпретации вводимых управляющих  последовательностей процедура wgetch запускает таймер, ожидая  следующего  символа.  Если  вызвать процедуру
notimeout (win, TRUE), то запуска таймера не  происходит. Таймер используется для различения последовательностей,  приходящих от функциональных клавиш, и последовательных нажатий обычных клавиш.
<p><dt>
raw ( )
<br>noraw ( ) <dd>
Устанавливается или отменяется  режим  RAW.  Режим
RAW  аналогичен  режиму  CBREAK,  вводимые символы
сразу передаются программе. Отличие заключается  в
том,  что  символы прерывания (interrupt, quit), а
также символы управления передачей (xon, xoff) передаются без интерпретации, сигналы  при  этом  не
генерируются. Режим RAW устанавливает восьмибитный
ввод  и вывод. Реакция на клавишу BREAK зависит от
других бит в характеристиках драйвера <a href=TTY~1.htm>tty(7)</a>,  эти
биты пакетом curses не устанавливаются.
<p><dt>
typeahead (fildes) <dd>
Обычно curses выполняет следующий вид оптимизации.
Перед выводом на экран проверяется, нет ли уже нажатых клавиш, и, если есть, то вывод откладывается
до следующего вызова  refresh  или  doupdate.  Это
позволяет быстрее реагировать на последовательности  команд. Обычно для проверки используется дескриптор файла,  переданного  в  качестве  аргумента
процедуре  newterm,  или stdin, если инициализация
проводилась с помощью initscr. Процедура typeahead
позволяет заменить  проверяемый  файл  на  файл  с
дескриптором fildes. Если fildes равен -1, то описанная выше оптимизация не выполняется.
<p align=justify>Отметим, что fildes - это дескриптор файла,  а  не
указатель на структуру типа FILE.
</dl>
<p align=justify><b>     Запросы к оборудованию </b><br>
<dl><dt>
baudrate ( ) <dd>
Скорость  вывода  на  терминал. Возвращается целое
число, означающее скорость передачи в битах в  секунду, например 9600.
<p><dt>
char erasechar ( ) <dd>
Возвращается текущее значение символа erase.
<p><dt>
has_ic ( ) <dd>
Истина,  если  терминал  умеет вставлять и удалять
символы.
<p><dt>
has_il ( ) <dd>
Истина, если терминал умеет  вставлять  и  удалять
строки.
<p><dt>
char killchar ( ) <dd>
Возвращается текущее значение символа kill.
<p><dt>
char *longname ( ) <dd>
Процедура  возвращает указатель на статическую область, содержащую словесное описание данного  терминала.  Максимальная  длина словесного описания 128 символов. К данной процедуре можно  обращаться
только  после initscr или newterm. Статическая область изменяется при последующих вызовах newterm и
не восстанавливается вызовами  set_term,  поэтому,
если предполагается пользоваться словесными описаниями для нескольких терминалов, то описание необходимо скопировать в другое место.
</dl>
<p align=justify><b>     Программируемые метки </b><br>
Пакет  curses  дает  доступ к программируемым меткам на
клавишах, которые имеются на некоторых терминалах.  Для
тех  терминалов,  на которых нет программируемых меток,
имеется возможность их эмуляции в верхней  строке  окна
stdscr,  при  этом  уменьшается  на единицу размер окна
stdscr и значение переменной LINES. Curses поддерживает
восемь меток по восемь символов каждая.
<dl><dt>
slk_init (labfmt) <dd>
Чтобы использовать программируемые метки, процедура slk_init должна быть  вызвана  раньше  процедур
initscr  и  newterm.  Если процедура initscr будет
использовать верхнюю строку экрана для  меток,  то
аргумент  labfmt  задает их расположение в строке.
Если значение labfmt равно  0,  метки  размещаются
тремя группами 3-2-3, а если значение labfmt равно
1, то двумя группами 4-4.
<p><dt>
slk_set (labnum, label, labfmt) <dd>
Аргумент  labnum - это номер метки, от 1 до 8. Аргумент label представляет собой  цепочку  символов
(длиной  не  более  8),  которая помещается в виде
метки. Пустая цепочка или адрес, равный NULL,  задают  пустую  метку.  Значения labfmt, равные 0, 1
или 2, говорят о том, что метка соответственно выровнена влево, центрирована или выровнена вправо.
<p><dt>
slk_refresh ( )
<br>slk_noutrefresh ( ) <dd>
Эти процедуры соответствуют процедурам wrefresh  и
wnoutrefresh.    Большинство   программ   вызывают
slk_noutrefresh, так  как  обычно  довольно  скоро
приходится вызывать wrefresh.
<p><dt>
char *slk_label (labnum) <dd>
Возвращается  текущее  значение  метки  с  номером
labnum, из которого удалены начальные и  хвостовые
пробелы.
<p><dt>
slk_clear ( ) <dd>
Программируемые метки убираются с экрана.
<p><dt>
slk_restore ( ) <dd>
Программируемые метки, убранные  с экрана процедурой slk_clear, восстанавливаются.
<p><dt>
slk_touch ( ) <dd>
При  следующем  обращении  к  slk_noutrefresh  все
программируемые метки будут выведены на экран  заново.
</dl>
<p align=justify><b>     Процедуры нижнего уровня </b><br>
Следующие процедуры нижнего уровня дают доступ  к  различным возможностям пакета curses. Обычно эти процедуры
вызываются из библиотечных процедур.
<dl><dt>
def_prog_mode ( )
<br>def_shell_mode ( ) <dd>
Сохранить  текущие значения характеристик терминала, как значения, необходимые для выполнения самой
программы (с пакетом curses) или  программы  shell
(без  пакета curses) для последующего восстановления      процедурами       reset_prog_mode       и
reset_shell_mode.  Эти процедуры вызываются процедурой initscr.
<p><dt>
reset_prog_mode ( )
<br>reset_shell_mode ( ) <dd>
Восстановить  запомненные  значения  характеристик
терминала для продолжения работы пакета curses или
для запуска программы shell. Эти процедуры вызываются процедурами endwin и doupdate.
<p><dt>
resetty ( )
<br>savetty ( ) <dd>
Эти процедуры запоминают и восстанавливают  запомненные характеристики терминала. Процедура savetty
запоминает  характеристики  в  буфере,  а  resetty
восстанавливает последние запомненные  характеристики.
<p><dt>
getsyx (y, x) <dd>
Аргументам  y и x присваиваются значения координат
курсора на виртуальном экране. Как и в getyx,  перед  именами переменных не нужно указывать &. Если
установлен режим leaveok, то переменным присваиваются значения (-1,-1). Если верхние строки  экрана
были  удалены с помощью процедуры ripoffline и полученные значения предполагается не  просто  передать  процедуре  setyx, а использовать еще как-то,
то значение y должно  быть  скорректировано  путем
прибавления значения stdscr->_yoffset.
<p align=justify>Отметим, что getsyx является макросом.
<p><dt>
setsyx (y, x) <dd>
Виртуальный  курсор  устанавливается в позицию (y,
x). Если оба значения y и x равны -1, то  устанавливается  режим  leaveok.  Две  процедуры getsyx и
setsyx созданы для того, чтобы библиотечные процедуры могли манипулировать окнами, не испортив  текущей позиции курсора. Библиотечные процедуры вначале вызывают getsyx, затем производят манипуляции
над   окнами,   вызывают   для   измененных   окон
wnoutrefresh, после чего вызывают setsyx и  заканчивают вызовом doupdate.
<p><dt>
ripoffline (line, init) <dd>
Эта  процедура  позволяет уменьшить размер экрана,
ею  пользуется   процедура   slk_init.   Процедуру
ripoffline  необходимо  вызывать  раньше  процедур
initscr и newterm. Если значение line  положительно, удаляется одна строка сверху окна sdtscr, если
отрицательно - удаляется строка снизу. После этого
из процедуры initscr вызывается процедура  init  с
двумя  аргументами:  указателем  на созданное окно
единичной высоты и шириной этого окна в  колонках.
При  вызове данной процедуры не гарантируется правильность глобальных переменных LINES и COLS  (определенных в &lt;curses.h>), кроме того, из этой процедуры  нельзя  обращаться к процедурам wrefresh и
doupdate, но можно обращаться к wnoutrefresh.
<p align=justify>Перед обращением к initscr или  newterm  процедуру
ripoffline можно вызывать несколько раз (до пяти).
<p><dt>
scr_dump (filename) <dd>
Текущее состояние виртуального экрана записывается
в файл filename.
<p><dt>
scr_restore (filename) <dd>
Текущее состояние виртуального экрана восстанавливается  из  файла  filename,  куда оно должно быть
предварительно записано командой  scr_dump.  После
восстановления    необходимо   вызвать   процедуру
doupdate для изображения восстановленного  состояния.
<p><dt>
scr_init (filename) <dd>
Содержимое файла filename используется для коррекции  информации  о  том, что изображено на экране.
Если данные пройдут проверку на  корректность,  то
curses при следующей перерисовке экрана использует
полученную  информацию.  Процедура scr_init обычно
используется после initscr и после системного  вызова  <a href=SYSTEM.htm>system(3S)</a>  для сохранения состояния экрана,
сформированного другим процессом,  который  должен
предварительно,  после  обращения  к endwin, обратиться к scr_dump. Проверка на корректность заключается в проверке времени модификации файла с состоянием  экрана,  кроме   того   в   базе   данных
<a href=TERMINFO.htm>terminfo(4)</a> для данного терминала должна присутствовать характеристика nrrmc.
<p><dt>
curs_set (visibility) <dd>
Курсор  делается  невидимым,  нормальным или более
ярким, если значение visibility равно,  соответственно, 0, 1 или 2.
<p><dt>
draino (ms) <dd>
Подождать, пока весь сформированный вывод на экран
не будет  почти закончен, то есть до его окончания
останется не более ms миллисекунд.
<p><dt>
garbagedlines (win, begline, numlines) <dd>
Эта процедура сообщает пакету  curses,  что  экран
испорчен и должен быть перерисован. Это может быть
использовано,   например,  экранными  редакторами,
имеющими команду для перерисовки отдельной строки.
Подобная команда требуется, если терминал  подсоединен  по  линии,  на  которой много шумов, причем
полная перерисовка экрана приведет к  еще  большим
шумам.  Перерисовка  одной строки дает возможность
надеяться, что она будет исполнена правильно.
<p><dt>
napms (ms) <dd>
    Пауза на ms миллисекунд.
</dl>
<p align=justify><b>     Процедуры уровня terminfo </b><br>
Данные процедуры используются программами, которым требуется   работа   непосредственно   с   базой    данных
<a href=TERMINFO.htm>terminfo(4)</a>  для  отработки  специфических возможностей
терминалов, например,  программирования  функциональной
клавиатуры.  В  остальных случаях рекомендуется пользоваться только процедурами пакета curses, описанными выше.
<p align=justify>Вначале должна быть вызвана  процедура  setupterm  (эта
процедура  автоматически вызывается процедурами initscr
и newterm. В ней присваиваются значения  всем  переменным,  определенным  в  <a href=TERMINFO.htm>terminfo(4)</a>. Значения переменным
<a href=TERMINFO.htm>terminfo(4)</a> lines и columns присваиваются следующим образом: если определены  переменные  окружения  LINES  и
COLUMNS,  используются  их значения. Иначе используются
значения, заданные в базе данных <a href=TERMINFO.htm>terminfo(4)</a>.
<p align=justify>Для  того, чтобы программа имела доступ ко всем необходимым переменным, цепочкам,  числам  и  флагам,  в  нее
должны быть включены файлы &lt;curses.h> и <term.h> в указанном  порядке.  Параметризованные цепочки должны быть
конкретизированы   процедурой   tparm.   Все    цепочки
<a href=TERMINFO.htm>terminfo(4)</a>, включая цепочки, выходные для tparm, должны  выводиться на экран процедурами tputs или putp. Перед   завершением    необходимо    вызвать    процедуру
reset_shell_mode  для восстановления характеристик терминала. Программы,  в  которых  используется  адресация
курсора,  должны вывести цепочку enter_ca_mode в начале
работы и цепочку exit_ca_mode перед концом работы  [см.
<a href=TERMINFO.htm>terminfo(4)</a>].  Программы,  предусматривающие запуск порожденного процесса  shell,  должны  вызвать  процедуру
reset_shell_mode  и  вывести цепочку exit_ca_mode перед
запуском shell, а после завершения порожденного процесса необходимо вывести цепочку enter_ca_mode  и  вызвать
процедуру reset_prog_mode. Обратите внимание на отличие
этой  процедуры  от  стандартной  процедуры  для пакета
curses [см. endwin].
<dl><dt>
setupterm (term, fildes, erret)<dd> 
Читает  базу  данных  <a href=TERMINFO.htm>terminfo(4)</a>,  инициализирует
структуры данных <a href=TERMINFO.htm>terminfo(4)</a>. Структуры управления
выводом для пакета curses при этом не устанавливаются. Тип терминала задается аргументом term,  являющемся  цепочкой  символов.  Если  значение term
равно NULL, используется значение переменной окружения TERM. Вывод ведется в  файл  с  дескриптором
fildes.  Если  значение  erret  не  равно NULL, то
setupterm возвратит значение OK или ERR и поместит
в переменную *erret код завершения. Код, равный 1,
означает нормальное завершение,  0  означает,  что
терминал не найден в базе данных, -1 означает, что
не удалось найти саму базу данных <a href=TERMINFO.htm>terminfo(4)</a>. Если  значение erret равно NULL, то в случае наличия
ошибок setupterm напечатает сообщения о них и  завершит программу. Таким образом, самый простой вызов, при котором используются только подразумеваемые значение, выглядит следующим образом:
<pre>
	setupterm ((char *) 0, 1, (int *) 0)
</pre>
<p align=justify>Все переменные  <a href=TERMINFO.htm>terminfo(4)</a>  булева,  числового  и
символьного  типа  размещаются  в  структуре  типа
TERMINAL.  После  успешного  завершения  процедуры
setupterm   глобальной  переменной  cur_term  типа
TERMINAL * присваивается значение указателя на заполненную структуру.  Этот  указатель  может  быть
сохранен  перед  следующим вызовом setupterm. Повторный вызов setupterm размещает  в  памяти  новую
структуру  и  записывает  новую информацию в новое
место.
<p><dt>
set_curterm (nterm) <dd>
Аргумент nterm имеет  тип  TERMINAL  *.  Процедура
set_curterm присваивает переменной cur_term значение  nterm, после этого все переменные <a href=TERMINFO.htm>terminfo(4)</a>
получают значения, заданные для nterm.
<p><dt>
del_curterm (oterm) <dd>
Аргумент oterm имеет  тип  TERMINAL  *.  Процедура
del_curterm  освобождает  память, занятую структурой, на которую указывает oterm. Если oterm совпадает с cur_term, то после этого нельзя  обращаться
ни к одной переменной <a href=TERMINFO.htm>terminfo(4)</a> до тех пор, пока
снова не будет вызвана процедура setupterm.
<p><dt>
restartterm (term, fildes, erret) <dd>
То  же, что и setupterm после восстановления памяти.
<p><dt>
char *tparm (str, p1, p2, p3, p4, p5, p6, p7, p8, p9) <dd>
Подставляет в цепочку str аргументы  p1,  p2,  ...
p9.  Возвращается  указатель на цепочку с подставленными аргументами.
<p><dt>
tputs (str, count, putc) <dd>
Добавляет, если надо, заполнитель к цепочке str  и
выводит  ее. Цепочка str должна быть значением какой либо символьной переменной  <a href=TERMINFO.htm>terminfo(4)</a>,  либо
результатом   работы   процедур  tparm,  tsgetstr,
tigetstr или tgoto. Аргумент  count  задает  количество  строк, которые затрагиваются выводом; если
оно неизвестно, задается 1. Аргумент  putc  -  это
процедура, аналогичная <a href=PUTCHAR.htm>putchar(3S)</a>. Этой процедуре
символы передаются последовательно.
<p><dt>
putp (str) <dd>
Процедура, вызывающая tputs (str, 1, putchar).
<p><dt>
vidputs (attrs, putc) <dd>
Выводит  цепочку, переводящую терминал в режим визуализации символов с атрибутами attrs -  комбинацией  атрибутов, описанных ниже, в разделе АТРИБУТЫ. Символы передаются процедуре putc, аналогичной
<a href=PUTCHAR.htm>putchar(3S)</a>.
<p><dt>
mvcur (oldrow, oldcol, newrow, newcol) <dd>
Процедура нижнего уровня для перемещения курсора.
</dl>
<p align=justify>Следующие процедуры возвращают значения  характеристик,
которые  передаются  им в качестве параметров, например
xenl.
<dl><dt>
tigetflag (capname) <dd>
Если  capname не является булевой характеристикой,
возвращается значение -1.
<p><dt>
tigetnum (capname) <dd>
Если capname не является числовой характеристикой,
возвращается значение -2.
<p><dt>
char *tigetstr (capname)<dd>
Если capname не является символьной  характеристикой, возвращается значение (char*) -1.
<p><dt>
char *boolnames [ ], *boolcodes [ ], *boolfnames [ ]
<br>char *numnames [ ], *numcodes [ ], *numfnames [ ]
<br>char *strnames [ ], *strcodes [ ], strfnames [ ] <dd>
Эти  массивы,  завершающиеся нулевыми байтами, содержат имена, коды termcap и длинные  C-имена  для
каждой переменной <a href=TERMINFO.htm>terminfo(4)</a>.
</dl>
<p align=justify>   <b>  Эмуляция termcap </b><br>
Данные процедуры включены  для  того,  чтобы  упростить
преобразование   программ,   использовавших  библиотеку
termcap. Параметры у них остались прежними,  но  теперь
они эмулируются через базу данных <a href=TERMINFO.htm>terminfo(4)</a>.
<dl><dt>
tgetent (bp, name) <dd>
Найти элемент termcap для имени name. При эмуляции
параметр bp игнорируется.
<p><dt>
tgetflag (codename)<dd> 
Получить булево значение элемента codename.
<p><dt>
tgetnum (codename) <dd>
Получить числовое значение элемента codename.
<p><dt>
char *tgetnum (codename, area) <dd>
Получить  символьное  значение  элемента codename.
Если указатель area не равен NULL, то поместить то
же значение в буфер, на который указывает *area, и
продвинуть *area. Для вывода возвращенной  цепочки
символов необходимо использовать процедуру tputs.
<p><dt>
char *tgoto (cap, col, row) <dd>
Подставить  аргументы в указанный элемент. Для вывода возвращенной цепочки символов необходимо  использовать процедуру tputs.
<p><dt>
tputs (str, count, putc) <dd>
См. выше раздел Процедуры уровня terminfo.
</dl>
<p align=justify><b>     Дополнительные процедуры </b><br>
<dl><dt>
traceoff ( )
<br>traceon ( ) <dd>
Включить  и  выключить трассировочную печать отладочной   версии   библиотеки   curses   (/usr/lib/
libdcurses.a). Эта библиотека доступна только тем,
кто  приобрел  лицензию  на исходные тексты пакета
curses.
<p><dt>
unctrl (c) <dd>
Этот макрос преобразует символ в цепочку, содержащую его печатное представление. Управляющие символы изображаются в виде ^X. Печатные символы не изменяются.
<p align=justify>Отметим,  что  unctrl - это макрос, определенный в
файле &lt;unctrl.h>, автоматически  подключающемся  к
&lt;curses.h>.
<p><dt>
char *keyname (c) <dd>
Возвращается   цепочка  символов,  соответствующая
клавише c.
<p><dt>
filter ( ) 
<dd>Данная процедура является одной  из  тех,  которые
должны вызываться перед initscr. Вызов этой процедуры  означает, что в пределах пакета curses экран
считается имеющим единичную высоту.  В  результате
процедуры  пакета не будут использовать возможностей терминала, подразумевающих знание номера строки на экране.
</dl>
<p align=justify><b>     Использование curscr </b><br>
Спецокно curscr может использоваться только несколькими
процедурами. Если обратиться к процедуре clearok с  аргументом  curscr, то следующее обращение к wrefresh для
любого окна приведет к очистке экрана и затем его  полной перерисовке. Если обратиться к процедуре wrefresh с
аргументом  curscr, то экран немедленно очистится и перерисуется. Именно так большинство программ осуществляет перерисовку экрана. Если curscr  указывается  в  качестве   аргумента   процедур   overlay,  overwite  или
copywin, то доступ производится  к  текущему  состоянию
виртуального экрана терминала.
<p align=justify>   <b>  Устаревшие процедуры </b><br>
Следующие  процедуры  оставлены  только для того, чтобы
обеспечить совместимость с программами, написанными для
старых версий пакета curses. Все они могут быть заменены указанными процедурами:
<table>
<tr valign=top><td>crmode ( )   <td>    заменяется на cbreak ( )
<tr valign=top><td>fixterm ( )    <td>  заменяется на reset_prog_mode ( )
<tr valign=top><td>gettmode ( )  <td>   заменяется на пустую процедуру
<tr valign=top><td>nocrmode ( )  <td>   заменяется на nocbreak ( )
<tr valign=top><td>resetterm ( ) <td>   заменяется на reset_shell_mode ( )
<tr valign=top><td>saveterm ( )  <td>   заменяется на def_prog_mode ( )
<tr valign=top><td>setterm ( )   <td>   заменяется на setupterm ( )
</table>
<a name=atr></a>
<p align=justify><b>АТРИБУТЫ </b><br>
Следующие атрибуты визуализации, определенные  в  файле
&lt;curses.h>,  могут  передаваться  в качестве аргументов
процедурам attron, attroff и attrset.  Их  можно  также
добавить (операцией логическое ИЛИ) к символам, передаваемым процедуре addch.
<dl><dt>
A_STANDOUT <dd>
Режим,  в  котором лучше всего выводить сообщения,
привлекающие внимание.
<p><dt>
A_UNDERLINE <dd>
Подчеркивание.
<p><dt>
A_REVERSE <dd>
Инверсия.
<p><dt>
A_BLINK <dd>
Мерцание.
<p><dt>
A_DIM <dd>
Пониженная яркость.
<p><dt>
A_BOLD <dd>
Выделение - жирность или повышенная яркость.
<p><dt>
A_ALTCHARSET <dd>
Альтернативный набор символов.
<p><dt>
A_CHARTEXT <dd>
Битная  маска  для  выделения  кода  символа  [см.
winch].
<p><dt>
A_ATTRIBUTES <dd>
Битная маска для выделения атрибутов [см. winch].
<p><dt>
A_NORMAL <dd>
Битная  маска для сброса всех атрибутов (например,
attrset (A_NORMAL)).
</dl>
<a name=func></a>
<p align=justify><b>ФУНКЦИОНАЛЯНЫЕ КЛАВИШИ </b><br>
Следующие  коды  функциональных  клавиш, определенные в
файле  &lt;curses.h>,  могут  быть  возвращены  процедурой
getch,  если  установлен  режим keypad. Отметим, что не
все клавиши на конкретном терминале могут поддерживаться, особенно если они не посылают уникальных  кодов,  а
также  если определение клавиши отсутствует в базе данных <a href=TERMINFO.htm>terminfo(4)</a>.
<table>
<tr valign=top><th>Название    <th>  Значение<th> Описание   
<tr valign=top><td>KEY_BREAK  <td>   0401  <td>   клавиша прерывания (ненадежно)   
<tr valign=top><td>KEY_DOWN   <td>   0402  <td>   стрелка вниз   
<tr valign=top><td>KEY_UP     <td>   0403   <td>  стрелка вверх   
<tr valign=top><td>KEY_LEFT   <td>   0404   <td>  стрелка влево   
<tr valign=top><td>KEY_RIGHT  <td>   0405   <td>  стрелка вправо   
<tr valign=top><td>KEY_HOME   <td>   0406   <td>  HOME (стрелка влево-вверх)   
<tr valign=top><td>KEY_BACKSPACE<td> 0407   <td>  забой   
<tr valign=top><td>KEY_F0     <td>   0410   <td>  F0   
<tr valign=top><td>KEY_Fn    <td>    KEY_F0+n <td>Fn, есть место для 64 клавиш   
<tr valign=top><td>KEY_DL    <td>    0510   <td>  DL, удаление строки   
<tr valign=top><td>KEY_IL    <td>    0511  <td>   IL, вставка строки   
<tr valign=top><td>KEY_DC    <td>    0512  <td>   DC, удаление символа   
<tr valign=top><td>KEY_IC    <td>    0513  <td>   IC, вставка символа   
<tr valign=top><td>KEY_EIC  <td>     0514  <td>   выход из режима вставки   
<tr valign=top><td>KEY_CLEAR <td>    0515  <td>   очистка экрана   
<tr valign=top><td>KEY_EOS   <td>    0516  <td>   очистка конца экрана   
<tr valign=top><td>KEY_EOL   <td>    0517  <td>   очистка конца строки   
<tr valign=top><td>KEY_SF    <td>    0520  <td>   роллирование на строку вперед   
<tr valign=top><td>KEY_SR    <td>    0521  <td>   роллирование на строку назад   
<tr valign=top><td>KEY_NPAGE   <td>  0522  <td>   следующая страница   
<tr valign=top><td>KEY_PPAGE  <td>   0523  <td>   предыдущая страница   
<tr valign=top><td>KEY_STAB   <td>   0524  <td>   установить позицию табуляции   
<tr valign=top><td>KEY_CTAB   <td>   0525  <td>   снять позицию табуляции   
<tr valign=top><td>KEY_CATAB  <td>   0526   <td>  снять все позиции табуляции   
<tr valign=top><td>KEY_ENTER  <td>   0527   <td>  ENTER, ввод   
<tr valign=top><td>KEY_SRESET <td>   0530   <td>  мягкий сброс   
<tr valign=top><td>KEY_RESET  <td>   0531   <td>  жесткий сброс   
<tr valign=top><td>KEY_LL     <td>   0533   <td>  стрелка влево-вниз   
<tr valign=top><th colspan=3> дополнительная клавиатура устроена следующим образом:  
<tr valign=top><th align=left>A1 <br>влево  <br>C1<th align=left>   вверх  <br>B2 <br>вниз <th align=left> A3 <br>вправо <br>C3
<tr valign=top><td>KEY_A1    <td>    0534  <td>   A1   
<tr valign=top><td>KEY_A3    <td>    0535  <td>   A3   
<tr valign=top><td>KEY_B2   <td>     0536  <td>   B2   
<tr valign=top><td>KEY_C1     <td>   0537  <td>   C1   
<tr valign=top><td>KEY_C3     <td>   0540  <td>   C3   
<tr valign=top><td>KEY_BTAB   <td>   0541  <td>   обратная табуляция   
<tr valign=top><td>KEY_BEG    <td>   0542  <td>   BEG   
<tr valign=top><td>KEY_CANCEL  <td>  0543  <td>   CANCEL   
<tr valign=top><td>KEY_CLOSE   <td>  0544  <td>   CLOSE   
<tr valign=top><td>KEY_COMMAND <td>  0545  <td>   CMD   
<tr valign=top><td>KEY_COPY    <td>  0546  <td>   COPY   
<tr valign=top><td>KEY_CREATE <td>   0547  <td>   CREATE   
<tr valign=top><td>KEY_END    <td>   0550  <td>   END   
<tr valign=top><td>KEY_EXIT   <td>   0551  <td>   EXIT   
<tr valign=top><td>KEY_MARK    <td>  0554  <td>   MARK   
<tr valign=top><td>KEY_MESSAGE <td>  0555  <td>   MESSAGE   
<tr valign=top><td>KEY_MOVE    <td>  0556  <td>   MOVE   
<tr valign=top><td>KEY_NEXT    <td>  0557  <td>   NEXT   
<tr valign=top><td>KEY_OPEN    <td>  0560  <td>   OPEN   
<tr valign=top><td>KEY_OPTIONS <td>  0561  <td>   OPTIONS   
<tr valign=top><td>KEY_PREVIOUS <td> 0562  <td>   PREVIOUS   
<tr valign=top><td>KEY_REDO    <td>  0563  <td>   REDO   
<tr valign=top><td>KEY_REFERENCE<td> 0564  <td>   REFERENCE   
<tr valign=top><td>KEY_REFRESH <td>  0565  <td>   REFRESH   
<tr valign=top><td>KEY_REPLACE <td>  0566  <td>   REPLACE   
<tr valign=top><td>KEY_RESTART <td>  0567  <td>   RESTART   
<tr valign=top><td>KEY_RESUME  <td>  0570  <td>   RESUME   
<tr valign=top><td>KEY_SAVE   <td>   0571 <td>    SAVE   
<tr valign=top><td>KEY_SBEG     <td> 0572 <td>    SHIFT+BEG   
<tr valign=top><td>KEY_SCANCEL  <td> 0573 <td>    SHIFT+CANCEL   
<tr valign=top><td>KEY_SCOMMAND <td> 0574 <td>    SHIFT+COMMAND   
<tr valign=top><td>KEY_SCOPY    <td> 0575  <td>   SHIFT+COPY   
<tr valign=top><td>KEY_SCREATE  <td> 0576  <td>   SHIFT+CREATE   
<tr valign=top><td>KEY_SDC      <td> 0577  <td>   SHIFT+"удалить символ"   
<tr valign=top><td>KEY_SDL     <td>  0600  <td>   SHIFT+"удалить строку"   
<tr valign=top><td>KEY_SELECT <td>   0601  <td>   SELECT   
<tr valign=top><td>KEY_SEND   <td>   0602  <td>   SEND   
<tr valign=top><td>KEY_SEOL   <td>   0603  <td>   SHIFT+EOL   
<tr valign=top><td>KEY_SEXIT  <td>   0604   <td>  SHIFT+EXIT   
<tr valign=top><td>KEY_SFIND <td>    0605   <td>  SHIFT+FIND   
<tr valign=top><td>KEY_SHELP <td>    0606  <td>   SHIFT+HELP   
<tr valign=top><td>KEY_SHOME <td>    0607  <td>   SHIFT+HOME   
<tr valign=top><td>KEY_SIC    <td>   0610  <td>   SHIFT+"вставить символ"   
<tr valign=top><td>KEY_SLEFT  <td>   0611  <td>   SHIFT+"стрелка влево"   
<tr valign=top><td>KEY_SMESSAGE<td>  0612  <td>   SHIFT+MESSAGE   
<tr valign=top><td>KEY_SMOVE   <td>  0613  <td>   SHIFT+MOVE   
<tr valign=top><td>KEY_SNEXT   <td>  0614  <td>   SHIFT+NEXT   
<tr valign=top><td>KEY_SOPTIONS <td> 0615  <td>   SHIFT+OPTIONS   
<tr valign=top><td>KEY_SPREVIOUS <td>0616  <td>   SHIFT+PREVIOUS   
<tr valign=top><td>KEY_SPRINT    <td>0617  <td>   SHIFT+PRINT   
<tr valign=top><td>KEY_SREDO    <td> 0620  <td>   SHIFT+REDO   
<tr valign=top><td>KEY_SREPLACE <td> 0621  <td>   SHIFT+REPLACE   
<tr valign=top><td>KEY_SRIGHT   <td> 0622  <td>   SHIFT+"стрелка вправо"   
<tr valign=top><td>KEY_SRSUME   <td> 0623   <td>  SHIFT+RESUME   
<tr valign=top><td>KEY_SSAVE   <td>  0624  <td>   SHIFT+SAVE   
<tr valign=top><td>KEY_SSUSPEND <td> 0625  <td>   SHIFT+SUSPEND   
<tr valign=top><td>KEY_SUNDO    <td> 0626  <td>   SHIFT+UNDO   
<tr valign=top><td>KEY_SUSPEND  <td> 0627  <td>   SUSPEND   
<tr valign=top><td>KEY_UNDO     <td> 0630   <td>  UNDO   
</table>
<a name=gr></a>
<p align=justify><b>ПСЕВДОГРАФИКА </b><br>
Следующие переменные могут быть использованы для  рисования  рамочек  на экране терминала с помощью процедуры
waddch. Если соответствующий символ может быть  выведен
на  терминал,  значение переменной будет иметь установленный бит A_ALTCHARSET. В противном случае  переменная
имеет  подразумеваемое  значение.  Отправной точкой для
набора символов послужили возможности терминала vt100.
<table>
<tr valign=top><th>    Имя  <th>  Символ по умолчанию <th>Описание   
<tr valign=top><td>    ACS_ULCORNER<td align=center> +     <td>    левый верхний угол  
<tr valign=top><td>    ACS_LLCORNER<td align=center> +     <td>    левый нижний угол  
<tr valign=top><td>    ACS_URCORNER<td align=center> +     <td>    правый верхний угол  
<tr valign=top><td>    ACS_LRCORNER<td align=center> +     <td>    правый нижний угол  
<tr valign=top><td>    ACS_RTEE    <td align=center> +     <td>    правый край  
<tr valign=top><td>    ACS_LTEE    <td align=center> +     <td>    левый край  
<tr valign=top><td>    ACS_BTEE    <td align=center> +    <td>     нижний край  
<tr valign=top><td>    ACS_TTEE    <td align=center> +    <td>     верхний край  
<tr valign=top><td>    ACS_HLINE   <td align=center> -    <td>     горизонталь  
<tr valign=top><td>    ACS_VLINE   <td align=center> |    <td>     вертикаль  
<tr valign=top><td>    ACS_PLUS    <td align=center> +    <td>     крест  
<tr valign=top><td>    ACS_S1      <td align=center> -    <td>     надчеркивание  
<tr valign=top><td>    ACS_S9      <td align=center> _    <td>     подчеркивание  
<tr valign=top><td>    ACS_DIAMOND <td align=center> +    <td>     алмаз  
<tr valign=top><td>    ACS_CKBOARD <td align=center> :    <td>     клетка  
<tr valign=top><td>    ACS_DEGREE  <td align=center> '    <td>     знак градуса  
<tr valign=top><td>    ACS_PLMINUS <td align=center> #    <td>     плюс/минус  
<tr valign=top><td>    ACS_BULLET  <td align=center> o     <td>    перечисление  
<tr valign=top><td>    ACS_LARROW  <td align=center> &lt;  <td>       стрелка влево  
<tr valign=top><td>    ACS_RARROW  <td align=center> >    <td>     стрелка вправо  
<tr valign=top><td>    ACS_DARROW  <td align=center> v    <td>     стрелка вниз  
<tr valign=top><td>    ACS_UARROW  <td align=center> ^    <td>     стрелка вверх  
<tr valign=top><td>    ACS_BOARD   <td align=center> #    <td>     квадраты  
<tr valign=top><td>    ACS_LANTERN <td align=center> #    <td>     фонарик  
<tr valign=top><td>    ACS_BLOCK   <td align=center> #    <td>     сплошной блок  
</table>
<p align=justify><b>ДИАГНОСТИКА</b><br>
Все процедуры, для  которых  при  описании  не  указано
возвращаемое значение, возвращают целое значение OK при
успешном  завершении и ERR при неудаче.
<p align=justify>Все макросы возвращают значение то же, что и соответствующие  w-процедуры,   кроме   setscrreg,   wsetscrreg,
getsyx, getyx, getbegy, getmaxyx, возвращаемые значения
которых описаны выше.
<p align=justify>В случае ошибки результат процедур, возвращающих значения-указатели, равен (тип *) NULL.
<p align=justify><b>СЮРПРИЗЫ </b><br>
В  настоящее время при использовании пакета curses непрерывно производится проверка ввода  путем  чтения  без
ожидания и возврата символа обратно, если он вдруг оказался прочитанным. Проверка ввода начинается после первого  вызова wgetch. В дальнейшем, когда появится соответствующая поддержка со стороны ядра операционной системы, это будет изменено. Программы, которые  перемешивают  ввод  от пакета curses и свой собственный, должны
вызвать typeahead (-1) для отключения проверки ввода.
<p align=justify>Аргумент функции napms в настоящее время округляется до
ближайшего целого числа секунд.
<p align=justify>Процедура draino (ms) работает, только если значение ms
равно 0.
<p align=justify><b>ПРЕДОСТЕРЕЖЕНИЯ</b><br>
Для  версии операционной системы 3.1 необходимо пользоваться пакетом curses версии 3.1. Программы,  использовавшие пакет curses в операционной системе версии 2 для
выполнения  в  операционной  системе версии 3.1 требуют
пересборки  об ектных  файлов   с   новой   библиотекой
libcurses.a  версии 3.1. Если Ваша программа не пользуется новыми возможностями пакета версии 3.1, то об ектные файлы можно собрать с библиотекой версии 2 и выполнять в операционной системе версии 2.
<p align=justify>Библиотеки <a href=PLOT~1.htm>plot(3X)</a> и <a href=CURSES.htm>curses(3X)</a> используют  одинаковые
имена  процедур  erase  и  move,  причем  версии пакета
curses являются макросами. Если Вам требуется  работать
с  обеими  библиотеками,  то  соответствующие фрагменты
нужно поместить в разные исходные файлы  или  использовать в тексте, работающем с пакетом <a href=PLOT~1.htm>plot(3X)</a>, директивы
#undef move и #undef erase.
<p align=justify>Между вызовами initscr и endwin выводить на экран можно
только  с помощью процедур пакета curses. Использование
для этих целей процедур стандартного пакета ввода/вывода [см. <a href=STDIO.htm>stdio(3S)</a>] может привести к непредсказуемым результатам.
<p><b>СМ. ТАКЖЕ</b><br>
<a href=IOCTL.htm>ioctl(2)</a>,  <a href=PLOT~1.htm>plot(3X)</a>,  <a href=PUTC.htm>putc(3S)</a>,  <a href=SCANF.htm>scanf(3S)</a>,  <a href=STDIO.htm>stdio(3S)</a>,
<a href=SYSTEM.htm>system(3S)</a>,     <a href=VPRINTF.htm>vprintf(3S)</a>,    <a href=PROFILE.htm>profile(4)</a>,    <a href=TERM.htm>term(4)</a>,
<a href=TERMINFO.htm>terminfo(4)</a>, <a href=VARARGS.htm>varargs(5)</a>.<br>
<a href=CC.htm>cc(1)</a>, <a href=LD.htm>ld(1)</a> в Справочнике пользователя.<br>
<a href=TERMIO.htm>termio(7)</a>, <a href=TTY~1.htm>tty(7)</a> в Справочнике администратора.
<table cellspacing=0 cellpadding=0 border=0 background="_pic_/footer0.jpg" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table>
</body>
</html>
